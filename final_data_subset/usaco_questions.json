{
  "735_bronze_the_lost_cow": {
    "name": "The Lost Cow",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=735",
    "test_data_link": "http://www.usaco.org/current/data/lostcow_bronze_open17.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_lostcow_bronze_open17.html",
    "contest_link": "http://www.usaco.org/index.php?page=open17results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "735",
    "problem_id": "735_bronze_the_lost_cow",
    "description": "Farmer John has lost his prize cow Bessie, and he needs to find her!\n\nFortunately, there is only one long path running across the farm, and Farmer\nJohn knows that Bessie has to be at some location on this path.  If we think of\nthe path as a number line, then Farmer John is currently at position $x$ and\nBessie is currently at position $y$ (unknown to Farmer John).  If Farmer John\nonly knew where Bessie was located, he could walk directly to her, traveling a\ndistance of $|x - y|$.  Unfortunately, it is dark outside and Farmer John can't\nsee anything.  The only way he can find Bessie is to walk back and forth until\nhe eventually reaches her position.\n\nTrying to figure out the best strategy for walking back and forth in his search,\nFarmer John consults the computer science research literature and is\nsomewhat amused to find that this exact problem has not only been studied by\ncomputer scientists in the past, but that it is actually called the \"Lost Cow\nProblem\" (this is actually true!).\n\nThe recommended solution for Farmer John to find Bessie is to move to position\n$x+1$, then reverse direction and move to position $x-2$, then to position\n$x+4$, and so on, in a  \"zig zag\" pattern, each step moving twice as far from\nhis initial starting position as before.  As he has read during his study of algorithms\nfor solving the lost cow problem, this approach guarantees that he will at worst\ntravel 9 times the direct distance $|x-y|$ between himself and Bessie before he\nfinds her (this is also true, and the factor of 9 is actually the smallest such\nworst case guarantee any strategy can achieve).\n\nFarmer John is curious to verify this result.  Given $x$ and $y$, please compute\nthe  total distance he will travel according to the zig-zag search strategy above\nuntil he finds Bessie.\n\nINPUT FORMAT:\nThe single line of input contains two distinct space-separated integers $x$ and\n$y$.  Both are in the range $0 \\ldots 1,000$.\n\nOUTPUT FORMAT:\nPrint one line of output, containing the distance Farmer John will travel to\nreach Bessie.\n\nSAMPLE INPUT:\n3 6\nSAMPLE OUTPUT: \n9\n\n\nProblem credits: Brian Dean\n",
    "num_tests": 10,
    "solution": "\nby Nathan Pinsker\nWe can simulate this problem by running each step of Farmer John's movement. At\neach step, we check Farmer John's starting position and his intended ending\nposition, and check to see whether that overlaps Bessie's position. If it does\nnot, then we add the full distance to a running total and move poor Farmer John\nback to his starting position. Otherwise, we add the distance between FJ's\ncurrent position and Bessie's position to the running total, and return that\ntotal as our answer.\nHere's Jonathan Paulson's code. See the comments for some more insight on what\nhe's doing:\n\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  ll x, y;\n  cin >> x >> y;\n\n  ll ans = 0;\n  ll by = 1;\n  ll dir = 1;\n  while(true) {\n    // dir == 1 means Farmer John is moving to the right, and\n    // dir == -1 means he is moving to the left.\n    if((dir==1 && x<=y && y<=x+by) || (dir==-1 && x-by<=y && y<=x)) {\n      // We found Bessie!\n      ans += abs(y-x);\n      cout << ans << endl;\n      break;\n    } else {\n      // Didn't find Bessie! Add to our running total the cost of\n      // moving 'by' units away from the start and back again.\n      // Then multiply our next move's length by 2 and switch direction.\n      ans += by*2;\n      by *= 2;\n      dir *= -1;\n    }\n  }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 6",
        "output": "9",
        "explanation": ""
      }
    ],
    "description_no_samples": "Farmer John has lost his prize cow Bessie, and he needs to find her!\n\nFortunately, there is only one long path running across the farm, and Farmer\nJohn knows that Bessie has to be at some location on this path.  If we think of\nthe path as a number line, then Farmer John is currently at position $x$ and\nBessie is currently at position $y$ (unknown to Farmer John).  If Farmer John\nonly knew where Bessie was located, he could walk directly to her, traveling a\ndistance of $|x - y|$.  Unfortunately, it is dark outside and Farmer John can't\nsee anything.  The only way he can find Bessie is to walk back and forth until\nhe eventually reaches her position.\n\nTrying to figure out the best strategy for walking back and forth in his search,\nFarmer John consults the computer science research literature and is\nsomewhat amused to find that this exact problem has not only been studied by\ncomputer scientists in the past, but that it is actually called the \"Lost Cow\nProblem\" (this is actually true!).\n\nThe recommended solution for Farmer John to find Bessie is to move to position\n$x+1$, then reverse direction and move to position $x-2$, then to position\n$x+4$, and so on, in a  \"zig zag\" pattern, each step moving twice as far from\nhis initial starting position as before.  As he has read during his study of algorithms\nfor solving the lost cow problem, this approach guarantees that he will at worst\ntravel 9 times the direct distance $|x-y|$ between himself and Bessie before he\nfinds her (this is also true, and the factor of 9 is actually the smallest such\nworst case guarantee any strategy can achieve).\n\nFarmer John is curious to verify this result.  Given $x$ and $y$, please compute\nthe  total distance he will travel according to the zig-zag search strategy above\nuntil he finds Bessie.\n\nINPUT FORMAT:\nThe single line of input contains two distinct space-separated integers $x$ and\n$y$.  Both are in the range $0 \\ldots 1,000$.\n\nOUTPUT FORMAT:\nPrint one line of output, containing the distance Farmer John will travel to\nreach Bessie.\n\n",
    "num_samples": 1
  },
  "546_bronze_bessie_gets_even": {
    "name": "Bessie Gets Even",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=546",
    "test_data_link": "http://www.usaco.org/current/data/geteven_bronze.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_geteven_bronze.html",
    "contest_link": "http://www.usaco.org/index.php?page=open15results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "546",
    "problem_id": "546_bronze_bessie_gets_even",
    "description": "Farmer John and Bessie the cow love to exchange math puzzles in their free time.\nThe last puzzle FJ gave Bessie was quite difficult and she failed to solve it. \nNow she wants to get even with FJ by giving him a challenging puzzle.\nBessie gives FJ the expression $(B+E+S+S+I+E)(G+O+E+S)(M+O+O)$, containing the\nseven variables $B,E,S,I,G,O,M$ (the \"$O$\" is a variable, not a zero).  For each\nvariable, she gives FJ a list of up to 20 integer values the variable can\npossibly take.  She asks FJ to count the number of different ways he can assign\nvalues to the variables so the entire expression evaluates to an even number.\nINPUT FORMAT:\nThe first line of the input contains an integer $N$.  The next $N$ lines each \ncontain a variable and a possible value for that variable.  Each variable will\nappear in this list at least once and at most 20 times.  No possible value will\nbe listed more than once for the same variable.  All possible values will be in\nthe range $-300$ to $300$.\n\nOUTPUT FORMAT:\nPrint a single integer, giving the number of ways FJ can assign values to\nvariables so the expression above evaluates to an even result.\n\nSAMPLE INPUT:10\nB 2\nE 5\nS 7\nI 10\nO 16\nM 19\nB 3\nG 1\nI 9\nM 2\nSAMPLE OUTPUT: 6\n\nThere are six possible variable assignments:\n\n(B,E,S,I,G,O,M) = (2, 5, 7, 10, 1, 16, 19) -> 53,244\n                = (2, 5, 7, 10, 1, 16, 2 ) -> 35,496\n                = (2, 5, 7, 9,  1, 16, 2 ) -> 34,510\n                = (3, 5, 7, 10, 1, 16, 2 ) -> 36,482\n                = (3, 5, 7, 9,  1, 16, 19) -> 53,244\n                = (3, 5, 7, 9,  1, 16, 2 ) -> 35,496\n\nNote that (2,5,7,10,1,16,19) and (3,5,7,9,1,16,19) count as different\nassignments even though they yield the same value because the variables are\nassigned differently.\n[Problem credits: Brian Dean, 2015]\n",
    "num_tests": 10,
    "solution": "\n(Analysis by Nick Wu)\nIn a pure brute-force solution, we would try every possible combination of\nassignments of variables to values. There are 7 variables, with at most 20\nvalues per variable, for a total of $20^7$ combinations. This is over one\nbillion combinations to check, which is too many to check.\nOne approach you can try is to count the number of ways you can force the\nexpression to be odd. When checking if a combination is odd, you can immediately\nnote a couple things - for example, M must be odd. Also, if you recursively\nassign values to variables and you see that one of the three terms in the\nproduct is even, you can stop all combinations for variables that you haven't\nyet inspected.\nThere is a much faster approach though that removes the dependency on checking\ndifferent combinations. Since you want to check if the product is even or odd,\nthe important thing to know for each variable is how many even values that\nvariable can take on, and how many odd values that variable can take on. Once\nyou've done that, you can assign to each variable a parity and see if with those\nparities, the product is even. If so, you can count how many combinations there\nare with those parities, and then sum the parities.\nWith this approach, there are only $2^7=128$ combinations of parities to check,\nwhich is guaranteed to work quickly enough.\nHere is Mark Gordon's code:\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint num[256][2];\n\nbool is_even(int x) {\n  return x % 2 == 0;\n}\n\nint main() {\n  freopen(\"geteven.in\", \"r\", stdin);\n  freopen(\"geteven.out\", \"w\", stdout);\n\n  int N;\n  cin >> N;\n\n  for (int i = 0; i < N; i++) {\n    char letter;\n    int val;\n    cin >> letter >> val;\n\n    if (is_even(val)) {\n      num[letter][0]++;\n    } else {\n      num[letter][1]++;\n    }\n  }\n\n  int result = 0;\n\n  /* Try every possible way that the variables could be even or odd. */\n  for(int B = 0; B < 2; B++)\n  for(int E = 0; E < 2; E++)\n  for(int S = 0; S < 2; S++)\n  for(int I = 0; I < 2; I++)\n  for(int G = 0; G < 2; G++)\n  for(int O = 0; O < 2; O++)\n  for(int M = 0; M < 2; M++) {\n    if (is_even((B + E + S + S + I + E) * (G + O + E + S) * (M + O + O))) {\n      /* If the expression is even then add the number of variable assignments\n       * that have the variables odd/even.\n       */\n      result += num['B'][B] * num['E'][E] * num['S'][S] * num['I'][I] *\n                num['G'][G] * num['O'][O] * num['M'][M];\n    }\n  }\n  cout << result << endl;\n\n  return 0;\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "10\nB 2\nE 5\nS 7\nI 10\nO 16\nM 19\nB 3\nG 1\nI 9\nM 2",
        "output": "6",
        "explanation": "There are six possible variable assignments:\n\n(B,E,S,I,G,O,M) = (2, 5, 7, 10, 1, 16, 19) -> 53,244\n                = (2, 5, 7, 10, 1, 16, 2 ) -> 35,496\n                = (2, 5, 7, 9,  1, 16, 2 ) -> 34,510\n                = (3, 5, 7, 10, 1, 16, 2 ) -> 36,482\n                = (3, 5, 7, 9,  1, 16, 19) -> 53,244\n                = (3, 5, 7, 9,  1, 16, 2 ) -> 35,496\n\nNote that (2,5,7,10,1,16,19) and (3,5,7,9,1,16,19) count as different\nassignments even though they yield the same value because the variables are\nassigned differently.\n["
      }
    ],
    "description_no_samples": "Farmer John and Bessie the cow love to exchange math puzzles in their free time.\nThe last puzzle FJ gave Bessie was quite difficult and she failed to solve it. \nNow she wants to get even with FJ by giving him a challenging puzzle.\nBessie gives FJ the expression $(B+E+S+S+I+E)(G+O+E+S)(M+O+O)$, containing the\nseven variables $B,E,S,I,G,O,M$ (the \"$O$\" is a variable, not a zero).  For each\nvariable, she gives FJ a list of up to 20 integer values the variable can\npossibly take.  She asks FJ to count the number of different ways he can assign\nvalues to the variables so the entire expression evaluates to an even number.\nINPUT FORMAT:\nThe first line of the input contains an integer $N$.  The next $N$ lines each \ncontain a variable and a possible value for that variable.  Each variable will\nappear in this list at least once and at most 20 times.  No possible value will\nbe listed more than once for the same variable.  All possible values will be in\nthe range $-300$ to $300$.\n\nOUTPUT FORMAT:\nPrint a single integer, giving the number of ways FJ can assign values to\nvariables so the expression above evaluates to an even result.\n\n",
    "num_samples": 1
  },
  "855_bronze_mixing_milk": {
    "name": "Mixing Milk",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=855",
    "test_data_link": "http://www.usaco.org/current/data/mixmilk_bronze_dec18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_mixmilk_bronze_dec18.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "855",
    "problem_id": "855_bronze_mixing_milk",
    "description": "Farming is competitive business -- particularly milk production.  Farmer John\nfigures that if he doesn't innovate in his milk production methods, his dairy\nbusiness could get creamed!\n\nFortunately, Farmer John has a good idea.  His three prize dairy cows Bessie,\nElsie, and Mildred each produce milk with a slightly different taste, and he\nplans to mix these together to get the perfect blend of flavors. \n\nTo mix the three different milks, he takes three buckets containing milk from\nthe three cows.  The buckets may have different sizes, and may not be completely\nfull.  He then pours bucket 1 into bucket 2, then bucket 2 into bucket 3, then\nbucket 3  into bucket 1, then bucket 1 into bucket 2, and so on in a cyclic\nfashion, for a total of 100 pour operations (so the 100th pour would be from\nbucket 1 into bucket 2).  When Farmer John pours from bucket $a$ into bucket\n$b$, he pours as much milk as possible until either bucket $a$ becomes empty or\nbucket $b$ becomes full.\n\nPlease tell Farmer John how much milk will be in each bucket after he finishes\nall 100 pours.\n\nINPUT FORMAT:\nThe first line of the input file contains two space-separated integers: the\ncapacity $c_1$ of the first bucket, and the amount of milk $m_1$ in the first\nbucket. Both $c_1$ and $m_1$ are positive and at most 1 billion, with\n$c_1 \\geq m_1$. The second and third lines are similar, containing capacities\nand milk amounts for the  second and third buckets.\n\nOUTPUT FORMAT:\nPlease print three lines of output, giving the final amount of milk in each\nbucket, after  100 pour operations.\n\nSAMPLE INPUT:\n10 3\n11 4\n12 5\nSAMPLE OUTPUT: \n0\n10\n2\n\nIn this example, the milk in each bucket is as follows during the sequence of\npours:\n\n\nInitial State: 3  4  5\n1. Pour 1->2:  0  7  5\n2. Pour 2->3:  0  0  12\n3. Pour 3->1:  10 0  2\n4. Pour 1->2:  0  10 2\n5. Pour 2->3:  0  0  12\n(The last three states then repeat in a cycle ...)\n\n\nProblem credits: Brian Dean\n",
    "num_tests": 10,
    "solution": "\n(Analysis by  Dhruv Rohatgi )\nWe can simulate the pours one by one, keeping track of the amount of milk in\neach bucket. For example, if we pour from bucket $1$ into bucket $2$, and bucket\n$1$ has size $c_1$ and bucket $2$ has size $c_2$, and before the pour, bucket\n$1$ has $m_1$ units of milk and bucket $2$ has $m_2$ units, then the amount of\nmilk poured is $\\min(m_1, c_2 - m_2)$. Therefore after the pour, the amount of\nmilk in bucket $1$ is $m_1 - \\min(m_1, c_2 - m_2)$. And the amount of milk in\nbucket $2$ is $m_2 + \\min(m_1, c_2 - m_2)$. The formulas for pouring bucket $2$\ninto bucket $3$, or bucket $3$ into bucket $1$, are analogous.\nSince there are only $100$ pours, and each pour takes only a constant number of\narithmetic operations to simulate, this algorithm will run very fast.\nHere is Travis Hance's code:\n\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n \nvoid pour(int& c1, int& m1, int& c2, int& m2) {\n  int amt = min(m1, c2 - m2);\n  m1 -= amt;\n  m2 += amt;\n}\n \nint main() {\n  int c1, c2, c3;\n  int m1, m2, m3;\n  scanf(\"%d %d\", &c1, &m1);\n  scanf(\"%d %d\", &c2, &m2);\n  scanf(\"%d %d\", &c3, &m3);\n \n  for (int i = 0; i < 33; i++) {\n    pour(c1, m1, c2, m2);\n    pour(c2, m2, c3, m3);\n    pour(c3, m3, c1, m1);\n  }\n  pour(c1, m1, c2, m2);\n \n  printf(\"%d\\n%d\\n%d\\n\", m1, m2, m3);\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "10 3\n11 4\n12 5",
        "output": "0\n10\n2",
        "explanation": "In this example, the milk in each bucket is as follows during the sequence of\npours:\n\n\nInitial State: 3  4  5\n1. Pour 1->2:  0  7  5\n2. Pour 2->3:  0  0  12\n3. Pour 3->1:  10 0  2\n4. Pour 1->2:  0  10 2\n5. Pour 2->3:  0  0  12\n(The last three states then repeat in a cycle ...)"
      }
    ],
    "description_no_samples": "Farming is competitive business -- particularly milk production.  Farmer John\nfigures that if he doesn't innovate in his milk production methods, his dairy\nbusiness could get creamed!\n\nFortunately, Farmer John has a good idea.  His three prize dairy cows Bessie,\nElsie, and Mildred each produce milk with a slightly different taste, and he\nplans to mix these together to get the perfect blend of flavors. \n\nTo mix the three different milks, he takes three buckets containing milk from\nthe three cows.  The buckets may have different sizes, and may not be completely\nfull.  He then pours bucket 1 into bucket 2, then bucket 2 into bucket 3, then\nbucket 3  into bucket 1, then bucket 1 into bucket 2, and so on in a cyclic\nfashion, for a total of 100 pour operations (so the 100th pour would be from\nbucket 1 into bucket 2).  When Farmer John pours from bucket $a$ into bucket\n$b$, he pours as much milk as possible until either bucket $a$ becomes empty or\nbucket $b$ becomes full.\n\nPlease tell Farmer John how much milk will be in each bucket after he finishes\nall 100 pours.\n\nINPUT FORMAT:\nThe first line of the input file contains two space-separated integers: the\ncapacity $c_1$ of the first bucket, and the amount of milk $m_1$ in the first\nbucket. Both $c_1$ and $m_1$ are positive and at most 1 billion, with\n$c_1 \\geq m_1$. The second and third lines are similar, containing capacities\nand milk amounts for the  second and third buckets.\n\nOUTPUT FORMAT:\nPlease print three lines of output, giving the final amount of milk in each\nbucket, after  100 pour operations.\n\n",
    "num_samples": 1
  },
  "430_bronze_odometer": {
    "name": "Odometer",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=430",
    "test_data_link": "http://www.usaco.org/current/data/odometer_bronze.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_odometer_bronze.html",
    "contest_link": "http://www.usaco.org/index.php?page=open14results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=open14problems",
    "problem_level": "bronze",
    "cp_id": "430",
    "problem_id": "430_bronze_odometer",
    "description": "Problem 1: Odometer [Brian Dean, 2014]\n\nFarmer John's cows are on a road trip!  The odometer on their car displays\nan integer mileage value, starting at X (100 <= X <= 10^16) miles at the\nbeginning of their trip and ending at Y (X <= Y <= 10^16) miles at the end\nof their trip.  Whenever the odometer displays an 'interesting' number\n(including at the start and end of the trip) the cows will moo.  A number\nis 'interesting' if when you look at all its digits except for leading\nzeros, all of these are the same except for one single digit that is\ndifferent.  For example, the numbers 33323 and 110 are interesting, while\nthe numbers 9779 and 55555 are not.\n\nHelp FJ count how many times the cows will moo during the trip. \n\nFor half of the test cases, the constraint X <= Y <= 10^6 will hold.  Note\nthat to store a number as large as 10^16, you will need a 64-bit integer\ndata type such as a \"long long\" in C/C++.\n\nPROBLEM NAME: odometer\n\nINPUT FORMAT:\n\n* Line 1: The first line will contain two integers, X and Y, separated\n        by a space.\n\nSAMPLE INPUT:\n\n110 133\n\nINPUT DETAILS:\n\nThe trip starts with the odometer at 110 and ends at 133.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer containing how many times the cows will moo\n        during the trip.\n\nSAMPLE OUTPUT:\n\n13\n\nOUTPUT DETAILS:\n\nThe cows moo when the odometer reads 110, 112, 113, 114, 115, 116,\n117, 118, 119, 121, 122, 131, and 133.\n",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Odometer by Nathan Pinsker\n\nAlthough the numbers we are working with can be quite large (up to 10^16!) \r\nit actually turns out that the number of interesting numbers is quite small. In \r\nfact, we can construct all such numbers by taking every number with repeated \r\ndigits (e.g. 3333333333) and changing exactly one digit, then checking whether \r\nthe new number is between X and Y. There are at most 17 digits in our number \r\nthat we can change, and there are 9 possible new digits to change it to, so the \r\nnumber of interesting numbers we could possibly find is about 17*9, which is \r\ndefinitely small enough to deal with. We can solve this problem by actually \r\nconstructing all possible numbers composed of a single unique digit, then \r\nbrute-force changing these numbers in every possible allowed way, and checking \r\neach of these numbers to see if it is in the interval [X, Y].\r\n\r\nBelow is Mark Gordon's solution. He uses the variable 'sz' to denote the size \r\nof the number he is considering, 'd0' to denote the digit of the original \r\nnumber, and 'd1' to denote the new digit's value.  A full list of all 10774\r\ninteresting numbers within the constraints of this problem is given here.\r\n\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <cstdio>\r\n#include <cassert>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n  freopen(\"odometer.in\", \"r\", stdin);\r\n  freopen(\"odometer.out\", \"w\", stdout);\r\n\r\n  long long X, Y;\r\n  cin >> X >> Y;\r\n\r\n  int result = 0;\r\n  for(int sz = 3; sz <= 17; sz++) {\r\n    for(int d0 = 0; d0 < 10; d0++) {\r\n      string S(sz, '0' + d0);\r\n      for(int d1 = 0; d1 < 10; d1++) {\r\n        if(d0 == d1) continue;\r\n\r\n        for(int i = 0; i < sz; i++) {\r\n          S[i] = '0' + d1;\r\n\r\n          long long num = atoll(S.c_str());\r\n          if(S[0] != '0' && X <= num && num <= Y) {\r\n            ++result;\r\n          }\r\n\r\n          S[i] = '0' + d0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  cout << result << endl;\r\n  return 0;\r\n}\r\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "110 133",
        "output": "13",
        "input_explanation": "The trip starts with the odometer at 110 and ends at 133.",
        "output_explanation": "The cows moo when the odometer reads 110, 112, 113, 114, 115, 116,\n117, 118, 119, 121, 122, 131, and 133.",
        "explanation": "The trip starts with the odometer at 110 and ends at 133.\nThe cows moo when the odometer reads 110, 112, 113, 114, 115, 116,\n117, 118, 119, 121, 122, 131, and 133."
      }
    ],
    "description_no_samples": "Problem 1: Odometer [Brian Dean, 2014]\n\nFarmer John's cows are on a road trip!  The odometer on their car displays\nan integer mileage value, starting at X (100 <= X <= 10^16) miles at the\nbeginning of their trip and ending at Y (X <= Y <= 10^16) miles at the end\nof their trip.  Whenever the odometer displays an 'interesting' number\n(including at the start and end of the trip) the cows will moo.  A number\nis 'interesting' if when you look at all its digits except for leading\nzeros, all of these are the same except for one single digit that is\ndifferent.  For example, the numbers 33323 and 110 are interesting, while\nthe numbers 9779 and 55555 are not.\n\nHelp FJ count how many times the cows will moo during the trip. \n\nFor half of the test cases, the constraint X <= Y <= 10^6 will hold.  Note\nthat to store a number as large as 10^16, you will need a 64-bit integer\ndata type such as a \"long long\" in C/C++.\n\nPROBLEM NAME: odometer\n\nINPUT FORMAT:\n\n* Line 1: The first line will contain two integers, X and Y, separated\n        by a space.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer containing how many times the cows will moo\n        during the trip.",
    "description_raw": "Problem 1: Odometer [Brian Dean, 2014]\n\nFarmer John's cows are on a road trip!  The odometer on their car displays\nan integer mileage value, starting at X (100 <= X <= 10^16) miles at the\nbeginning of their trip and ending at Y (X <= Y <= 10^16) miles at the end\nof their trip.  Whenever the odometer displays an 'interesting' number\n(including at the start and end of the trip) the cows will moo.  A number\nis 'interesting' if when you look at all its digits except for leading\nzeros, all of these are the same except for one single digit that is\ndifferent.  For example, the numbers 33323 and 110 are interesting, while\nthe numbers 9779 and 55555 are not.\n\nHelp FJ count how many times the cows will moo during the trip. \n\nFor half of the test cases, the constraint X <= Y <= 10^6 will hold.  Note\nthat to store a number as large as 10^16, you will need a 64-bit integer\ndata type such as a \"long long\" in C/C++.\n\nPROBLEM NAME: odometer",
    "input_format": "* Line 1: The first line will contain two integers, X and Y, separated\n        by a space.",
    "output_format": "* Line 1: A single integer containing how many times the cows will moo\n        during the trip.",
    "num_samples": 1
  },
  "1132_bronze_acowdemia_ii": {
    "name": "Acowdemia II",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1132",
    "test_data_link": "http://www.usaco.org/current/data/prob2_bronze_open21.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_bronze_open21.html",
    "contest_link": "http://www.usaco.org/index.php?page=open21results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "1132",
    "problem_id": "1132_bronze_acowdemia_ii",
    "description": "Bessie is applying to computer science graduate school, and has secured an\ninterview at a prestigious computer science lab. However, to avoid offending\nanyone, Bessie is interested in determining the relative seniority of the $N$\ncurrent members of the lab ($1 \\leq N \\leq 100$). No two members of the lab have\nthe same seniority, but determining their seniorities may be tricky. To do so,\nBessie will look at the lab's publications.\n\nEach publication contains an author list, which is an ordering of all $N$ lab\nmembers. The list is in decreasing order of the effort each lab member\ncontributed to the paper. If multiple researchers put in equivalent effort, then\nthey are ordered alphabetically. Since more senior lab members have additional\nadministrative duties, a  a more senior researcher never puts in more effort\nthan a more junior researcher. \n\nFor example, in a lab consisting of a junior student Elsie, a more senior Prof.\nMildred, and a very senior Prof. Dean, then there may be a paper\n(Elsie-Mildred-Dean) if all of them put in different amounts of effort (i.e.\nElsie puts in more effort than Mildred, and Mildred more than Dean). However,\nthey may also have a paper in the order (Elsie-Dean-Mildred) if Mildred and Dean\nput in the same amount of effort and Elsie puts in more effort.\n\nGiven $K$ publications from this lab ($1 \\leq K \\leq 100$), help Bessie\ndetermine for all pairs of researchers in this lab who is more senior, if it's\npossible to tell.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two integers, $K$ and $N$.\n\nThe second line contains $N$ space-separated strings, giving the names of the\nmembers of  the lab.  Each consists of lowercase letters and is at most 10\ncharacters long.\n\nEach of the next $K$ lines contains $N$ space-separated strings, indicating the\nauthor list for one publication.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe output should consist of $N$ lines, with $N$ characters per line. On line\n$i$, for any $j \\neq i$, character $j$ should be $1$ if the $i$th member is\ndefinitely more senior than the $j$th member, $0$ if the $i$th member is\ndefinitely more junior than the $j$th member, and $?$ if it's impossible to tell\nfrom the given publications.\n\nCharacter $i$ on line $i$ should be $B$ because that's Bessie's favorite letter.\n\nSAMPLE INPUT:\n1 3\ndean elsie mildred\nelsie mildred dean\nSAMPLE OUTPUT: \nB11\n0B?\n0?B\n\nIn this first example, the single paper (elsie-mildred-dean) does not give \nenough information to determine whether Elsie is more senior than Mildred or\nvice versa.  However, one can deduce that Dean must be more senior than both, so\nthe seniority orderings Elsie<Mildred<Dean and Mildred<Elsie<Dean are both\npossible.\n\nSAMPLE INPUT:\n2 3\nelsie mildred dean\nelsie mildred dean\nelsie dean mildred\nSAMPLE OUTPUT: \nB00\n1B0\n11B\n\nIn this second example, the only seniority ordering consistent with both papers\nis Elsie<Mildred<Dean, since one can second paper builds on the knowledge  from\nthe first example above and helps us deduce that Mildred is also more senior than\nElsie.\n\n\nProblem credits: Dhruv Rohatgi\n",
    "num_tests": 10,
    "solution": "\n(Analysis by Benjamin Qi)\nLet's start with $K=1$. Given an author list with names $n_1,n_2,\\ldots,n_N$,  how\ndo we tell which members are more senior than others? \nIf\n$n_i<n_{i+1}<\\cdots<n_j$,  then we receive no information about the relative\nseniorities of members $n_i,\\ldots,n_j$;  perhaps all of these members put in\nthe same amount of effort. In particular, $n_1<n_2<\\cdots <n_N$ is consistent\nwith any seniority ordering.\nHowever, if there exists $i$ such that $n_i>n_{i+1}$, then member $n_i$\ndefinitely put in more effort than member $n_{i+1}$, so all of members\n$n_1,\\ldots,n_i$ must be more junior than members $n_{i+1}\\ldots n_N$. In other\nwords, if $i<j$ and $n_i,n_{i+1},\\ldots,n_j$ are not in alphabetical\norder, then we know that $n_i$ is definitely more junior than $n_j$. \nFor $K>1$, we simply accumulate the results over all publications.\nDanny Mittal's code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n \npublic class AcowdemiaII {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        Map<String, Integer> members = new HashMap<>();\n        tokenizer = new StringTokenizer(in.readLine());\n        for (int a = 0; a < n; a++) {\n            members.put(tokenizer.nextToken(), a);\n        }\n        char[][] answer = new char[n][n];\n        for (int a = 0; a < n; a++) {\n            Arrays.fill(answer[a], '?');\n            answer[a][a] = 'B';\n        }\n        for (int j = 0; j < k; j++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            String[] publication = new String[n];\n            for (int x = 0; x < n; x++) {\n                publication[x] = tokenizer.nextToken();\n            }\n            for (int x = 0; x < n; x++) {\n                boolean alphabetical = true;\n                for (int y = x + 1; y < n; y++) {\n                    if (publication[y - 1].compareTo(publication[y]) > 0) {\n                        alphabetical = false;\n                    }\n                    if (!alphabetical) {\n                        int a = members.get(publication[x]);\n                        int b = members.get(publication[y]);\n                        answer[a][b] = '0';\n                        answer[b][a] = '1';\n                    }\n                }\n            }\n        }\n        StringBuilder out = new StringBuilder();\n        for (int a = 0; a < n; a++) {\n            out.append(answer[a]).append('\\n');\n        }\n        System.out.print(out);\n    }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "1 3\ndean elsie mildred\nelsie mildred dean",
        "output": "B11\n0B?\n0?B",
        "explanation": "In this first example, the single paper (elsie-mildred-dean) does not give \nenough information to determine whether Elsie is more senior than Mildred or\nvice versa.  However, one can deduce that Dean must be more senior than both, so\nthe seniority orderings Elsie<Mildred<Dean and Mildred<Elsie<Dean are both\npossible."
      },
      {
        "input": "2 3\nelsie mildred dean\nelsie mildred dean\nelsie dean mildred",
        "output": "B00\n1B0\n11B",
        "explanation": "In this second example, the only seniority ordering consistent with both papers\nis Elsie<Mildred<Dean, since one can second paper builds on the knowledge  from\nthe first example above and helps us deduce that Mildred is also more senior than\nElsie."
      }
    ],
    "description_no_samples": "Bessie is applying to computer science graduate school, and has secured an\ninterview at a prestigious computer science lab. However, to avoid offending\nanyone, Bessie is interested in determining the relative seniority of the $N$\ncurrent members of the lab ($1 \\leq N \\leq 100$). No two members of the lab have\nthe same seniority, but determining their seniorities may be tricky. To do so,\nBessie will look at the lab's publications.\n\nEach publication contains an author list, which is an ordering of all $N$ lab\nmembers. The list is in decreasing order of the effort each lab member\ncontributed to the paper. If multiple researchers put in equivalent effort, then\nthey are ordered alphabetically. Since more senior lab members have additional\nadministrative duties, a  a more senior researcher never puts in more effort\nthan a more junior researcher. \n\nFor example, in a lab consisting of a junior student Elsie, a more senior Prof.\nMildred, and a very senior Prof. Dean, then there may be a paper\n(Elsie-Mildred-Dean) if all of them put in different amounts of effort (i.e.\nElsie puts in more effort than Mildred, and Mildred more than Dean). However,\nthey may also have a paper in the order (Elsie-Dean-Mildred) if Mildred and Dean\nput in the same amount of effort and Elsie puts in more effort.\n\nGiven $K$ publications from this lab ($1 \\leq K \\leq 100$), help Bessie\ndetermine for all pairs of researchers in this lab who is more senior, if it's\npossible to tell.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two integers, $K$ and $N$.\n\nThe second line contains $N$ space-separated strings, giving the names of the\nmembers of  the lab.  Each consists of lowercase letters and is at most 10\ncharacters long.\n\nEach of the next $K$ lines contains $N$ space-separated strings, indicating the\nauthor list for one publication.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe output should consist of $N$ lines, with $N$ characters per line. On line\n$i$, for any $j \\neq i$, character $j$ should be $1$ if the $i$th member is\ndefinitely more senior than the $j$th member, $0$ if the $i$th member is\ndefinitely more junior than the $j$th member, and $?$ if it's impossible to tell\nfrom the given publications.\n\nCharacter $i$ on line $i$ should be $B$ because that's Bessie's favorite letter.\n\n",
    "num_samples": 2
  },
  "358_bronze_record_keeping": {
    "name": "Record Keeping",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=358",
    "test_data_link": "http://www.usaco.org/current/data/records.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_records.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec13results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=dec13problems",
    "problem_level": "bronze",
    "cp_id": "358",
    "problem_id": "358_bronze_record_keeping",
    "description": "Problem 1: Record Keeping [Brian Dean, 2013]\n\nFarmer John has been keeping detailed records of his cows as they enter the\nbarn for milking.  Each hour, a group of 3 cows enters the barn, and Farmer\nJohn writes down their names.  For example over a 5-hour period, he might\nwrite down the following list, where each row corresponds to a group\nentering the barn:\n\nBESSIE ELSIE MATILDA\nFRAN BESSIE INGRID\nBESSIE ELSIE MATILDA\nMATILDA INGRID FRAN\nELSIE BESSIE MATILDA\n\nFarmer John notes that the same group of cows may appear several times on\nhis list; in the example above, the group of BESSIE, ELSIE, and MATILDA\nappears three times (even though Farmer John didn't necessarily write their\nnames in the same order every time they entered the barn).  \n\nPlease help Farmer John count the number of occurrences of the group\nentering the barn the most.\n\nPROBLEM NAME: records\n\nINPUT FORMAT:\n\n* Line 1: The number of hours, N, for which Farmer John keeps records\n        (1 <= N <= 1000).\n\n* Lines 2..1+N: Each line contains a list of three space-separated cow\n        names.  Each name is between 1 and 10 characters and uses only\n        the letters A-Z.\n\nSAMPLE INPUT:\n\n5\nBESSIE ELSIE MATILDA\nFRAN BESSIE INGRID\nBESSIE ELSIE MATILDA\nMATILDA INGRID FRAN\nELSIE BESSIE MATILDA\n\nOUTPUT FORMAT:\n\n* Line 1: The number of occurrences of the group entering the barn the\n        most often.\n\nSAMPLE OUTPUT:\n\n3\n\nOUTPUT DETAILS:\n\nThe group {BESSIE, ELSIE, MATILDA} enters the barn on three separate occasions.\n",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Record Keeping by Fatih Gelgi\n\nThe trivial idea is to try all possibilities: check how many times each\r\ngroup appears in the list. We know that the order of cows can be different in\r\nsame groups. Trying all cow permutations in a group complicates coding.\r\nInstead, a better idea is to sort the cows alphabetically in a group and store\r\nthem in a string. Then we can search each string in the list easily. For\r\ninstance, the sample will input will be as follows after sorting each group:\n\r\nBESSIE ELSIE MATILDA\r\nBESSIE FRAN INGRID\r\nBESSIE ELSIE MATILDA\r\nFRAN INGRID MATILDA\r\nBESSIE ELSIE MATILDA\r\n\nNow, we can clearly see the string \"BESSIE ELSIE MATILDA\" appears in the\r\nlist three times. Note that we put space between cows instead of having\r\n\"BESSIEELSIEMATILDA\". Otherwise, the solution will fail in the following input\r\n- \"BESSI EELSIE MATILDA\" is not same as \"BESSIE ELSIE MATILDA\":\n\r\nBESSI EELSIE MATILDA\r\nBESSIE FRAN INGRID\r\nBESSIE ELSIE MATILDA\r\nFRAN INGRID MATILDA\r\nBESSIE ELSIE MATILDA\r\n\nThe running time will be O(N^2) since we search each string in the entire\r\nlist. N is small hence the solution is fast enough for the problem. Sample code\r\nis as follows:\n\r\n// O(N^2)\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint n;\r\nstring groups[1001];\r\n\r\nint main()\r\n{\r\n\tifstream fin(\"records.in\");\r\n\tfin >> n;\r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tstring str[3];\r\n\t\tfin >> str[0] >> str[1] >> str[2];\r\n\t\tsort(str,str+3);\t\t\t\t// sort each group\r\n\t\tgroups[i]=str[0]+\" \"+str[1]+\" \"+str[2];\t\t// and convert it to a string\r\n\t}\r\n\tfin.close();\r\n\r\n\tint best=0;\r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tint cnt=0;\r\n\t\t// search for the groups that are same as group i \r\n\t\tfor (int j=0; j<n; j++)\r\n\t\t\tif (groups[i]==groups[j]) cnt++;\r\n\t\tif (best<cnt) best=cnt;\t// update the best count\r\n\t}\r\n\r\n\tofstream fout(\"records.out\");\r\n\tfout << best << \"\\n\";\r\n\tfout.close();\r\n}\r\n\nAlthough it is not necessary for this problem, a faster solution may worth\r\nmentioning for similar problems in bronze division. In the first solution, we\r\nhave a list of strings that correspond to the groups with sorted cows. Let's\r\nsort the entire list this time. Then the sample input will become as follows:\n\r\nBESSIE ELSIE MATILDA\r\nBESSIE ELSIE MATILDA\r\nBESSIE ELSIE MATILDA\r\nBESSIE FRAN INGRID\r\nFRAN INGRID MATILDA\r\n\nNow, it is much easier and faster to find same groups since they will be\r\nconsecutive. This solution requires sorting the entire list which is O(N log N)\r\nand only one pass over the list is necessary which is O(N). Here's the code for\r\nthe faster solution:\n\r\n// O(N log N)\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint n;\r\nstring groups[1001];\r\n\r\nint main()\r\n{\r\n\tifstream fin(\"records.in\");\r\n\tfin >> n;\r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tstring str[3];\r\n\t\tfin >> str[0] >> str[1] >> str[2];\r\n\t\tsort(str,str+3);\t\t\t\t// sort each group\r\n\t\tgroups[i]=str[0]+\" \"+str[1]+\" \"+str[2];\t\t// and convert it to a string\r\n\t}\r\n\tfin.close();\r\n\r\n\tsort(groups,groups+n);\t\t\t\t// sort the entire list\r\n\r\n\tint best=0;\r\n\tfor (int i=0,j=1; i<n; i++,j++)\r\n\t\t// continue counting until the next string is different\r\n\t\tif (groups[i]!=groups[i+1])\r\n\t\t{\r\n\t\t\tif (best<j) best=j;\t\t// update the best count\r\n\t\t\tj=0;\r\n\t\t}\r\n\r\n\tofstream fout(\"records.out\");\r\n\tfout << best << \"\\n\";\r\n\tfout.close();\r\n}\r\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5\nBESSIE ELSIE MATILDA\nFRAN BESSIE INGRID\nBESSIE ELSIE MATILDA\nMATILDA INGRID FRAN\nELSIE BESSIE MATILDA",
        "output": "3",
        "input_explanation": "",
        "output_explanation": "The group {BESSIE, ELSIE, MATILDA} enters the barn on three separate occasions.",
        "explanation": "The group {BESSIE, ELSIE, MATILDA} enters the barn on three separate occasions."
      }
    ],
    "description_no_samples": "Problem 1: Record Keeping [Brian Dean, 2013]\n\nFarmer John has been keeping detailed records of his cows as they enter the\nbarn for milking.  Each hour, a group of 3 cows enters the barn, and Farmer\nJohn writes down their names.  For example over a 5-hour period, he might\nwrite down the following list, where each row corresponds to a group\nentering the barn:\n\nBESSIE ELSIE MATILDA\nFRAN BESSIE INGRID\nBESSIE ELSIE MATILDA\nMATILDA INGRID FRAN\nELSIE BESSIE MATILDA\n\nFarmer John notes that the same group of cows may appear several times on\nhis list; in the example above, the group of BESSIE, ELSIE, and MATILDA\nappears three times (even though Farmer John didn't necessarily write their\nnames in the same order every time they entered the barn).  \n\nPlease help Farmer John count the number of occurrences of the group\nentering the barn the most.\n\nPROBLEM NAME: records\n\nINPUT FORMAT:\n\n* Line 1: The number of hours, N, for which Farmer John keeps records\n        (1 <= N <= 1000).\n\n* Lines 2..1+N: Each line contains a list of three space-separated cow\n        names.  Each name is between 1 and 10 characters and uses only\n        the letters A-Z.\n\nOUTPUT FORMAT:\n\n* Line 1: The number of occurrences of the group entering the barn the\n        most often.",
    "description_raw": "Problem 1: Record Keeping [Brian Dean, 2013]\n\nFarmer John has been keeping detailed records of his cows as they enter the\nbarn for milking.  Each hour, a group of 3 cows enters the barn, and Farmer\nJohn writes down their names.  For example over a 5-hour period, he might\nwrite down the following list, where each row corresponds to a group\nentering the barn:\n\nBESSIE ELSIE MATILDA\nFRAN BESSIE INGRID\nBESSIE ELSIE MATILDA\nMATILDA INGRID FRAN\nELSIE BESSIE MATILDA\n\nFarmer John notes that the same group of cows may appear several times on\nhis list; in the example above, the group of BESSIE, ELSIE, and MATILDA\nappears three times (even though Farmer John didn't necessarily write their\nnames in the same order every time they entered the barn).  \n\nPlease help Farmer John count the number of occurrences of the group\nentering the barn the most.\n\nPROBLEM NAME: records",
    "input_format": "* Line 1: The number of hours, N, for which Farmer John keeps records\n        (1 <= N <= 1000).\n\n* Lines 2..1+N: Each line contains a list of three space-separated cow\n        names.  Each name is between 1 and 10 characters and uses only\n        the letters A-Z.",
    "output_format": "* Line 1: The number of occurrences of the group entering the barn the\n        most often.",
    "num_samples": 1
  },
  "341_bronze_goldilocks_and_the_n_cows": {
    "name": "Goldilocks and the N Cows",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=341",
    "test_data_link": "http://www.usaco.org/current/data/milktemp.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_milktemp.html",
    "contest_link": "http://www.usaco.org/index.php?page=nov13results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov13problems",
    "problem_level": "bronze",
    "cp_id": "341",
    "problem_id": "341_bronze_goldilocks_and_the_n_cows",
    "description": "Problem 2: Goldilocks and the N Cows [Brian Dean, 2013]\n\nYou may have heard the classical story about Goldilocks and the 3 bears. \nLittle known, however, is that Goldilocks ultimately took up farming as a\nprofession.  On her farm, she has a barn containing N cows (1 <= N <=\n20,000). Unfortunately, her cows are rather sensitive to temperature. \n\nEach cow i specifies a range of temperatures A(i)..B(i) that are \"just\nright\" (0 <= A(i) <= B(i) <= 1,000,000,000).  If Goldilocks sets the\nthermostat in the barn to a temperature T < A(i), the cow will be too cold,\nand will produce X units of milk. If she sets the thermostat to a\ntemperature T within this range (A(i) <= T <= B(i)), then the cow will feel\ncomfortable and produce Y units of milk.  If she sets the thermostat to a\ntemperature T > B(i), the cow will feel too hot, and will produce Z units\nof milk.  As one would expect, the value of Y is always larger than both X\nand Z.\n\nGiven X, Y, and Z, as well as the preferred range of temperatures for each\ncow, please compute the maximum amount of milk Goldilocks can obtain if she\nsets the barn thermostat optimally.  The values of X, Y, and Z are integers\nin the range 0..1000, and the thermostat can be set to any integer value. \n\nPartial credit opportunities: Out of the 10 test cases for this problem,\ncases 1..4 will have B(i) <= 100 for every cow, and in cases 1..6, N is at\nmost 1000.\n\nPROBLEM NAME: milktemp\n\nINPUT FORMAT:\n\n* Line 1: Four space-separated integers: N X Y Z.\n\n* Lines 2..1+N: Line 1+i contains two space-separated integers: A(i)\n        and B(i).\n\nSAMPLE INPUT:\n\n4 7 9 6\n5 8\n3 4\n13 20\n7 10\n\nINPUT DETAILS:\n\nThere are 4 cows in the barn, with temperature ranges 5..8, 3..4, 13..20,\nand 7..10.  A cold cow produces 7 units of milk, a comfortable cow produces\n9 units of milk, and a hot cow produces 6 units of milk.\n\nOUTPUT FORMAT:\n\n* Line 1: The maximum amount of milk Goldilocks can obtain by an\n        optimal temperature setting in her barn.\n\nSAMPLE OUTPUT:\n\n31\n\nOUTPUT DETAILS:\n\nIf Goldilocks sets the thermostat to either 7 or 8, then she will make cows\n#1 and #4 happy, with cow #2 being too hot and cow #3 being too cold.  This\nyields 31 units of total milk.\n",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Goldilocks and the N Cows, by Brian Dean\n\n\n The process of solving this problem is described in the video above; the final\ncode is shown below. \n One small subtlety not discussed in the video above: if there is a tie\nbetween two elements -- one from the A array and the other from the B\narray -- it is important to process the one from the A array first (as\nwe do in our code, since we check if A[i] <= B[j]).  This ensures\nthat we get the highest possible milk output at each temperature we\nconsider, by first processing all the cows that become comfortable\n(entries in the A array), after which we process cows that become too\nhot (entries in the B array).  \n The total running time of this solution is\nO(N log N).  The initial sorts run in O(N log N) time, then the ensuing\nscan through A and B takes only O(N) time. \n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#define MAX_N 20000\nusing namespace std;\n\nint N, X, Y, Z;\nint A[MAX_N+1], B[MAX_N+1];\n\nint main(void)\n{\n  ifstream fin(\"milktemp.in\");\n  fin >> N >> X >> Y >> Z;\n  for (int i=0; i<N; i++) \n    fin >> A[i] >> B[i];\n  fin.close();\n\n  sort(A, A+N);\n  sort(B, B+N);\n  A[N] = 1000000001;\n  B[N] = 1000000001;\n\n  // scan through A and B simultaneously\n  int i=0, j=0;\n  int current_milk = N*X;\n  int answer = N*X;\n  while (i<N || j<N) {\n    // look at A[i] and B[j].\n    if (A[i] <= B[j]) {\n      // next event comes from A array\n      current_milk += Y-X;\n      i++;\n    } else {\n      // next event comes from B array\n      current_milk += Z-Y;\n      j++;\n    }\n    if (current_milk > answer) \n      answer = current_milk;\n  }\n\n  ofstream fout(\"milktemp.out\");\n  fout << answer << \"\\n\";\n  fout.close();\n\n  return 0;\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4 7 9 6\n5 8\n3 4\n13 20\n7 10",
        "output": "31",
        "input_explanation": "There are 4 cows in the barn, with temperature ranges 5..8, 3..4, 13..20,\nand 7..10.  A cold cow produces 7 units of milk, a comfortable cow produces\n9 units of milk, and a hot cow produces 6 units of milk.",
        "output_explanation": "If Goldilocks sets the thermostat to either 7 or 8, then she will make cows\n#1 and #4 happy, with cow #2 being too hot and cow #3 being too cold.  This\nyields 31 units of total milk.",
        "explanation": "There are 4 cows in the barn, with temperature ranges 5..8, 3..4, 13..20,\nand 7..10.  A cold cow produces 7 units of milk, a comfortable cow produces\n9 units of milk, and a hot cow produces 6 units of milk.\nIf Goldilocks sets the thermostat to either 7 or 8, then she will make cows\n#1 and #4 happy, with cow #2 being too hot and cow #3 being too cold.  This\nyields 31 units of total milk."
      }
    ],
    "description_no_samples": "Problem 2: Goldilocks and the N Cows [Brian Dean, 2013]\n\nYou may have heard the classical story about Goldilocks and the 3 bears. \nLittle known, however, is that Goldilocks ultimately took up farming as a\nprofession.  On her farm, she has a barn containing N cows (1 <= N <=\n20,000). Unfortunately, her cows are rather sensitive to temperature. \n\nEach cow i specifies a range of temperatures A(i)..B(i) that are \"just\nright\" (0 <= A(i) <= B(i) <= 1,000,000,000).  If Goldilocks sets the\nthermostat in the barn to a temperature T < A(i), the cow will be too cold,\nand will produce X units of milk. If she sets the thermostat to a\ntemperature T within this range (A(i) <= T <= B(i)), then the cow will feel\ncomfortable and produce Y units of milk.  If she sets the thermostat to a\ntemperature T > B(i), the cow will feel too hot, and will produce Z units\nof milk.  As one would expect, the value of Y is always larger than both X\nand Z.\n\nGiven X, Y, and Z, as well as the preferred range of temperatures for each\ncow, please compute the maximum amount of milk Goldilocks can obtain if she\nsets the barn thermostat optimally.  The values of X, Y, and Z are integers\nin the range 0..1000, and the thermostat can be set to any integer value. \n\nPartial credit opportunities: Out of the 10 test cases for this problem,\ncases 1..4 will have B(i) <= 100 for every cow, and in cases 1..6, N is at\nmost 1000.\n\nPROBLEM NAME: milktemp\n\nINPUT FORMAT:\n\n* Line 1: Four space-separated integers: N X Y Z.\n\n* Lines 2..1+N: Line 1+i contains two space-separated integers: A(i)\n        and B(i).\n\nOUTPUT FORMAT:\n\n* Line 1: The maximum amount of milk Goldilocks can obtain by an\n        optimal temperature setting in her barn.",
    "description_raw": "Problem 2: Goldilocks and the N Cows [Brian Dean, 2013]\n\nYou may have heard the classical story about Goldilocks and the 3 bears. \nLittle known, however, is that Goldilocks ultimately took up farming as a\nprofession.  On her farm, she has a barn containing N cows (1 <= N <=\n20,000). Unfortunately, her cows are rather sensitive to temperature. \n\nEach cow i specifies a range of temperatures A(i)..B(i) that are \"just\nright\" (0 <= A(i) <= B(i) <= 1,000,000,000).  If Goldilocks sets the\nthermostat in the barn to a temperature T < A(i), the cow will be too cold,\nand will produce X units of milk. If she sets the thermostat to a\ntemperature T within this range (A(i) <= T <= B(i)), then the cow will feel\ncomfortable and produce Y units of milk.  If she sets the thermostat to a\ntemperature T > B(i), the cow will feel too hot, and will produce Z units\nof milk.  As one would expect, the value of Y is always larger than both X\nand Z.\n\nGiven X, Y, and Z, as well as the preferred range of temperatures for each\ncow, please compute the maximum amount of milk Goldilocks can obtain if she\nsets the barn thermostat optimally.  The values of X, Y, and Z are integers\nin the range 0..1000, and the thermostat can be set to any integer value. \n\nPartial credit opportunities: Out of the 10 test cases for this problem,\ncases 1..4 will have B(i) <= 100 for every cow, and in cases 1..6, N is at\nmost 1000.\n\nPROBLEM NAME: milktemp",
    "input_format": "* Line 1: Four space-separated integers: N X Y Z.\n\n* Lines 2..1+N: Line 1+i contains two space-separated integers: A(i)\n        and B(i).",
    "output_format": "* Line 1: The maximum amount of milk Goldilocks can obtain by an\n        optimal temperature setting in her barn.",
    "num_samples": 1
  },
  "1275_bronze_leaders": {
    "name": "Leaders",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1275",
    "test_data_link": "http://www.usaco.org/current/data/prob1_bronze_jan23.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_bronze_jan23.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan23results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "1275",
    "problem_id": "1275_bronze_leaders",
    "description": "\nFarmer John has $N$ cows ($2 \\leq N \\leq 10^5$). Each cow has a breed that is\neither Guernsey or Holstein.  As is often the case, the cows are standing in a\nline, numbered $1 \\ldots N$ in this order.  \n\nOver the course of the day, each cow writes down a list of cows.  Specifically,\ncow $i$'s list contains the range of cows starting with herself (cow $i$) up to\nand including cow $E_i$ ($i \\leq E_i \\leq N$).\n\nFJ has recently discovered that each breed of cow has exactly one distinct\nleader. FJ does not know who the leaders are, but he knows that each leader must\nhave a list that includes all the cows of their breed, or the other breed's \nleader (or both).\n\nHelp FJ count the number of pairs of cows that could be leaders. It is\nguaranteed that there is at least one possible pair.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe second line contains a string of length $N$, with the $i$th character\ndenoting the breed of the $i$th cow (G meaning Guernsey and H meaning Holstein).\nIt is guaranteed that there is at least one Guernsey and one Holstein.\n\nThe third line contains $E_1 \\dots E_N$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the number of possible pairs of leaders.\n\nSAMPLE INPUT:\n4\nGHHG\n2 4 3 4\nSAMPLE OUTPUT: \n1\n\nThe only valid leader pair is $(1, 2)$. Cow $1$'s list contains the other\nbreed's leader (cow $2$). Cow $2$'s list contains all cows of her breed\n(Holstein). \n\nNo other pairs are valid. For example, $(2,4)$ is invalid since cow $4$'s list\ndoes not contain the other breed's leader, and it also does not contain all cows\nof her breed.\n\nSAMPLE INPUT:\n3\nGGH\n2 3 3\nSAMPLE OUTPUT: \n2\n\nThere are two valid leader pairs, $(1, 3)$ and $(2, 3)$.\n\nSCORING\nInputs 3-5: $N \\leq 100$Inputs 6-10: $N \\leq 3000$Inputs 11-17: No additional constraints.\n\n\nProblem credits: Mythreya Dharani\n",
    "num_tests": 17,
    "solution": "\n(Analysis by David Hu)\nNote that each cow visits only cows at or after it. This implies that it is \nimpossible for any pair of two cows to visit each other. Thus, either the \nleader of the guernseys must have visited all the guernseys or the leader of\nholsteins must have visited all the holsteins (or both). This means that the\nleader of the guernseys must be the earliest guernsey or the leader of the\nholsteins must be the earliest holstein (or both).\nOnce we fix the leader of the guernseys to be the earliest guernsey and verify\nthat the earliest guernsey has indeed visited all the other guernseys, we can\nbrute force  over all holsteins and check whether they can also be a leader\ntogether with the earliest guernsey. Likewise, we also consider a similar case\nwhere the leader of the holsteins is the earliest holstein.\nMake sure to pay special attention to the case where the earliest guernsey and\nearliest holstein are both leaders.\nMy C++ code:\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 3e5 + 13;\n\nint N;\nstring s;\nint arr[MAXN];\nint eG, eH; //earliest guernsey, earliest holstein\nint lG, lH; //latest guernsey, latest holstein\nint ans;\n\nint main()\n{\n    cin >> N >> s;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        arr[i]--;\n    }\n    for (int i = 0; i < N; i++)\n    {\n        if (s[i] == 'G')\n        {\n            eG = i;\n            break;\n        }\n    }\n    for (int i = N - 1; i >= 0; i--)\n    {\n        if (s[i] == 'G')\n        {\n            lG = i;\n            break;\n        }\n    }\n    for (int i = 0; i < N; i++)\n    {\n        if (s[i] == 'H')\n        {\n            eH = i;\n            break;\n        }\n    }\n    for (int i = N - 1; i >= 0; i--)\n    {\n        if (s[i] == 'H')\n        {\n            lH = i;\n            break;\n        }\n    }\n    if (arr[eG] >= lG)\n    {\n        //earliest guernsey visited everybody and is the leader.\n        //holstein leader has to visit earliest guernsey or visit all holsteins.\n        //handle case where holstein leader has visited earliest guernsey.\n        for (int i = 0; i < eG; i++)\n        {\n            if (i == eH) //ignore the case where the holstein leader is earliest holstein.\n            {\n                continue;\n            }\n            if (s[i] == 'H' && arr[i] >= eG)\n            {\n                ans++;\n            }\n        }\n    }\n    if (arr[eH] >= lH)\n    {\n        //earliest holstein visited everybody.\n        for (int i = 0; i < eH; i++)\n        {\n            if (i == eG)\n            {\n                continue;\n            }\n            if (s[i] == 'G' && arr[i] >= eH)\n            {\n                ans++;\n            }\n        }\n    }\n    //check whether earliest guernsey and earliest holstein can together be leaders.\n    if ((arr[eG] >= lG || (eG <= eH && arr[eG] >= eH)) && (arr[eH] >= lH || (eH <= eG && arr[eH] >= eG)))\n    {\n        ans++;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n\nMy Python code:\n\nN = int(input())\ns = input()\narr = list(map(int, input().split()))\narr = [x - 1 for x in arr]\n\neG, eH, lG, lH = -1, -1, -1, -1\n\nfor i in range(N - 1, -1, -1):\n    if (s[i] == 'G'):\n        eG = i\n    if (s[i] == 'H'):\n        eH = i\n\nfor i in range(N):\n    if (s[i] == 'G'):\n        lG = i\n    if (s[i] == 'H'):\n        lH = i\n\nans = 0\n\nif (arr[eG] >= lG):\n    for i in range(eG):\n        if (i == eH):\n            continue\n        if (s[i] == 'H' and arr[i] >= eG):\n            ans += 1\n\nif (arr[eH] >= lH):\n    for i in range(eH):\n        if (i == eG):\n            continue\n        if (s[i] == 'G' and arr[i] >= eH):\n            ans += 1\n\nif ((arr[eG] >= lG or (eG <= eH and arr[eG] >= eH)) and (arr[eH] >= lH or (eH <= eG and arr[eH] >= eG))):\n    ans += 1\n\nprint(ans)\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4\nGHHG\n2 4 3 4",
        "output": "1",
        "explanation": "The only valid leader pair is $(1, 2)$. Cow $1$'s list contains the other\nbreed's leader (cow $2$). Cow $2$'s list contains all cows of her breed\n(Holstein). \n\nNo other pairs are valid. For example, $(2,4)$ is invalid since cow $4$'s list\ndoes not contain the other breed's leader, and it also does not contain all cows\nof her breed."
      },
      {
        "input": "3\nGGH\n2 3 3",
        "output": "2",
        "explanation": "There are two valid leader pairs, $(1, 3)$ and $(2, 3)$."
      }
    ],
    "description_no_samples": "\nFarmer John has $N$ cows ($2 \\leq N \\leq 10^5$). Each cow has a breed that is\neither Guernsey or Holstein.  As is often the case, the cows are standing in a\nline, numbered $1 \\ldots N$ in this order.  \n\nOver the course of the day, each cow writes down a list of cows.  Specifically,\ncow $i$'s list contains the range of cows starting with herself (cow $i$) up to\nand including cow $E_i$ ($i \\leq E_i \\leq N$).\n\nFJ has recently discovered that each breed of cow has exactly one distinct\nleader. FJ does not know who the leaders are, but he knows that each leader must\nhave a list that includes all the cows of their breed, or the other breed's \nleader (or both).\n\nHelp FJ count the number of pairs of cows that could be leaders. It is\nguaranteed that there is at least one possible pair.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe second line contains a string of length $N$, with the $i$th character\ndenoting the breed of the $i$th cow (G meaning Guernsey and H meaning Holstein).\nIt is guaranteed that there is at least one Guernsey and one Holstein.\n\nThe third line contains $E_1 \\dots E_N$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the number of possible pairs of leaders.\n\n",
    "num_samples": 2
  },
  "394_bronze_mirror_field": {
    "name": "Mirror Field",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=394",
    "test_data_link": "http://www.usaco.org/current/data/mirror.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_mirror.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb14results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=feb14problems",
    "problem_level": "bronze",
    "cp_id": "394",
    "problem_id": "394_bronze_mirror_field",
    "description": "Problem 1: Mirror Field [Mark Gordon]\n\nFarmer John has left some old mirrors sitting outside his house, and his\ncows, feeling mischievous as always, have stolen them!  \n\nThe cows have set up the mirrors in a rectangular field measuring N by M\nsquares (1 <= N, M <= 1,000).  In each square, they have placed a double\nsided mirror between two of its opposite corners.  These two possible\nconfigurations are represented by the '/' character (a mirror connecting\nthe lower-left corner to the upper-right corner) and the '\\' character (a\nmirror connecting the upper-left corner to the lower-right corner).\n\nOne evening, Bessie the cow brings a laser pointer out to the mirror field.\nStanding outside the field, she shines the beam of light either\nhorizontally or vertically along either a row or column of the field,\ncausing it to bounce of some number of mirrors.  Since the mirrors are all\ndiagonally oriented, a horizontal beam of light that reflects off a mirror\nwill end up traveling vertically, and vice versa.  Bessie wonders what is\nthe maximum number of mirrors on which her beam of light can be reflected\nat the same time.  Given the layout of the mirror field, please help Bessie\ncompute this number.\n\nPROBLEM NAME: mirror\n\nINPUT FORMAT:\n\n* Line 1: The integers N and M, separated by a space.\n\n* Lines 2..1+N: Each line will contain M '/' or '\\' characters,\n        describing a row of the mirror field.\n\nSAMPLE INPUT:\n\n3 3\n/\\\\\n\\\\\\\n/\\/\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer indicating the maximum number of times a\n        horizontal or vertical beam originating outside the mirror\n        field could be reflected.  Please output -1 if it could be\n        reflected indefinitely.\n\nSAMPLE OUTPUT:\n\n3\n\nOUTPUT DETAILS:\n\nBessie can shine the beam downwards above the middle column of her\nfield to have it reflected 3 times.\n",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Mirror by Brian Dean\n\nThe solution to this problem involves simply simulating the beam of\nlight from every possible starting point, counting the number of\nbounces until it leaves the grid.  There are two possible concerns\nabout this approach, however: is it possible for the beam to continue\nbouncing forever?  And, will this be fast enough to run within the\nrequired time limit?  \nFortunately, a simple observation helps resovle both of these\nquestions.  Each mirror side has two \"ports\" (say, A and B).  If light\ncomes in on A it leaves on B, and if light comes in on B it leaves on\nA.  With a bit of thought, we can therefore see that if light enters\nthe grid at a certain location, there is a unique path it must take\nuntil it finally exits -- and if we shine light back in the exit, it\nwill take this same path in reverse.  Each mirror side is therefore\nencountered along exactly two paths, so at worst our method examines\nevery square in the grid only a constant number of times, making the\napproach run very quickly.  We also cannot encounter any cycles, since\notherwise the first mirror side we encounter along a cycle would need\nto have 3 \"ports\" (two along the cycle, and one along the direction we\ncame from to enter the cycle).  If you are familiar with the concept\nof \"graphs\" in computer science, this gives a very convenient way to\nthink about the field of mirrors -- as a graph where every node has\none or two incident edges. \nHere is one simple solution, using lookup tables to deal with \nthe mechanics of deciding how to change direction at each bounce: \n\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n// direction: 0  1   2   3 \nint dr[] =   {1, 0, -1,  0};\nint dc[] =   {0, 1,  0, -1};\n\n// new direction after hitting / mirror\nint bounce1[] = {3, 2, 1, 0}; \n\n// new direction after hitting \\ mirror \nint bounce2[] = {1, 0, 3, 2}; \n\nint N, M;\nstring A[1010];\n\nint trace(int r, int c, int dir) {\n  int result = 0;\n  while(0 <= r && r < N && 0 <= c && c < M) {\n    if(A[r][c] == '/') \n      dir = bounce1[dir];\n    else \n      dir = bounce2[dir];\n    r += dr[dir];\n    c += dc[dir];\n    result++;\n  }\n  return result;\n}\n\nint main() {\n  freopen(\"mirror.in\", \"r\", stdin);\n  freopen(\"mirror.out\", \"w\", stdout);\n\n  cin >> N >> M;\n\n  for(int i = 0; i < N; i++) \n    cin >> A[i];\n\n  int best = 0;\n  for(int i = 0; i < N; i++) {\n    best = max(best, trace(i, 0, 1));\n    best = max(best, trace(i, M - 1, 3));\n  }\n  for(int i = 0; i < M; i++) {\n    best = max(best, trace(0, i, 0));\n    best = max(best, trace(N - 1, i, 2));\n  }\n  cout << best << endl;\n  \n  return 0;\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 3\n/\\\\\n\\\\\\\n/\\/",
        "output": "3",
        "input_explanation": "",
        "output_explanation": "Bessie can shine the beam downwards above the middle column of her\nfield to have it reflected 3 times.",
        "explanation": "Bessie can shine the beam downwards above the middle column of her\nfield to have it reflected 3 times."
      }
    ],
    "description_no_samples": "Problem 1: Mirror Field [Mark Gordon]\n\nFarmer John has left some old mirrors sitting outside his house, and his\ncows, feeling mischievous as always, have stolen them!  \n\nThe cows have set up the mirrors in a rectangular field measuring N by M\nsquares (1 <= N, M <= 1,000).  In each square, they have placed a double\nsided mirror between two of its opposite corners.  These two possible\nconfigurations are represented by the '/' character (a mirror connecting\nthe lower-left corner to the upper-right corner) and the '\\' character (a\nmirror connecting the upper-left corner to the lower-right corner).\n\nOne evening, Bessie the cow brings a laser pointer out to the mirror field.\nStanding outside the field, she shines the beam of light either\nhorizontally or vertically along either a row or column of the field,\ncausing it to bounce of some number of mirrors.  Since the mirrors are all\ndiagonally oriented, a horizontal beam of light that reflects off a mirror\nwill end up traveling vertically, and vice versa.  Bessie wonders what is\nthe maximum number of mirrors on which her beam of light can be reflected\nat the same time.  Given the layout of the mirror field, please help Bessie\ncompute this number.\n\nPROBLEM NAME: mirror\n\nINPUT FORMAT:\n\n* Line 1: The integers N and M, separated by a space.\n\n* Lines 2..1+N: Each line will contain M '/' or '\\' characters,\n        describing a row of the mirror field.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer indicating the maximum number of times a\n        horizontal or vertical beam originating outside the mirror\n        field could be reflected.  Please output -1 if it could be\n        reflected indefinitely.",
    "description_raw": "Problem 1: Mirror Field [Mark Gordon]\n\nFarmer John has left some old mirrors sitting outside his house, and his\ncows, feeling mischievous as always, have stolen them!  \n\nThe cows have set up the mirrors in a rectangular field measuring N by M\nsquares (1 <= N, M <= 1,000).  In each square, they have placed a double\nsided mirror between two of its opposite corners.  These two possible\nconfigurations are represented by the '/' character (a mirror connecting\nthe lower-left corner to the upper-right corner) and the '\\' character (a\nmirror connecting the upper-left corner to the lower-right corner).\n\nOne evening, Bessie the cow brings a laser pointer out to the mirror field.\nStanding outside the field, she shines the beam of light either\nhorizontally or vertically along either a row or column of the field,\ncausing it to bounce of some number of mirrors.  Since the mirrors are all\ndiagonally oriented, a horizontal beam of light that reflects off a mirror\nwill end up traveling vertically, and vice versa.  Bessie wonders what is\nthe maximum number of mirrors on which her beam of light can be reflected\nat the same time.  Given the layout of the mirror field, please help Bessie\ncompute this number.\n\nPROBLEM NAME: mirror",
    "input_format": "* Line 1: The integers N and M, separated by a space.\n\n* Lines 2..1+N: Each line will contain M '/' or '\\' characters,\n        describing a row of the mirror field.",
    "output_format": "* Line 1: A single integer indicating the maximum number of times a\n        horizontal or vertical beam originating outside the mirror\n        field could be reflected.  Please output -1 if it could be\n        reflected indefinitely.",
    "num_samples": 1
  },
  "278_bronze_bovine_ballet": {
    "name": "Bovine Ballet",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=278",
    "test_data_link": "http://www.usaco.org/current/data/ballet.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_ballet.html",
    "contest_link": "http://www.usaco.org/index.php?page=open13results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=open13problems",
    "problem_level": "bronze",
    "cp_id": "278",
    "problem_id": "278_bronze_bovine_ballet",
    "description": "Problem 1: Bovine Ballet [Brian Dean, 2013]\n\nIn an attempt to challenge the stereotypical perception of cows as awkward\ncreatures, Farmer John's prize cow Bessie has signed up for an introductory\nballet class.  Her final performance is next week, and FJ wants to help her\nby building a rectangular stage large enough so that she can perform her\nentire dance without falling off the edges.\n\nBessie's dance will take place on a rectangular stage consisting of a grid\nof 1 x 1 square cells.  Bessie's four feet are described concisely as follows:\n\nFR: Front right foot\nFL: Front left foot\nRR: Rear right foot\nRL: Rear left foot\n\nHer four feet start out in 4 adjacent cells forming a square as follows,\nwith Bessie facing north.\n\nFL FR\nRL RR\n\nBessie's dance follows a series of N instructions (1 <= N <= 1000), where\neach instruction tells her to either move one foot by one cell or to pivot\n90 degrees clockwise.  \n\nInstructions to move a foot consist of 3 characters, the first two\nidentifying the foot to move, and the final character specifying the\ndirection of movement (F = forward, B = back, R = right, L = left).  For\nexample, \"FRF\" means Bessie should move her front right foot forward one\ncell, and \"RLR\" means she should move her rear left foot right one cell. \nOf course, the direction of movement is relative to the direction Bessie is\nfacing.\n\nInstruction to pivot are also 3 characters, the first two specifying the\nsingle foot that Bessie keeps planted, around which she rotates 90 degrees\nclockwise.  The last character is \"P\" (for pivot).  For example, the\ninstruction \"FRP\" means Bessie should pivot 90 degrees clockwise about her\nstationary front right foot.  This means that if her feet are currently\nsituated as follows (with Bessie facing north)\n\n.. .. .. \n.. .. FR \n.. FL .. \n.. RL RR \n\nthen the after the instruction \"FRP\" her feet will be located as follows,\nwith Bessie now facing east:\n\nRL FL .. \nRR .. FR \n.. .. ..  \n.. .. .. \n\nGiven the N instructions in Bessie's dance, please compute the minimum area\nof a rectangular stage necessary contain her feet during the entire dance.\n\nIf Bessie clumsily ever moves one foot onto the same cell as another foot,\nshe will trip and fail to complete the dance; in this case, please output\n-1.  Note that this is the only case where Bessie will trip; she has become\nquite flexible after all her practice, and can easily move her feet into\nrather strange configurations (for example, with her back feet farther\nforward than her front feet).\n\nPROBLEM NAME: ballet\n\nINPUT FORMAT:\n\n* Line 1: The integer N.\n\n* Lines 2..1+N: Each line contains one of the 3-character instructions\n        in Bessie's dance.\n\nSAMPLE INPUT:\n\n3\nFRF\nFRP\nRLB\n\nINPUT DETAILS:\n\nBessie's dance consists of the instructions \"front right foot forward\",\n\"front right foot pivot\", and \"rear left foot back\".\n\nOUTPUT FORMAT:\n\n* Line 1: The minimum area of a rectangular stage necessary to contain\n        Bessie's feet during the entire dance, or -1 if Bessie trips.\n\nSAMPLE OUTPUT:\n\n16\n\nOUTPUT DETAILS:\n\nBessie needs a 4 x 4 stage to complete her dance.  Her feet move as follows:\n\n.. .. .. .. \n.. .. .. .. (facing north)\n.. .. FL FR \n.. .. RL RR \n\nAfter FRF:\n\n.. .. .. .. \n.. .. .. FR (facing north)\n.. .. FL .. \n.. .. RL RR \n\nAfter FRP:\n\n.. RL FL .. \n.. RR .. FR (facing east)\n.. .. .. .. \n.. .. .. .. \n\nAfter RLB:\n\nRL .. FL ..\n.. RR .. FR (facing east)\n.. .. .. ..\n.. .. .. ..\n",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Bovine Ballet by Fatih Gelgi\n\nIn this problem, a trivial solution is to keep the feet positions and apply\r\ninstructions one by one. After each instruction, the corner coordinates of the\r\nrectangular stage are updated. Note that we cannot mark the feet position on a\r\nmatrix since the matrix may be excessively large and doesn't fit in the memory\r\n(ex. an input that has 500 FRFs and FRP,RRP alternates 250 times).\nat the beginning, we need to assign initial positions to the feet. Let's\r\nsay:\n\r\n    y x\r\nFL (0,0)\r\nFR (0,1)\r\nRL (1,0)\r\nRR (1,1)\r\n\nWithout rotation, moves are straightforward:\n\nforward: y=y-1\r\n\tright: x=x+1\r\n\tback: y=y+1\r\n\tleft: x=x-1\r\n\nWhen we include rotation, the moves will change with respect to the current\r\ndirection. We have 16 different cases in total -- 4 moves per direction. One\r\nidea is to write all cases one by one. However, we will work on a more elegant\r\nidea. Let's numerate the moves first - {0:forward, 1:right, 2:back, 3:left}.\r\nNotice that they in clockwise order. Let's numerate the directions again in\r\nclockwise order as the second step - {0:north, 1:east, 2:south, 3:west}. Now,\r\nconsider the following instructions:\n\r\n0) Initially:\r\n.. .. .. .. \r\n.. .. .. .. (facing north)\r\n.. .. FL FR \r\n.. .. RL RR \r\n\r\n1) FRF:\r\n.. .. .. .. \r\n.. .. .. FR (facing north)\r\n.. .. FL .. \r\n.. .. RL RR \r\n\r\n2) FRP:\r\n.. RL FL .. \r\n.. RR .. FR (facing east)\r\n.. .. .. .. \r\n.. .. .. .. \r\n\r\n3) RRF:\r\n.. RL FL .. \r\n.. .. RR FR (facing east)\r\n.. .. .. .. \r\n.. .. .. .. \r\n\r\n4) RLP:\r\n.. RL .. .. \r\nRR FL .. .. (facing south)\r\nFR .. .. .. \r\n.. .. .. .. \r\n\r\n5) FRF:\r\n.. RL .. .. \r\nRR FL .. .. (facing south)\r\n.. .. .. .. \r\nFR .. .. .. \r\n\nYou can observe that the moves shift by rotations. In other words, forward\r\nbecomes right, right becomes back, back becomes left, left becomes forward in\r\none rotation. For instance, Bessie moves forward (MOVE=0) in steps 1,3 and 5.\r\nIn the first one, the direction is north (DIR=0). In steps 3 and 5, the\r\ndirections are east (DIR=1) and south (DIR=2). Forward move (MOVE=0) means to\r\nmove right (MOVE=1) and back (MOVE=2) when facing east (DIR=1) and south\r\n(DIR=2) respectively. As a summary, we can calculate the absolute direction of\r\nthe current move by MOVE = (MOVE + DIR) % 4.\nNow, the issue is to do the rotation. We need to calculate the new positions\r\nfor the feet. Consider the following rotation:\n\r\n1) FRF:\r\n   -2 -1  0  1\r\n-2 .. .. .. .. \r\n-1 .. .. .. FR\r\n 0 .. .. FL .. \r\n 1 .. .. RL RR \r\n\r\n2) FRP:\r\n   -2 -1  0  1\r\n-2 .. RL FL .. \r\n-1 .. RR .. FR (facing east)\r\n 0 .. .. .. .. \r\n 1 .. .. .. .. \r\n\nNew coordinate of a foot (y1,x1) is (y0+x1-x0,x0+y0-y1) where (y0,x0) is the\r\nposition of the pivot foot. In the example above, the rotation is as follows:\n\r\n\tinitial position\tafter rotation\r\n\t------------\t\t------------\r\nFL\t(0,0)\t\t\t(-1+0-1,1-1-0)=(-2,0)\r\nFR\t(-1,1)\t\t\t(-1,1)\r\nRL\t(1,0)\t\t\t(-1+0-1,1-1-1)=(-2,-1)\r\nRR\t(1,1)\t\t\t(-1+1-1,1-1-1)=(-1,-1)\r\n\nThe solution requires O(N) time. The sample code is provided below:\n\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nconst int d[4][2]={{-1,0},{0,1},{1,0},{0,-1}}; \t// (dy,dx)\r\n{0:forward,1:right,2:back,3:left}\r\nstruct Point { int y,x; }\r\n\tfoot[4]={{0,0},{0,1},{1,0},{1,1}};\t// initial feet positions\r\nint dir;\t\t\t\t\t// {0:north,1:west,2:south,3:east}\r\nint miny,minx,maxy,maxx;\t\t\t// min - max coordinates of the area\r\n\r\nint move(string s)\r\n{\r\n\t// determine the foot\r\n\tint f=0;\r\n\tif (s[0]=='F' && s[1]=='R') f=1;\r\n\telse if (s[0]=='R')\r\n\t\tif (s[1]=='L') f=2;\r\n\t\telse f=3;\r\n\r\n\t// clockwise rotation\r\n\tif (s[2]=='P')\r\n\t{\r\n\t\tfor (int i=0; i<4; i++)\r\n\t\t{\r\n\t\t\tint ny=foot[f].y+foot[i].x-foot[f].x;\r\n\t\t\tint nx=foot[f].x+foot[f].y-foot[i].y;\r\n\t\t\tfoot[i].y=ny,foot[i].x=nx;\r\n\t\t}\r\n\t\tdir=(dir+1)%4;\t\t// rotate direction clockwise\r\n\t}\r\n\t// move\r\n\telse\r\n\t{\r\n\t\t// get the relative direction\r\n\t\tint m=0;\r\n\t\tif (s[2]=='R') m=1;\r\n\t\tif (s[2]=='B') m=2;\r\n\t\tif (s[2]=='L') m=3;\r\n\t\tm=(m+dir)%4;\t\t// calculate the absolute direction\r\n\r\n\t\tfoot[f].y+=d[m][0];\r\n\t\tfoot[f].x+=d[m][1];\r\n\r\n\t\t// check if Bessie trips\r\n\t\tfor (int i=0; i<4; i++)\r\n\t\t\tif (f!=i && foot[f].y==foot[i].y && foot[f].x==foot[i].x)\r\n\t\t\t\treturn 0;\r\n\t}\r\n\r\n\t// update minimum size rectangle\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tif (miny>foot[i].y) miny=foot[i].y;\r\n\t\tif (maxy<foot[i].y) maxy=foot[i].y;\r\n\t\tif (minx>foot[i].x) minx=foot[i].x;\r\n\t\tif (maxx<foot[i].x) maxx=foot[i].x;\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nint main()\r\n{\r\n\tifstream fin(\"ballet.in\");\r\n\tofstream fout(\"ballet.out\");\r\n\r\n\tint n,valid=1;\r\n\tfin >> n;\r\n\tstring inst;\r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tfin >> inst;\r\n\t\tif (!(valid=move(inst))) break;\r\n\t}\r\n\r\n\tif (valid)\r\n\t\tfout << (maxy-miny+1)*(maxx-minx+1) << endl;\r\n\telse\r\n\t\tfout << -1 << endl;\r\n\r\n\tfin.close();\r\n\tfout.close();\r\n}\r\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3\nFRF\nFRP\nRLB",
        "output": "16",
        "input_explanation": "Bessie's dance consists of the instructions \"front right foot forward\",\n\"front right foot pivot\", and \"rear left foot back\".",
        "output_explanation": "Bessie needs a 4 x 4 stage to complete her dance.  Her feet move as follows:\n\n.. .. .. .. \n.. .. .. .. (facing north)\n.. .. FL FR \n.. .. RL RR \n\nAfter FRF:\n\n.. .. .. .. \n.. .. .. FR (facing north)\n.. .. FL .. \n.. .. RL RR \n\nAfter FRP:\n\n.. RL FL .. \n.. RR .. FR (facing east)\n.. .. .. .. \n.. .. .. .. \n\nAfter RLB:\n\nRL .. FL ..\n.. RR .. FR (facing east)\n.. .. .. ..\n.. .. .. ..",
        "explanation": "Bessie's dance consists of the instructions \"front right foot forward\",\n\"front right foot pivot\", and \"rear left foot back\".\nBessie needs a 4 x 4 stage to complete her dance.  Her feet move as follows:\n\n.. .. .. .. \n.. .. .. .. (facing north)\n.. .. FL FR \n.. .. RL RR \n\nAfter FRF:\n\n.. .. .. .. \n.. .. .. FR (facing north)\n.. .. FL .. \n.. .. RL RR \n\nAfter FRP:\n\n.. RL FL .. \n.. RR .. FR (facing east)\n.. .. .. .. \n.. .. .. .. \n\nAfter RLB:\n\nRL .. FL ..\n.. RR .. FR (facing east)\n.. .. .. ..\n.. .. .. .."
      }
    ],
    "description_no_samples": "Problem 1: Bovine Ballet [Brian Dean, 2013]\n\nIn an attempt to challenge the stereotypical perception of cows as awkward\ncreatures, Farmer John's prize cow Bessie has signed up for an introductory\nballet class.  Her final performance is next week, and FJ wants to help her\nby building a rectangular stage large enough so that she can perform her\nentire dance without falling off the edges.\n\nBessie's dance will take place on a rectangular stage consisting of a grid\nof 1 x 1 square cells.  Bessie's four feet are described concisely as follows:\n\nFR: Front right foot\nFL: Front left foot\nRR: Rear right foot\nRL: Rear left foot\n\nHer four feet start out in 4 adjacent cells forming a square as follows,\nwith Bessie facing north.\n\nFL FR\nRL RR\n\nBessie's dance follows a series of N instructions (1 <= N <= 1000), where\neach instruction tells her to either move one foot by one cell or to pivot\n90 degrees clockwise.  \n\nInstructions to move a foot consist of 3 characters, the first two\nidentifying the foot to move, and the final character specifying the\ndirection of movement (F = forward, B = back, R = right, L = left).  For\nexample, \"FRF\" means Bessie should move her front right foot forward one\ncell, and \"RLR\" means she should move her rear left foot right one cell. \nOf course, the direction of movement is relative to the direction Bessie is\nfacing.\n\nInstruction to pivot are also 3 characters, the first two specifying the\nsingle foot that Bessie keeps planted, around which she rotates 90 degrees\nclockwise.  The last character is \"P\" (for pivot).  For example, the\ninstruction \"FRP\" means Bessie should pivot 90 degrees clockwise about her\nstationary front right foot.  This means that if her feet are currently\nsituated as follows (with Bessie facing north)\n\n.. .. .. \n.. .. FR \n.. FL .. \n.. RL RR \n\nthen the after the instruction \"FRP\" her feet will be located as follows,\nwith Bessie now facing east:\n\nRL FL .. \nRR .. FR \n.. .. ..  \n.. .. .. \n\nGiven the N instructions in Bessie's dance, please compute the minimum area\nof a rectangular stage necessary contain her feet during the entire dance.\n\nIf Bessie clumsily ever moves one foot onto the same cell as another foot,\nshe will trip and fail to complete the dance; in this case, please output\n-1.  Note that this is the only case where Bessie will trip; she has become\nquite flexible after all her practice, and can easily move her feet into\nrather strange configurations (for example, with her back feet farther\nforward than her front feet).\n\nPROBLEM NAME: ballet\n\nINPUT FORMAT:\n\n* Line 1: The integer N.\n\n* Lines 2..1+N: Each line contains one of the 3-character instructions\n        in Bessie's dance.\n\nOUTPUT FORMAT:\n\n* Line 1: The minimum area of a rectangular stage necessary to contain\n        Bessie's feet during the entire dance, or -1 if Bessie trips.",
    "description_raw": "Problem 1: Bovine Ballet [Brian Dean, 2013]\n\nIn an attempt to challenge the stereotypical perception of cows as awkward\ncreatures, Farmer John's prize cow Bessie has signed up for an introductory\nballet class.  Her final performance is next week, and FJ wants to help her\nby building a rectangular stage large enough so that she can perform her\nentire dance without falling off the edges.\n\nBessie's dance will take place on a rectangular stage consisting of a grid\nof 1 x 1 square cells.  Bessie's four feet are described concisely as follows:\n\nFR: Front right foot\nFL: Front left foot\nRR: Rear right foot\nRL: Rear left foot\n\nHer four feet start out in 4 adjacent cells forming a square as follows,\nwith Bessie facing north.\n\nFL FR\nRL RR\n\nBessie's dance follows a series of N instructions (1 <= N <= 1000), where\neach instruction tells her to either move one foot by one cell or to pivot\n90 degrees clockwise.  \n\nInstructions to move a foot consist of 3 characters, the first two\nidentifying the foot to move, and the final character specifying the\ndirection of movement (F = forward, B = back, R = right, L = left).  For\nexample, \"FRF\" means Bessie should move her front right foot forward one\ncell, and \"RLR\" means she should move her rear left foot right one cell. \nOf course, the direction of movement is relative to the direction Bessie is\nfacing.\n\nInstruction to pivot are also 3 characters, the first two specifying the\nsingle foot that Bessie keeps planted, around which she rotates 90 degrees\nclockwise.  The last character is \"P\" (for pivot).  For example, the\ninstruction \"FRP\" means Bessie should pivot 90 degrees clockwise about her\nstationary front right foot.  This means that if her feet are currently\nsituated as follows (with Bessie facing north)\n\n.. .. .. \n.. .. FR \n.. FL .. \n.. RL RR \n\nthen the after the instruction \"FRP\" her feet will be located as follows,\nwith Bessie now facing east:\n\nRL FL .. \nRR .. FR \n.. .. ..  \n.. .. .. \n\nGiven the N instructions in Bessie's dance, please compute the minimum area\nof a rectangular stage necessary contain her feet during the entire dance.\n\nIf Bessie clumsily ever moves one foot onto the same cell as another foot,\nshe will trip and fail to complete the dance; in this case, please output\n-1.  Note that this is the only case where Bessie will trip; she has become\nquite flexible after all her practice, and can easily move her feet into\nrather strange configurations (for example, with her back feet farther\nforward than her front feet).\n\nPROBLEM NAME: ballet",
    "input_format": "* Line 1: The integer N.\n\n* Lines 2..1+N: Each line contains one of the 3-character instructions\n        in Bessie's dance.",
    "output_format": "* Line 1: The minimum area of a rectangular stage necessary to contain\n        Bessie's feet during the entire dance, or -1 if Bessie trips.",
    "num_samples": 1
  },
  "1111_silver_year_of_the_cow": {
    "name": "Year of the Cow",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1111",
    "test_data_link": "http://www.usaco.org/current/data/prob2_silver_feb21.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_silver_feb21.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb21results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "silver",
    "cp_id": "1111",
    "problem_id": "1111_silver_year_of_the_cow",
    "description": "Farmer John's cows are excited to learn that Chinese New Year was recently \ncelebrated, ushering in the year of the Ox, always a bovine favorite.\n\nAs we know, the zodiac animals for Chinese calendar years follow a 12-year\ncycle: Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig,\nRat, and then Ox again.  Slightly lesser known is the fact that a mysterious\ntime portal opens up during every year of the Ox, allowing cows to travel\nthrough time to any other year of the Ox in the past or future.\n\nBessie the cow would like to take advantage of the time portal that has opened\nup this year to visit $N$ of her famous bovine ancestors who lived long ago in\nhistory, with $1 \\leq N \\leq 0x10000$ (it seems fitting, being the year of the\nOx, to write the bound on $N$ in hexadecimal; note that 0x10000 is the same as\n65536).  \n\nUnfortunately, time travel makes Bessie a bit queasy, and  she would prefer to\nmake at most $K$ jumps through time ($1 \\leq K \\leq N$). Please help Bessie\ndetermine the minimum number of years it will take her to visit all her\nancestors and return to the present year, with at most $K$ total jumps through\ntime along the way.  \n\nBessie does not need to use the time portal in a given Ox year if she does not\nwant to.  Time portals connect the first days of each Ox year with each-other,\nso for example if Bessie travels to a time portal and then waits 12 years for\nthe next time portal, she spends exactly 12 years in the process.  Bessie starts\nher adventure on the first day of the present Ox year, so she can travel back in\ntime right away.   None of Bessie's ancestors live in Ox years.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of input contains $N$ and $K$. The next $N$ lines contain $N$\ndistinct integers in the range $1 \\ldots 10^9$, indicating how many years ago each of\nBessie's $N$ ancestors lived.  \n\nOUTPUT FORMAT (print output to the terminal / stdout):\nPrint the minimum number of years it will take Bessie to visit all her ancestors\nand return to the present year.\n\nSAMPLE INPUT:\n5 3\n101\n85\n100\n46\n95\nSAMPLE OUTPUT: \n36\n\nOne way for Bessie to visit all her ancestors and return in 36 years is as\nfollows:\n\nEnter the portal in the present day and travel 48 years into the past.Wait 12 years, then enter the portal 36 years in the past and travel 108\nyears into the past.Wait 24 years, then enter the portal 84 years in the past and travel back to\nthe present year.\n\nProblem credits: Brian Dean and David Yang\n",
    "num_tests": 10,
    "solution": "\n(Analysis by Spencer Compton)\nWe start by thinking about the structure of Bessie's journey through time. Since\nthere are only time portals on years that are multiples of 12, and none of\nBessie's relatives are born in such a year, to visit some relative Bessie must\nalso visit the preceding year of the Ox and wait 12 years. For example, if\nBessie has a relative from 15 years ago, Bessie must visit the year of the Ox 24\nyears ago and must wait until at least the year of the Ox 12 years ago. In other\nwords, we can think of each year $x$ as belonging to a 12-year cycle\n$\\lfloor \\frac{x+11}{12} \\rfloor$, so $0$ belongs to cycle $0$, \n$[1, \\dots, 12]$ to cycle $1$, $[13, \\dots, 24]$ to cycle $2$, and so on.\nMeaning, if Bessie has a relative in cycle $x$ then Bessie must spend all 12\nyears in that cycle.\nWe must use a jump to go back to the earliest cycle, then with the remaining\n$K-1$ jumps Bessie can skip over contiguous ranges of unnecessary cycles. It is\nthen optimal to skip over the $K-1$ largest contiguous ranges of unused cycles.\nOne way we can accomplish this is by identifying all the cycles Bessie has\nrelatives in, sorting them, identifying the gaps between adjacent cycles in the\nsorted list, and sorting those gaps to find the $K-1$ largest. In total, this\ntakes  $O(n \\log (n) ) $ time.\nBrian Dean's code:\n\n#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \nset<int> blocks;\nvector<int> gaps;\n \nint main(void)\n{\n  int N, K, years_ago, answer, last = 0;\n  cin >> N >> K;\n  for (int i=0; i<N; i++) { cin >> years_ago; blocks.insert ((years_ago+11)/12); }\n  answer = *blocks.rbegin();\n  while (!blocks.empty()) {\n    gaps.push_back(*blocks.begin() - last - 1);\n    last = *blocks.begin();\n    blocks.erase(*blocks.begin());\n  }\n  sort (gaps.rbegin(), gaps.rend());\n  for (int i=0; i<K-1 && i<gaps.size(); i++) answer -= gaps[i];\n  cout << answer * 12 << \"\\n\";\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5 3\n101\n85\n100\n46\n95",
        "output": "36",
        "explanation": "One way for Bessie to visit all her ancestors and return in 36 years is as\nfollows:\n\nEnter the portal in the present day and travel 48 years into the past.Wait 12 years, then enter the portal 36 years in the past and travel 108\nyears into the past.Wait 24 years, then enter the portal 84 years in the past and travel back to\nthe present year."
      }
    ],
    "description_no_samples": "Farmer John's cows are excited to learn that Chinese New Year was recently \ncelebrated, ushering in the year of the Ox, always a bovine favorite.\n\nAs we know, the zodiac animals for Chinese calendar years follow a 12-year\ncycle: Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig,\nRat, and then Ox again.  Slightly lesser known is the fact that a mysterious\ntime portal opens up during every year of the Ox, allowing cows to travel\nthrough time to any other year of the Ox in the past or future.\n\nBessie the cow would like to take advantage of the time portal that has opened\nup this year to visit $N$ of her famous bovine ancestors who lived long ago in\nhistory, with $1 \\leq N \\leq 0x10000$ (it seems fitting, being the year of the\nOx, to write the bound on $N$ in hexadecimal; note that 0x10000 is the same as\n65536).  \n\nUnfortunately, time travel makes Bessie a bit queasy, and  she would prefer to\nmake at most $K$ jumps through time ($1 \\leq K \\leq N$). Please help Bessie\ndetermine the minimum number of years it will take her to visit all her\nancestors and return to the present year, with at most $K$ total jumps through\ntime along the way.  \n\nBessie does not need to use the time portal in a given Ox year if she does not\nwant to.  Time portals connect the first days of each Ox year with each-other,\nso for example if Bessie travels to a time portal and then waits 12 years for\nthe next time portal, she spends exactly 12 years in the process.  Bessie starts\nher adventure on the first day of the present Ox year, so she can travel back in\ntime right away.   None of Bessie's ancestors live in Ox years.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of input contains $N$ and $K$. The next $N$ lines contain $N$\ndistinct integers in the range $1 \\ldots 10^9$, indicating how many years ago each of\nBessie's $N$ ancestors lived.  \n\nOUTPUT FORMAT (print output to the terminal / stdout):\nPrint the minimum number of years it will take Bessie to visit all her ancestors\nand return to the present year.\n\n",
    "num_samples": 1
  },
  "596_silver_build_gates": {
    "name": "USACO 2016 January Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=596",
    "test_data_link": "http://www.usaco.org/current/data/gates_silver_jan16.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_gates_silver_jan16.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan16results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "596",
    "problem_id": "596_silver_build_gates",
    "description": "Farmer John decides to build a new fence around parts of his farm, but he keeps\ngetting distracted and ends up building the fence into a much stranger shape\nthan he intended!\nSpecifically, FJ starts at position $(0,0)$ and takes $N$ steps, each moving one\nunit of distance north, south, east, or west.  Each step he  takes, he lays a\nunit of fence behind him.  For example, if his first step is to the north, he\nadds a segment of fence from $(0,0)$ to $(0,1)$. FJ might re-visit points\nmultiple times and he may even lay the same segment of fence multiple times. \nHis fence might even cross over itself if his  path cuts through a run of\nfencing he has already built.\nNeedless to say, FJ is rather dismayed at the result after he completes the\nfence.  In particular, he notices that it may be the case that he has now\npartitioned off some areas of the farm from others, so that one can no longer\nwalk from one region to another without crossing a fence. FJ would like to add\ngates to his fences to fix this problem.  A gate can be added to any unit-length\nsegment of fence he has built, allowing passage between the two sides of this\nsegment.\nPlease determine the minimum number of gates FJ needs to build so that every\nregion of the farm is once again reachable from every other region.\nINPUT FORMAT (file gates.in):\nThe first line of input contains $N$ ($1 \\leq N \\leq 1000$). The next line\ncontains a string of length $N$ describing FJ's path. Each character is either N\n(north), E (east), S (south), or W (west).\nOUTPUT FORMAT (file gates.out):\nWrite out a single integer giving the minimum number of gates FJ needs to build\nto restore complete connectivity to all regions of his farm. Note that the\nanswer could be zero if the farm is connected to begin with.\nSAMPLE INPUT:\n14\nNNNESWWWSSEEEE\nSAMPLE OUTPUT:\n2\nProblem credits: Brian Dean"
  },
  "1208_silver_email_filing": {
    "name": "Email Filing",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1208",
    "test_data_link": "http://www.usaco.org/current/data/prob3_silver_feb22.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob3_silver_feb22.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb22results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "silver",
    "cp_id": "1208",
    "problem_id": "1208_silver_email_filing",
    "description": "Farmer John has fallen behind on organizing his inbox. The way his screen is\norganized, there is a vertical list of folders on the left side of the screen\nand a vertical list of emails on the right side of the screen. There are $M$\ntotal folders, numbered $1 \\ldots M$ ($1 \\le M \\le 10^4)$. His inbox currently\ncontains $N$ emails numbered $1\\ldots N$ ($1 \\le N \\le 10^5$); the $i$th email\nneeds to be filed into folder $f_i$ ($1\\le f_i\\le M$). \n\nFJ's screen is rather small, so he can only view $K$ ($1\\le K\\le \\min(N,M)$)\nfolders and $K$ emails at once.  Initially, his screen starts out displaying folders\n$1 \\ldots K$ on the left and emails $1 \\ldots K$ on the right.  To access other\nfolders and emails, he needs to scroll through these respective lists.  For\nexample, if he scrolls down one position in the list of folders, his screen will display\nfolders $2 \\ldots K+1$, and then scrolling down one position further it will display folders\n$3 \\ldots K+2$.  When FJ drags an email into a folder, the email disappears from\nthe email list, and the emails after the one that disappeared shift up by one\nposition.  For example, if emails $1, 2, 3, 4, 5$ are currently displayed and FJ\ndrags email 3 into its appropriate folder, the email list will now show emails\n$1, 2, 4, 5, 6$.  FJ can only drag an email into the folder to which it needs to\nbe filed.\n\nUnfortunately, the scroll wheel on FJ's mouse is broken, and he can only scroll\ndownwards, not upwards.  The only way he can achieve some semblance of upward\nscrolling is if he is viewing the last set of $K$ emails in his email list, and\nhe files one of these.  In this case, the email list will again show the last\n$K$ emails that haven't yet been filed, effectively scrolling the top email up\nby one. If there are fewer than $K$ emails remaining, then all of them will be\ndisplayed. \n\nPlease help FJ determine if it is possible to file all of his emails.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of input contains $T$ ($1 \\le T \\le 10$), the number of subcases\nin this input,  all of which must be solved correctly to solve the input case.\nThe $T$ subcases then follow.  For each subcase, the first line of input\ncontains $M$, $N$, and $K$. The next line contains $f_1 \\ldots f_N$.\n\nIt is guaranteed that the sum of $M$ over all subcases does not exceed $10^4$,\nand that the sum of $N$ over all subcases does not exceed $10^5$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $T$ lines, each one either containing either YES or NO, specifying\nwhether FJ can successfully file all his emails in each of the $T$ subcases.\n\nSAMPLE INPUT:\n6\n5 5 1\n1 2 3 4 5\n5 5 1\n1 2 3 5 4\n5 5 1\n1 2 4 5 3\n5 5 2\n1 2 4 5 3\n3 10 2\n1 3 2 1 3 2 1 3 2 1\n3 10 1\n1 3 2 1 3 2 1 3 2 1\nSAMPLE OUTPUT: \nYES\nYES\nNO\nYES\nYES\nNO\n\nSCORING:\nIn inputs 2-10, the sum of $M$ over all subcases does not exceed\n$10^3$.In inputs 11-12, no additional constraints.\n\n\nProblem credits: Brian Dean\n",
    "num_tests": 12,
    "solution": "\n(Analysis by Nick Wu)\nBecause we cannot scroll up on the folders, we have some constraints on how far\ndown we must scroll in the emails before we can scroll down on the list of\nfolders. Specifically, we must always scroll down to at least email $E$ if the\ntopmost folder currently being looked at will need to have email $E$ filed to\nit.\nTherefore, as long as we do some bookkeeping, we can simulate this process\ncarefully. We'll maintain a collection of emails that have not yet been filed\nand are currently being scrolled through, as well as the collection of emails\nthat have been skipped so far. We'll also keep track of the earliest point of\ntime when an email can be filed.\nWe'll loop through the folders in order, keeping track of the topmost folder.\nWe'll also loop through the emails in order until we get to the last email that\nneeds to be filed for the given topmost folder. If having that email on screen\nwould cause the window to overflow, we have to mark the topmost email as\nskipped. Afterwards, if we can file the email, we should do so immediately.\nOtherwise, it sits in the window. \nIn the event we have looped through all the emails, we also have to simulate the\nbehavior of scrolling up through the emails that we previously skipped.\nMy C++ code:\n\n#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid rsolve() {\n  int nfolder, nemail, windowsz;\n  cin >> nfolder >> nemail >> windowsz;\n  vector<int> emailtofolder(nemail);\n  vector<vector<int>> foldertoemail(nfolder);\n  vector<vector<int>> filetiming(nfolder);\n  vector<bool> filed(nemail);\n  vector<bool> skipped(nemail);\n  vector<bool> inwindow(nemail);\n  for(int i = 0; i < nemail; i++) {\n    cin >> emailtofolder[i];\n    filetiming[max(0, --emailtofolder[i] - windowsz + 1)].push_back(i);\n    foldertoemail[emailtofolder[i]].push_back(i);\n  }\n  int currentemail = 0;\n  int lhsemail = 0;\n  int numinwindow = 0;\n  int rhsemail = nemail-1;\n  auto fileemail = [&](int id) -> void {\n    if(inwindow[id]) {\n      inwindow[id] = false;\n      numinwindow--;\n    }\n    assert(!filed[id]);\n    filed[id] = true;\n  };\n  int bottom = 0;\n  for(int i = 0; i < nfolder; i++) {\n    // file anything that can be newly filed\n    if(i > bottom && i + windowsz <= nfolder) bottom++;\n    for(int out: filetiming[i]) if(inwindow[out]) fileemail(out);\n    while(foldertoemail[i].size() && currentemail <= foldertoemail[i].back()) {\n      // the window is full so in order to consider this email, we must scroll past the current one\n      if(numinwindow == windowsz) {\n        while(!inwindow[lhsemail]) lhsemail++;\n        skipped[lhsemail] = true;\n        inwindow[lhsemail] = false;\n        numinwindow--;\n      }\n      if(emailtofolder[currentemail] >= i && emailtofolder[currentemail] <= i + windowsz - 1) {\n        // can file\n        filed[currentemail++] = true;\n        continue;\n      }\n      inwindow[currentemail++] = true; numinwindow++;\n    }\n    // scroll through emails that would be implicitly loaded\n    while(currentemail < nemail && numinwindow < windowsz) {\n      if(emailtofolder[currentemail] >= i && emailtofolder[currentemail] <= i + windowsz - 1) {\n        // can file\n        filed[currentemail++] = true;\n        continue;\n      }\n      inwindow[currentemail++] = true; numinwindow++;\n    }\n    // scroll up emails since we've hit the end\n    if(currentemail == nemail) {\n      while(numinwindow < windowsz) {\n        if(rhsemail < 0) break;\n        if(!skipped[rhsemail]) {\n          rhsemail--;\n          continue;\n        }\n        if(emailtofolder[rhsemail] < bottom) {\n          cout << \"NO\\n\";\n          return;\n        }\n        if(emailtofolder[rhsemail] <= bottom + windowsz - 1) {\n          filed[rhsemail--] = true;\n          continue;\n        }\n        inwindow[rhsemail--] = true; numinwindow++;\n      }\n    }\n  }\n  for(auto out: filed) {\n    if(!out) {\n      cout << \"NO\\n\";\n      return;\n    }\n  }\n  cout << \"YES\\n\";\n}\n \nvoid solve() {\n  int t;\n  cin >> t;\n  while(t--) rsolve();\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n}\n\nDanny Mittal's Java code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n \npublic class EmailFiling {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n            int m = Integer.parseInt(tokenizer.nextToken());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int k = Integer.parseInt(tokenizer.nextToken());\n            tokenizer = new StringTokenizer(in.readLine());\n            int[] folder = new int[n];\n            int[] rem = new int[m];\n            for (int j = 0; j < n; j++) {\n                folder[j] = Integer.parseInt(tokenizer.nextToken()) - 1;\n                rem[folder[j]]++;\n            }\n            int firstFolder = 0;\n            int firstEmail = 0;\n            int lastEmail = k - 1;\n            boolean[] filed = new boolean[n];\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparingInt(j -> folder[j]));\n            for (int j = 0; j < k; j++) {\n                pq.add(j);\n            }\n            while (lastEmail < n - 1 && firstFolder < m) {\n                if (rem[firstFolder] == 0) {\n                    firstFolder++;\n                } else if (!pq.isEmpty() && folder[pq.peek()] < firstFolder + k) {\n                    int j = pq.remove();\n                    if (j >= firstEmail) {\n                        filed[j] = true;\n                        rem[folder[j]]--;\n                        lastEmail++;\n                        pq.add(lastEmail);\n                    }\n                } else {\n                    while (firstEmail < n && filed[firstEmail]) {\n                        firstEmail++;\n                    }\n                    firstEmail++;\n                    lastEmail++;\n                    pq.add(lastEmail);\n                }\n            }\n            String answer = \"YES\";\n            while (firstFolder < m) {\n                if (rem[firstFolder] == 0) {\n                    firstFolder++;\n                } else {\n                    if (pq.isEmpty()) {\n                        answer = \"NO\";\n                        break;\n                    }\n                    int j = pq.remove();\n                    if (j >= firstEmail && !filed[j]) {\n                        if (folder[j] >= firstFolder + k) {\n                            answer = \"NO\";\n                            break;\n                        }\n                        filed[j] = true;\n                        rem[folder[j]]--;\n                        while (firstEmail > 0) {\n                            firstEmail--;\n                            if (!filed[firstEmail]) {\n                                pq.add(firstEmail);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            out.append(answer).append('\\n');\n        }\n        System.out.print(out);\n    }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "6\n5 5 1\n1 2 3 4 5\n5 5 1\n1 2 3 5 4\n5 5 1\n1 2 4 5 3\n5 5 2\n1 2 4 5 3\n3 10 2\n1 3 2 1 3 2 1 3 2 1\n3 10 1\n1 3 2 1 3 2 1 3 2 1",
        "output": "YES\nYES\nNO\nYES\nYES\nNO",
        "explanation": ""
      }
    ],
    "description_no_samples": "Farmer John has fallen behind on organizing his inbox. The way his screen is\norganized, there is a vertical list of folders on the left side of the screen\nand a vertical list of emails on the right side of the screen. There are $M$\ntotal folders, numbered $1 \\ldots M$ ($1 \\le M \\le 10^4)$. His inbox currently\ncontains $N$ emails numbered $1\\ldots N$ ($1 \\le N \\le 10^5$); the $i$th email\nneeds to be filed into folder $f_i$ ($1\\le f_i\\le M$). \n\nFJ's screen is rather small, so he can only view $K$ ($1\\le K\\le \\min(N,M)$)\nfolders and $K$ emails at once.  Initially, his screen starts out displaying folders\n$1 \\ldots K$ on the left and emails $1 \\ldots K$ on the right.  To access other\nfolders and emails, he needs to scroll through these respective lists.  For\nexample, if he scrolls down one position in the list of folders, his screen will display\nfolders $2 \\ldots K+1$, and then scrolling down one position further it will display folders\n$3 \\ldots K+2$.  When FJ drags an email into a folder, the email disappears from\nthe email list, and the emails after the one that disappeared shift up by one\nposition.  For example, if emails $1, 2, 3, 4, 5$ are currently displayed and FJ\ndrags email 3 into its appropriate folder, the email list will now show emails\n$1, 2, 4, 5, 6$.  FJ can only drag an email into the folder to which it needs to\nbe filed.\n\nUnfortunately, the scroll wheel on FJ's mouse is broken, and he can only scroll\ndownwards, not upwards.  The only way he can achieve some semblance of upward\nscrolling is if he is viewing the last set of $K$ emails in his email list, and\nhe files one of these.  In this case, the email list will again show the last\n$K$ emails that haven't yet been filed, effectively scrolling the top email up\nby one. If there are fewer than $K$ emails remaining, then all of them will be\ndisplayed. \n\nPlease help FJ determine if it is possible to file all of his emails.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of input contains $T$ ($1 \\le T \\le 10$), the number of subcases\nin this input,  all of which must be solved correctly to solve the input case.\nThe $T$ subcases then follow.  For each subcase, the first line of input\ncontains $M$, $N$, and $K$. The next line contains $f_1 \\ldots f_N$.\n\nIt is guaranteed that the sum of $M$ over all subcases does not exceed $10^4$,\nand that the sum of $N$ over all subcases does not exceed $10^5$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $T$ lines, each one either containing either YES or NO, specifying\nwhether FJ can successfully file all his emails in each of the $T$ subcases.\n\n",
    "num_samples": 1
  },
  "619_silver_load_balancing": {
    "name": "USACO 2016 February Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=619",
    "test_data_link": "http://www.usaco.org/current/data/balancing_silver_feb16.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_balancing_silver_feb16.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb16results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "619",
    "problem_id": "619_silver_load_balancing",
    "description": "Farmer John's $N$ cows are each standing at distinct locations\n$(x_1, y_1) \\ldots (x_n, y_n)$ on his two-dimensional farm\n($1 \\leq N \\leq 1000$, and the $x_i$'s and $y_i$'s are positive odd integers of\nsize at most $1,000,000$).  FJ wants to partition his field by building a  long\n(effectively infinite-length) north-south fence with equation $x=a$ ($a$ will be\nan even integer, thus ensuring that he does not build the fence through the\nposition of any cow). He also wants to build a long (effectively\ninfinite-length) east-west fence with equation $y=b$, where $b$ is an even\ninteger.  These two fences cross at the point $(a,b)$, and together they\npartition his field into four regions.\nFJ wants to choose $a$ and $b$ so that the cows appearing in the four resulting\nregions are reasonably \"balanced\", with no region containing too many cows. \nLetting $M$ be the maximum number of cows appearing in one of the four regions,\nFJ wants to make $M$ as small as possible.  Please help him determine this\nsmallest possible value for $M$.\nINPUT FORMAT (file balancing.in):\nThe first line of the input contains a single integer, $N$. The next $N$ lines\neach contain the location of a single cow, specifying its $x$ and $y$\ncoordinates.\nOUTPUT FORMAT (file balancing.out):\nYou should output the smallest possible value of $M$ that FJ can achieve by\npositioning his fences optimally.\nSAMPLE INPUT:\n7\n7 3\n5 5\n7 13\n3 1\n11 7\n5 3\n9 1\nSAMPLE OUTPUT:\n2\nProblem credits: Brian Dean"
  },
  "512_silver_cow_routing": {
    "name": "USACO 2015 January Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=512",
    "test_data_link": "http://www.usaco.org/current/data/cowroute_silver.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_cowroute_silver.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan15results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "512",
    "problem_id": "512_silver_cow_routing",
    "description": "Problem 2: Cow Routing [Richard Peng, 2015]\n\nTired of the cold winter weather on her farm, Bessie the cow plans to\nfly to a warmer destination for vacation.  Unfortunately, she\ndiscovers that only one airline, Air Bovinia, is willing to sell\ntickets to cows, and that these tickets are somewhat complicated in\nstructure.\n\nAir Bovinia owns N planes (1 <= N <= 1000), each of which flies on a\nspecific \"route\" consisting of two or more cities.  For example, one\nplane might fly on a route that starts at city 1, then flies to city\n5, then flies to city 2, and then finally flies to city 8.  No city\nappears multiple times in a route.  If Bessie chooses to utilize a\nroute, she can board at any city along the route and then disembark at\nany city later along the route.  She does not need to board at the\nfirst city or disembark at the last city.  Each route has a certain\ncost, which Bessie must pay if she uses any part of the route,\nirrespective of the number of cities she visits along the route.  If\nBessie uses a route multiple times during her travel (that is, if she\nleaves the route and later comes back to use it from antoher city),\nshe must pay for it each time it is used.\n\nBessie would like to find the cheapest way to travel from her farm\n(in city A) to her tropical destination (city B). Please help her\ndecide what is the minimum cost she must pay, and also the smallest\nnumber of individual flights she must use take to achieve this minimum\ncost.\n\nINPUT: (file cowroute.in)\n\nThe first line of input contains A, B, and N, separated by spaces.  \n\nThe next 2N lines describe the available routes, in two lines per\nroute. The first line contains the cost of using the route (an integer\nin the range 1..1,000,000,000), and the number of cities along the\nroute (an integer in the range 1..100).  The second line contains a\nlist of the cities in order along the route.  Each city is identified\nby an integer in the range 1..1000.  Note that the cost of an\nitinerary can easily add up to more than can fit into a 32-bit\ninteger, so you should probably use 64-bit integers (e.g., \"long long\"\nintegers in C/C++).\n\nSAMPLE INPUT:\n\n3 4 3\n3 5\n1 2 3 4 5\n2 3\n3 5 4\n1 2\n1 5\n\nOUTPUT: (file cowroute.out)\n\nOutput the minimum cost of an itinerary that Bessie can use to travel\nfrom city A to city B, as well as the minimum number of individual\nflights required to achieve this minimum cost.  If there is no\nsolution, output \"-1 -1\" (quotes for clarity) on a single line.\n\nSAMPLE OUTPUT:\n\n2 2"
  },
  "967_silver_meetings": {
    "name": "Meetings",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=967",
    "test_data_link": "http://www.usaco.org/current/data/meetings_silver_dec19.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_meetings_silver_dec19.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec19results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "silver",
    "cp_id": "967",
    "problem_id": "967_silver_meetings",
    "description": "Two barns are located at positions $0$ and $L$ $(1\\le L\\le 10^9)$ on a\none-dimensional number line. There are also $N$ cows $(1\\le N\\le 5\\cdot 10^4)$\nat distinct locations on this number line (think of the barns and cows\neffectively as points). Each cow $i$ is initially located at some position $x_i$\nand moving in a positive or negative direction at a speed of one unit per\nsecond, represented by an integer $d_i$ that is either $1$ or $-1$. Each cow\nalso has a weight $w_i$ in the range $[1,10^3]$. All cows always move at a\nconstant velocity until one of the following events occur:\nIf cow $i$ reaches a barn, then cow $i$ stops moving.A meeting occurs when two cows $i$ and $j$ occupy the same point, where that\npoint is not a barn. In this case, cow $i$ is assigned cow $j$'s previous\nvelocity and vice versa. Note that cows could potentially meet at points that\nare not integers.\nLet $T$ be the earliest point in time when the sum of the weights of the cows\nthat have stopped moving (due to reaching one of the barns) is at least half of\nthe sum of the weights of all cows. Please determine the total number of\nmeetings between pairs of cows during the range of time $0 \\ldots T$ (including\nat time $T$).\n\nSCORING:\nTest cases 2-4 satisfy $N\\le 10^2$ and $w_i=1$ for all $i.$ Test cases 5-7 satisfy $N\\le 10^2.$ \n\nINPUT FORMAT:\nThe first line contains two space-separated integers $N$ and $L$. \n\nThe next $N$ lines each contain three space-separated integers $w_i$, $x_i$, and\n$d_i.$ All locations $x_i$ are distinct and satisfy $0<x_i<L.$\n\nOUTPUT FORMAT:\nPrint a single line containing the answer. \n\nSAMPLE INPUT:\n3 5\n1 1 1\n2 2 -1\n3 3 -1\nSAMPLE OUTPUT: \n2\n\nThe cows in this example move as follows:\n\n The first and second cows meet at position 1.5 at time 0.5. The first cow now\nhas velocity $-1$ and the second has velocity $1.$  The second and third cows meet at position 2 at time 1. The second cow now\nhas velocity $-1$ and the third has velocity $1.$  The first cow reaches the left barn at time 2.  The second cow reaches the left barn at time 3.  The process now terminates since the sum of the weights of the cows that \nhave reached a barn is at least half of the sum of the weights of all cows.  The\nthird cow would have reached the right barn at time 4. \nExactly two meetings occurred.\n\n\nProblem credits: Benjamin Qi\n",
    "num_tests": 13,
    "solution": "\n(Analysis by Benjamin Qi)\nNote: This problem is quite tricky for silver!\nFirst, sort all the cows by $x$-coordinate. For partial credit, we can simulate\neach collision that the cows make in $O(N),$ for a worst-case runtime of\n$O(N^3).$\nTo make solving the problem in $O(N\\log N)$ more manageable, let's split it into\ntwo independent parts.\nPart 1: Determining $T.$\nConsider the multiset of all times when the cows reach the barns. If the cows \ndid not actually switch velocities, \nCows with $d_i=-1$ contribute $x_i$ to the multiset.Cows with $d_i=1$ contribute $L-x_i$ to the multiset.\nNevertheless, this multiset remains the same regardless of whether cows switch\nvelocities or not.\nLet $z$ be the number of cows with $d_i=-1.$ Then exactly $z$ cows reach the\nleft barn,  so these must be precisely the $z$ leftmost cows. Thus, we can just\ntake all of the $x_i$ for the cows with initial $d_i=-1$ and set these equal to\nthe finishing times of the $z$ leftmost cows. Similarly, we can just take all of\nthe $L-x_i$ for cows with initial $d_i=1$ and set these equal to the finishing\ntimes of the $N-z$ rightmost cows. After this, we can sort all the finishing\ntimes again and maintain the current total weight in order to determine $T.$\nPart 2: Determining the number of meetings.\nNow we can ignore the weight condition and assume that cows do not switch\nvelocities after meeting; essentially, they will pass through each other. This\nwill not affect the answer. Then two cows with $x_i<x_j$ will meet if\n$d_i=1, d_j=-1, x_i+2T\\ge x_j.$ The number of such pairs can be computed by\niterating from left to right and maintaining a queue that consists of those cows\nwith $d_i=1$ that you are currently considering as meeting candidates.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi; \ntypedef vector<pair<int,int>> vpi; \n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \n#define pb push_back\n#define rsz resize\n#define sz(x) int(x.size())\n#define all(x) begin(x), end(x)\n#define f first\n#define s second\n\nvoid setIO(string name) {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfreopen((name+\".in\").c_str(),\"r\",stdin);\n\tfreopen((name+\".out\").c_str(),\"w\",stdout);\n}\n\nint N,L;\nvi w,x,d;\n \nvoid init() {\n\tsetIO(\"meetings\");\n\tcin >> N >> L;\n\tw.rsz(N), x.rsz(N), d.rsz(N);\n\tF0R(i,N) cin >> w[i] >> x[i] >> d[i];\n\tvi inds(N); iota(all(inds),0);\n\tsort(all(inds),[](int a, int b) { return x[a] < x[b]; });\n\tvi W,X,D;\n\ttrav(t,inds) {\n\t\tW.pb(w[t]);\n\t\tX.pb(x[t]);\n\t\tD.pb(d[t]);\n\t}\n\tswap(w,W), swap(x,X), swap(d,D);\n}\n \nint getTime() {\n\tvi lef, rig;\n\tF0R(i,N) {\n\t\tif (d[i] == -1) lef.pb(x[i]);\n\t\telse rig.pb(x[i]);\n\t}\n\tvpi v;\n\tF0R(i,sz(lef)) v.pb({lef[i],w[i]});\n\tF0R(i,sz(rig)) v.pb({L-rig[i],w[sz(lef)+i]});\n\tsort(all(v));\n\tint tot = 0; trav(t,v) tot += t.s;\n\ttrav(t,v) {\n\t\ttot -= 2*t.s;\n\t\tif (tot <= 0) return t.f;\n\t}\n}\n \nint main() {\n\tinit();\n\tint t = getTime(); \n\tqueue<int> rig;\n\tint ans = 0;\n\tF0R(i,N) {\n\t\tif (d[i] == -1) {\n\t\t\twhile (sz(rig) && rig.front()+2*t < x[i]) rig.pop();\n\t\t\tans += sz(rig);\n\t\t} else rig.push(x[i]);\n\t}\n\tcout << ans << \"\\n\";\n}\n\nFor some more problems in the same spirit see \n Independence #20 \nAnts on a Circle (AtCoder)\n  Ants\non a Circle (CodeForces) \n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 5\n1 1 1\n2 2 -1\n3 3 -1",
        "output": "2",
        "explanation": "The cows in this example move as follows:\n\n The first and second cows meet at position 1.5 at time 0.5. The first cow now\nhas velocity $-1$ and the second has velocity $1.$  The second and third cows meet at position 2 at time 1. The second cow now\nhas velocity $-1$ and the third has velocity $1.$  The first cow reaches the left barn at time 2.  The second cow reaches the left barn at time 3.  The process now terminates since the sum of the weights of the cows that \nhave reached a barn is at least half of the sum of the weights of all cows.  The\nthird cow would have reached the right barn at time 4. \nExactly two meetings occurred."
      }
    ],
    "description_no_samples": "Two barns are located at positions $0$ and $L$ $(1\\le L\\le 10^9)$ on a\none-dimensional number line. There are also $N$ cows $(1\\le N\\le 5\\cdot 10^4)$\nat distinct locations on this number line (think of the barns and cows\neffectively as points). Each cow $i$ is initially located at some position $x_i$\nand moving in a positive or negative direction at a speed of one unit per\nsecond, represented by an integer $d_i$ that is either $1$ or $-1$. Each cow\nalso has a weight $w_i$ in the range $[1,10^3]$. All cows always move at a\nconstant velocity until one of the following events occur:\nIf cow $i$ reaches a barn, then cow $i$ stops moving.A meeting occurs when two cows $i$ and $j$ occupy the same point, where that\npoint is not a barn. In this case, cow $i$ is assigned cow $j$'s previous\nvelocity and vice versa. Note that cows could potentially meet at points that\nare not integers.\nLet $T$ be the earliest point in time when the sum of the weights of the cows\nthat have stopped moving (due to reaching one of the barns) is at least half of\nthe sum of the weights of all cows. Please determine the total number of\nmeetings between pairs of cows during the range of time $0 \\ldots T$ (including\nat time $T$).\n\nSCORING:\nTest cases 2-4 satisfy $N\\le 10^2$ and $w_i=1$ for all $i.$ Test cases 5-7 satisfy $N\\le 10^2.$ \n\nINPUT FORMAT:\nThe first line contains two space-separated integers $N$ and $L$. \n\nThe next $N$ lines each contain three space-separated integers $w_i$, $x_i$, and\n$d_i.$ All locations $x_i$ are distinct and satisfy $0<x_i<L.$\n\nOUTPUT FORMAT:\nPrint a single line containing the answer. \n\n",
    "num_samples": 1
  },
  "1351_silver_cycle_correspondence": {
    "name": "USACO 2023 December Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1351",
    "test_data_link": "http://www.usaco.org/current/data/prob2_silver_dec23.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_silver_dec23.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec23results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "1351",
    "problem_id": "1351_silver_cycle_correspondence",
    "description": "Farmer John has $N$ barns ($3\\le N\\le 5\\cdot 10^5$), of which $K$\n($3\\le K\\le N$) distinct pairs of barns are connected.\nFirst, Annabelle assigns each barn a distinct integer label in the range\n$[1,N]$, and observes that the barns with labels $a_1,\\dots,a_K$  are connected\nin a cycle, in that order. That is, barns $a_i$ and $a_{i+1}$ are connected for\nall $1\\le i<K$, and barns $a_K$ and $a_1$ are also connected. All $a_i$ are\ndistinct.\nNext, Bessie also assigns each barn a distinct integer label in the range\n$[1,N]$ and observes that the barns with labels $b_1,\\dots,b_K$ are connected in\na cycle, in that order. All $b_i$ are distinct.\nSome (possibly none or all) barns are assigned the same label by Annabelle and\nBessie. Compute the maximum possible number of barns that are assigned the same\nlabel by Annabelle and Bessie.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $K$.\nThe next line contains $a_1,\\dots, a_K$.\nThe next line contains $b_1,\\dots, b_K$.\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe maximum number of fixed points.\nSAMPLE INPUT:\n6 3\n1 2 3\n2 3 1\nSAMPLE OUTPUT:\n6\nAnnabelle and Bessie could have assigned the same label to every barn.\nSAMPLE INPUT:\n6 3\n1 2 3\n4 5 6\nSAMPLE OUTPUT:\n0\nAnnabelle and Bessie could not have assigned the same label to any barn.\nSAMPLE INPUT:\n6 4\n1 2 3 4\n4 3 2 5\nSAMPLE OUTPUT:\n4\nAnnabelle and Bessie could have assigned labels $2,3,4,6$ to the same barns.\nSCORING:\nInputs 4-5: $N \\le 8$\nInputs 6-8: $N \\le 5000$\nInputs\n9-15: No additional constraints\nProblem credits: Benjamin Qi"
  },
  "125_silver_flowerpot": {
    "name": "Flowerpot",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=125",
    "test_data_link": "http://www.usaco.org/current/data/fpot.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_fpot.html",
    "contest_link": "http://www.usaco.org/index.php?page=mar12results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=mar12problems",
    "problem_level": "silver",
    "cp_id": "125",
    "problem_id": "125_silver_flowerpot",
    "description": "Problem 2: Flowerpot [Brian Dean, 2012]\n\nFarmer John has been having trouble making his plants grow, and needs your\nhelp to water them properly.  You are given the locations of N raindrops  \n(1 <= N <= 100,000) in the 2D plane, where y represents vertical height of\nthe drop, and x represents its location over a 1D number line:  \n\n\n\nEach drop falls downward (towards the x axis) at a rate of 1 unit per\nsecond.  You would like to place Farmer John's flowerpot of width W\nsomewhere along the x axis so that the difference in time between the\nfirst raindrop to hit the flowerpot and the last raindrop to hit the\nflowerpot is at least some amount D (so that the flowers in the pot receive\nplenty of water).  A drop of water that lands just on the edge of the\nflowerpot counts as hitting the flowerpot.\n\nGiven the value of D and the locations of the N raindrops, please compute\nthe minimum possible value of W.\n\nPROBLEM NAME: fpot\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers, N and D.  (1 <= D <=\n        1,000,000)\n\n* Lines 2..1+N: Line i+1 contains the space-separated (x,y)\n        coordinates of raindrop i, each value in the range\n        0...1,000,000.\n\nSAMPLE INPUT:\n\n4 5\n6 3\n2 4\n4 10\n12 15\n\nINPUT DETAILS:\n\nThere are 4 raindrops, at (6,3), (2,4), (4,10), and (12,15).  Rain must\nfall on the flowerpot for at least 5 units of time.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer, giving the minimum possible width of the\n        flowerpot.  Output -1 if it is not possible to build a\n        flowerpot wide enough to capture rain for at least D units of\n        time.\n\nSAMPLE OUTPUT:\n\n2\n\nOUTPUT DETAILS:\n\nA flowerpot of width 2 is necessary and sufficient, since if we place it\nfrom x=4..6, then it captures raindrops #1 and #3, for a total rain\nduration of 10-3 = 7.\n",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes: We first sort all the points on x, then\nsweep a pair of vertical \"sweep lines\" from left to right through the\nscene.  The y values of points between the sweep lines are stored in a\ndata structure that can quickly find the min and max, such as an STL \nmultiset (which we have used below) or a pair of priority queues.\nWhenever the difference between the max and min y coordinates is at\nleast D, we check if this represents the best flowerpot width so far,\nand then advance the left sweep line; otherwise, we advance the right\nsweep line.  The total running time is O(N log N). \n\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <vector>\n#define INF 2000000000\n\nusing namespace std;\n\ntypedef pair<int,int> Point;\nmultiset<int> Window;\nint N, D;\n\nint get_min(void) { return *(Window.begin()); } \nint get_max(void) { return *(Window.rbegin()); }\n\nint main(void)\n{\n  int i, j, x, y, ans=INF;\n  vector<Point> P;\n  \n  freopen (\"fpot.in\", \"r\", stdin);\n  freopen (\"fpot.out\", \"w\", stdout);\n  \n  scanf (\"%d %d\", &N, &D);\n  for (i=0; i<N; i++) {\n    scanf (\"%d %d\", &x, &y);\n    P.push_back(make_pair(x,y));\n  }\n  sort(&P[0], &P[N]);\n\n  i=j=0;\n  Window.insert(P[0].second);\n  while(1) {\n    if (get_max() - get_min() >= D) {\n      if (P[j].first-P[i].first < ans) ans = P[j].first-P[i].first;\n      multiset<nt>::iterator iter(Window.find(P[i++].second));\n      Window.erase(iter);\n    } else { \n      if (j==N-1) break;\n      Window.insert(P[++j].second);\n    }\n  }\n\n  printf (\"%d\\n\", ans==INF ? -1 : ans);\n  \n  return 0;\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4 5\n6 3\n2 4\n4 10\n12 15",
        "output": "2",
        "input_explanation": "There are 4 raindrops, at (6,3), (2,4), (4,10), and (12,15).  Rain must\nfall on the flowerpot for at least 5 units of time.",
        "output_explanation": "A flowerpot of width 2 is necessary and sufficient, since if we place it\nfrom x=4..6, then it captures raindrops #1 and #3, for a total rain\nduration of 10-3 = 7.",
        "explanation": "There are 4 raindrops, at (6,3), (2,4), (4,10), and (12,15).  Rain must\nfall on the flowerpot for at least 5 units of time.\nA flowerpot of width 2 is necessary and sufficient, since if we place it\nfrom x=4..6, then it captures raindrops #1 and #3, for a total rain\nduration of 10-3 = 7."
      }
    ],
    "description_no_samples": "Problem 2: Flowerpot [Brian Dean, 2012]\n\nFarmer John has been having trouble making his plants grow, and needs your\nhelp to water them properly.  You are given the locations of N raindrops  \n(1 <= N <= 100,000) in the 2D plane, where y represents vertical height of\nthe drop, and x represents its location over a 1D number line:  \n\n\n\nEach drop falls downward (towards the x axis) at a rate of 1 unit per\nsecond.  You would like to place Farmer John's flowerpot of width W\nsomewhere along the x axis so that the difference in time between the\nfirst raindrop to hit the flowerpot and the last raindrop to hit the\nflowerpot is at least some amount D (so that the flowers in the pot receive\nplenty of water).  A drop of water that lands just on the edge of the\nflowerpot counts as hitting the flowerpot.\n\nGiven the value of D and the locations of the N raindrops, please compute\nthe minimum possible value of W.\n\nPROBLEM NAME: fpot\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers, N and D.  (1 <= D <=\n        1,000,000)\n\n* Lines 2..1+N: Line i+1 contains the space-separated (x,y)\n        coordinates of raindrop i, each value in the range\n        0...1,000,000.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer, giving the minimum possible width of the\n        flowerpot.  Output -1 if it is not possible to build a\n        flowerpot wide enough to capture rain for at least D units of\n        time.",
    "description_raw": "Problem 2: Flowerpot [Brian Dean, 2012]\n\nFarmer John has been having trouble making his plants grow, and needs your\nhelp to water them properly.  You are given the locations of N raindrops  \n(1 <= N <= 100,000) in the 2D plane, where y represents vertical height of\nthe drop, and x represents its location over a 1D number line:  \n\n\n\nEach drop falls downward (towards the x axis) at a rate of 1 unit per\nsecond.  You would like to place Farmer John's flowerpot of width W\nsomewhere along the x axis so that the difference in time between the\nfirst raindrop to hit the flowerpot and the last raindrop to hit the\nflowerpot is at least some amount D (so that the flowers in the pot receive\nplenty of water).  A drop of water that lands just on the edge of the\nflowerpot counts as hitting the flowerpot.\n\nGiven the value of D and the locations of the N raindrops, please compute\nthe minimum possible value of W.\n\nPROBLEM NAME: fpot",
    "input_format": "* Line 1: Two space-separated integers, N and D.  (1 <= D <=\n        1,000,000)\n\n* Lines 2..1+N: Line i+1 contains the space-separated (x,y)\n        coordinates of raindrop i, each value in the range\n        0...1,000,000.",
    "output_format": "* Line 1: A single integer, giving the minimum possible width of the\n        flowerpot.  Output -1 if it is not possible to build a\n        flowerpot wide enough to capture rain for at least D units of\n        time.",
    "num_samples": 1
  },
  "1400_silver_moorbles": {
    "name": "USACO 2024 February Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1400",
    "test_data_link": "http://www.usaco.org/current/data/prob3_silver_feb24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob3_silver_feb24.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb24results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "1400",
    "problem_id": "1400_silver_moorbles",
    "description": "Bessie and Elsie are playing a game of Moorbles. The game works as follows:\nBessie and Elsie each start out with some amount of marbles. Bessie holds out\n$A$ of her marbles in her hoof and Elsie guesses if $A$ is Even or Odd. If Elsie\nis correct, she wins the $A$ marbles from Bessie and if she guesses incorrectly,\nshe loses $A$ of her marbles to Bessie (if Elsie has less than $A$ marbles, she\nloses all her marbles). A player loses when they lose all of their marbles.\nAfter some amount of turns in the game, Elsie has $N$ $(1 \\leq N \\leq 10^9)$\nmarbles. She thinks it is hard to win, but she is playing to not lose. After\nbeing around Bessie enough, Elsie has a good read on Bessie's habits and\nrecognizes that on turn $i$, there are only $K$ $(1 \\leq K \\leq 4)$ different\namounts of marbles that Bessie may put out. There are only $M$\n$(1 \\leq M \\leq 3 \\cdot 10^5)$ turns before Bessie gets bored and stops playing.\nCan you identify a lexicographically minimum turn sequence such that Elsie will\nnot lose, regardless of how Bessie plays?\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains a single integer $T$ ($1 \\leq T \\leq 10$) representing\nthe number of test cases. Each test case is described as follows:\nFirst, one line containing three integers $N$, $M$, and $K$, representing\nthe number of marbles Elsie has, the number of turns, and the number of\npotential moves Bessie can make respectively.\nThen, $M$ lines where\nline $i$ contains $K$ distinct space separated integers\n$a_{i,1} \\; a_{i,2} \\ldots a_{i,K}$ ($1 \\leq a_{i, j} \\leq 10^3$) representing\nthe possible amounts of marbles that Bessie might play on turn $i$.\nIt is guaranteed that the sum of $M$ over all test cases is at most\n$3 \\cdot 10^5$.\nOUTPUT FORMAT (print output to the terminal / stdout):\nFor each test case, output the lexicographically minimum move sequence for Elsie\nto guarantee not losing, or $-1$ if she will lose. The move sequence should be\non a single line and consist of $M$ space-separated tokens each equal to either\n\"Even\" or \"Odd\".\nNote: \"Even\" is lexicographically smaller than \"Odd\".\nSAMPLE INPUT:\n2\n10 3 2\n2 5\n1 3\n1 3\n10 3 3\n2 7 5\n8 3 4\n2 5 6\nSAMPLE OUTPUT:\nEven Even Odd\n-1\nIn the first case, the only lexicographically smaller sequence of moves is \"Even\nEven Even\", but Bessie can make Elsie lose in that case by first playing $5$,\nwhich reduces Elsie's number of marbles from $10$ to $5$, then playing $3$, which\nreduces Elsie's number of marbles from $5$ to $2$, then playing $3$, which wipes out\nall of her marbles.\nIf Elsie instead plays the correct move sequence \"Even Even Odd\", then if Bessie\nplays the same way, at the end when she plays $3$, Elsie will gain those $3$\nmarbles, increasing her number of marbles to $5$. It can further be shown that\nBessie cannot play in a different way to take all of Elsie's marbles given that\nElsie plays \"Even Even Odd\".\nIn the second case, it can be shown that for any move sequence that Elsie could\nchoose, Bessie can play in a way to take all of Elsie's marbles.\nSAMPLE INPUT:\n1\n20 8 2\n3 5\n3 5\n3 5\n3 5\n3 5\n3 5\n3 5\n3 5\nSAMPLE OUTPUT:\nEven Even Even Odd Even Odd Even Odd\nSCORING:\nInput 3: $M \\leq 16$.\nInputs 4-6: $M \\leq 1000$.\nInputs\n7-12: No further constraints.\nProblem credits: Suhas Nagar"
  },
  "210_silver_milk_routing": {
    "name": "Milk Routing",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=210",
    "test_data_link": "http://www.usaco.org/current/data/mroute.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_mroute.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec12results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=dec12problems",
    "problem_level": "silver",
    "cp_id": "210",
    "problem_id": "210_silver_milk_routing",
    "description": "Problem 3: Milk Routing [Brian Dean, 2012]\n\nFarmer John's farm has an outdated network of M pipes (1 <= M <= 500) for\npumping milk from the barn to his milk storage tank.  He wants to remove\nand update most of these over the next year, but he wants to leave exactly\none path worth of pipes intact, so that he can still pump milk from the\nbarn to the storage tank.\n\nThe pipe network is described by N junction points (1 <= N <= 500), each of\nwhich can serve as the endpoint of a set of pipes.  Junction point 1 is the\nbarn, and junction point N is the storage tank.  Each of the M\nbi-directional pipes runs between a pair of junction points, and has an\nassociated latency (the amount of time it takes milk to reach one end of\nthe pipe from the other) and capacity (the amount of milk per unit time\nthat can be pumped through the pipe in steady state).  Multiple pipes\ncan connect between the same pair of junction points.\n\nFor a path of pipes connecting from the barn to the tank, the latency\nof the path is the sum of the latencies of the pipes along the path,\nand the capacity of the path is the minimum of the capacities of the\npipes along the path (since this is the \"bottleneck\" constraining the\noverall rate at which milk can be pumped through the path).  If FJ\nwants to send a total of X units of milk through a path of pipes with\nlatency L and capacity C, the time this takes is therefore L + X/C.\n\nGiven the structure of FJ's pipe network, please help him select a single\npath from the barn to the storage tank that will allow him to pump X units\nof milk in a minimum amount of total time.\n\nPROBLEM NAME: mroute\n\nINPUT FORMAT:\n\n* Line 1: Three space-separated integers: N M X (1 <= X <= 1,000,000).\n\n* Lines 2..1+M: Each line describes a pipe using 4 integers: I J L C. \n        I and J (1 <= I,J <= N) are the junction points at both ends\n        of the pipe.  L and C (1 <= L,C <= 1,000,000) give the latency\n        and capacity of the pipe.\n\nSAMPLE INPUT:\n\n3 3 15\n1 2 10 3\n3 2 10 2\n1 3 14 1\n\nINPUT DETAILS:\n\nFJ wants to send 15 units of milk through his pipe network.  Pipe #1\nconnects junction point 1 (the barn) to junction point 2, and has a latency\nof 10 and a capacity of 3.  Pipes #2 and #3 are similarly defined.\n\nOUTPUT FORMAT:\n\n* Line 1: The minimum amount of time it will take FJ to send milk\n        along a single path, rounded down to the nearest integer.\n\nSAMPLE OUTPUT:\n\n27\n\nOUTPUT DETAILS:\n\nThe path 1->3 takes 14 + 15/1 = 29 units of time.  The path 1->2->3 takes\n20 + 15/2 = 27.5 units of time, and is therefore optimal.\n",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes (Jonathan Paulson): It's not obvious how to\nmake the tradeoff between latency and capacity. But the graph is\nreally small: only 500 edges. Even a quadratic algorithm will be fast\nenough. \nConsider the optimal path. It has some minimum capacity C. The key\nobservation is that if you throw out edges with capacity less than C,\nthen the optimal path is just a shortest path. If only we knew C, we\ncould just run Dijkstra.\nBut there are only M possible values for C (the minimum capacity of\nthe optimal path is the capacity of its bottleneck edge, which is\n*some* edge). So we can just try all M values for C, run Dijkstra on\neach subgraph (of edges with capacity at least C), and take the best\nof these M paths (of course, if we choose a value if C so that the\ndestination is not reachable, it can't have been right). Since\nDijkstra is O(M log M), this idea is O(M^2 log M), which is fast\nenough. Here is Travis Hance's solution in C++:  \n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define NMAX 500\n#define MMAX 500\n#define infinite 1000000000000000000LL\n\nstruct edge {\n    int dest;\n    long long latency, cap;\n    edge(int dest, long long latency, long long cap) :\n        dest(dest), latency(latency), cap(cap) { }\n};\nvector<edge> edges[NMAX];\nlong long caps[MMAX];\n\nstruct entry {\n    int v;\n    long long dist;\n    entry(int v, long long dist) : v(v), dist(dist) { }\n    bool operator<(entry const& o) const {\n        return dist > o.dist;\n    }\n};\n\nbool visited[NMAX];\nlong long minL(int n, int source, int dest, int minCap) {\n    for (int i = 0; i < n; i++) {\n        visited[i] = false;\n    }\n    priority_queue<entry> q;\n    q.push(entry(source, 0));\n    while(q.size() > 0) {\n        entry cur = q.top();\n        q.pop();\n        if (visited[cur.v]) {\n            continue;\n        }\n        if (cur.v == dest) {\n            return cur.dist;\n        }\n        visited[cur.v] = true;\n        for (int i = 0; i < edges[cur.v].size(); i++) {\n            edge e = edges[cur.v][i];\n            if (e.cap >= minCap) {\n                q.push(entry(e.dest, cur.dist + e.latency));\n            }\n        }\n    }\n    return infinite;\n}\n\nint main() {\n    freopen(\"mroute.in\",\"r\",stdin);\n    freopen(\"mroute.out\",\"w\",stdout);\n\n    int n, m;\n    long long X;\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    scanf(\"%lld\", &X);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        long long l, c;\n        scanf(\"%d\", &a);\n        scanf(\"%d\", &b);\n        scanf(\"%lld\", &l);\n        scanf(\"%lld\", &c);\n        a--;\n        b--;\n        edges[a].push_back(edge(b, l, c));\n        edges[b].push_back(edge(a, l, c));\n        caps[i] = c;\n    }\n\n    long long mintime = infinite;\n    for (int i = 0; i < m; i++) {\n        long long c = caps[i];\n        long long l = minL(n, 0, n-1, c);\n        if (l != infinite) {\n            mintime = min(mintime, l + X/c);\n        }\n    }\n    printf(\"%lld\\n\", mintime);\n}\n\n\nAnd here is Jonathan Paulson's solution in Java:\n\n\nimport java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport static java.lang.Math.*;\n\npublic class mroute {\n    static int n;\n    static int A;\n    static int B;\n    static int[] X = new int[n];\n    public static void main(String[] args) throws Exception {\n        Scanner in = new Scanner(new File(\"mroute.in\"));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new\nFileWriter(\"mroute.out\")));\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int AMT = in.nextInt();\n        List<List<int[]>> E = new ArrayList<List<int[]>>();\n        for(int i=0; i<n; i++) E.add(new ArrayList<int[]>());\n        int[] Cs = new int[m];\n        Set<Integer> U = new HashSet<Integer>();\n        for(int i=0; i<m; i++) {\n            int x = in.nextInt()-1;\n            int y = in.nextInt()-1;\n            int L = in.nextInt();\n            int C = in.nextInt();\n            if(x==y) {\n                out.println(1000*1000*1000);\n                out.flush();\n                return;\n            }\n            if(U.contains(x*500+y)) {\n                out.println(1000*1000*100);\n                out.flush();\n                return;\n            }\n            U.add(x*500+y);\n            Cs[i] = C;\n            E.get(x).add(new int[]{y,L,C});\n            E.get(y).add(new int[]{x,L,C});\n        }\n        Arrays.sort(Cs);\n\n        int ans = 1000*1000*1000;\n        for(int c=0; c<m; c++) {\n            Queue<int[]> PQ = new PriorityQueue<int[]>(10, new\nComparator<int[]>() {\n                public int compare(int[] A, int[] B) {\n                    return A[1]-B[1];\n                }\n            });\n            PQ.offer(new int[]{0, 0});\n            boolean[] S = new boolean[n];\n            int dist = 1000*1000*1000;\n            while(!PQ.isEmpty()) {\n                int[] X = PQ.poll();\n                int v = X[0];\n                int d = X[1];\n                if(S[v]) continue;\n                S[v] = true;\n                if(v == n-1) {\n                    dist = d;\n                    break;\n                }\n                for(int[] e:E.get(v)) {\n                    if(e[2] < Cs[c]) continue;\n                    PQ.offer(new int[]{e[0], d+e[1]});\n                }\n            }\n            ans = min(ans, dist + AMT/Cs[c]);\n        }\n        out.println(ans);\n        out.flush();\n    }\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 3 15\n1 2 10 3\n3 2 10 2\n1 3 14 1",
        "output": "27",
        "input_explanation": "FJ wants to send 15 units of milk through his pipe network.  Pipe #1\nconnects junction point 1 (the barn) to junction point 2, and has a latency\nof 10 and a capacity of 3.  Pipes #2 and #3 are similarly defined.",
        "output_explanation": "The path 1->3 takes 14 + 15/1 = 29 units of time.  The path 1->2->3 takes\n20 + 15/2 = 27.5 units of time, and is therefore optimal.",
        "explanation": "FJ wants to send 15 units of milk through his pipe network.  Pipe #1\nconnects junction point 1 (the barn) to junction point 2, and has a latency\nof 10 and a capacity of 3.  Pipes #2 and #3 are similarly defined.\nThe path 1->3 takes 14 + 15/1 = 29 units of time.  The path 1->2->3 takes\n20 + 15/2 = 27.5 units of time, and is therefore optimal."
      }
    ],
    "description_no_samples": "Problem 3: Milk Routing [Brian Dean, 2012]\n\nFarmer John's farm has an outdated network of M pipes (1 <= M <= 500) for\npumping milk from the barn to his milk storage tank.  He wants to remove\nand update most of these over the next year, but he wants to leave exactly\none path worth of pipes intact, so that he can still pump milk from the\nbarn to the storage tank.\n\nThe pipe network is described by N junction points (1 <= N <= 500), each of\nwhich can serve as the endpoint of a set of pipes.  Junction point 1 is the\nbarn, and junction point N is the storage tank.  Each of the M\nbi-directional pipes runs between a pair of junction points, and has an\nassociated latency (the amount of time it takes milk to reach one end of\nthe pipe from the other) and capacity (the amount of milk per unit time\nthat can be pumped through the pipe in steady state).  Multiple pipes\ncan connect between the same pair of junction points.\n\nFor a path of pipes connecting from the barn to the tank, the latency\nof the path is the sum of the latencies of the pipes along the path,\nand the capacity of the path is the minimum of the capacities of the\npipes along the path (since this is the \"bottleneck\" constraining the\noverall rate at which milk can be pumped through the path).  If FJ\nwants to send a total of X units of milk through a path of pipes with\nlatency L and capacity C, the time this takes is therefore L + X/C.\n\nGiven the structure of FJ's pipe network, please help him select a single\npath from the barn to the storage tank that will allow him to pump X units\nof milk in a minimum amount of total time.\n\nPROBLEM NAME: mroute\n\nINPUT FORMAT:\n\n* Line 1: Three space-separated integers: N M X (1 <= X <= 1,000,000).\n\n* Lines 2..1+M: Each line describes a pipe using 4 integers: I J L C. \n        I and J (1 <= I,J <= N) are the junction points at both ends\n        of the pipe.  L and C (1 <= L,C <= 1,000,000) give the latency\n        and capacity of the pipe.\n\nOUTPUT FORMAT:\n\n* Line 1: The minimum amount of time it will take FJ to send milk\n        along a single path, rounded down to the nearest integer.",
    "description_raw": "Problem 3: Milk Routing [Brian Dean, 2012]\n\nFarmer John's farm has an outdated network of M pipes (1 <= M <= 500) for\npumping milk from the barn to his milk storage tank.  He wants to remove\nand update most of these over the next year, but he wants to leave exactly\none path worth of pipes intact, so that he can still pump milk from the\nbarn to the storage tank.\n\nThe pipe network is described by N junction points (1 <= N <= 500), each of\nwhich can serve as the endpoint of a set of pipes.  Junction point 1 is the\nbarn, and junction point N is the storage tank.  Each of the M\nbi-directional pipes runs between a pair of junction points, and has an\nassociated latency (the amount of time it takes milk to reach one end of\nthe pipe from the other) and capacity (the amount of milk per unit time\nthat can be pumped through the pipe in steady state).  Multiple pipes\ncan connect between the same pair of junction points.\n\nFor a path of pipes connecting from the barn to the tank, the latency\nof the path is the sum of the latencies of the pipes along the path,\nand the capacity of the path is the minimum of the capacities of the\npipes along the path (since this is the \"bottleneck\" constraining the\noverall rate at which milk can be pumped through the path).  If FJ\nwants to send a total of X units of milk through a path of pipes with\nlatency L and capacity C, the time this takes is therefore L + X/C.\n\nGiven the structure of FJ's pipe network, please help him select a single\npath from the barn to the storage tank that will allow him to pump X units\nof milk in a minimum amount of total time.\n\nPROBLEM NAME: mroute",
    "input_format": "* Line 1: Three space-separated integers: N M X (1 <= X <= 1,000,000).\n\n* Lines 2..1+M: Each line describes a pipe using 4 integers: I J L C. \n        I and J (1 <= I,J <= N) are the junction points at both ends\n        of the pipe.  L and C (1 <= L,C <= 1,000,000) give the latency\n        and capacity of the pipe.",
    "output_format": "* Line 1: The minimum amount of time it will take FJ to send milk\n        along a single path, rounded down to the nearest integer.",
    "num_samples": 1
  },
  "791_gold_stamp_painting": {
    "name": "Stamp Painting",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=791",
    "test_data_link": "http://www.usaco.org/current/data/spainting_gold_jan18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_spainting_gold_jan18.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "gold",
    "cp_id": "791",
    "problem_id": "791_gold_stamp_painting",
    "description": "Bessie has found herself in possession of an $N$-unit long strip of canvas\n($1 \\leq N \\leq 10^6$), and she intends to paint it. However, she has been\nunable to acquire paint brushes. In their place she has $M$ rubber stamps of\ndifferent colors ($1 \\leq M \\leq 10^6$), each stamp $K$ units wide\n($1 \\leq K \\leq 10^6$). Astounded by the possibilities that lie before her, she\nwishes to know exactly how many different paintings she could conceivably\ncreate, by stamping her stamps in some order on the canvas.\n\nTo use a stamp, it must first be aligned with exactly $K$ neighboring units on\nthe canvas. The stamp cannot extend beyond the ends of the canvas, nor can it\ncover fractions of units. Once placed, the stamp paints the $K$ covered units\nwith its color. Any given stamp may be used multiple times, once, or even never\nat all. But by the time Bessie is finished, every unit of canvas must have been\npainted at least once.\n\nHelp Bessie find the number of different paintings that she could paint, modulo\n$10^9 + 7$. Two paintings that look identical but were painted by different\nsequences of stamping operations are counted as the same.\n\nFor at least 75% of the input cases, $N,K \\leq 10^3$.\n\nINPUT FORMAT:\nThe first and only line of input has three integers, $N$, $M$, and $K$. It is\nguaranteed that $K \\leq N$.\n\nOUTPUT FORMAT:\nA single integer: the number of possible paintings, modulo $10^9 + 7$.\n\nSAMPLE INPUT:\n3 2 2\nSAMPLE OUTPUT: \n6\n\nIf the two stamps have colors A and B, the possible paintings are AAA, AAB, ABB,\nBAA, BBA, and BBB.\n\n\nProblem credits: Dhruv Rohatgi\n",
    "num_tests": 12,
    "solution": "\n(Analysis by  Dhruv Rohatgi )\nThe first step is to find some criterion for which paintings can be created,\nwhere a painting is defined by $N$ numbers, each between $1$ and $M$ inclusive.\nTo this end, note that the last stamp Bessie uses will color $K$ consecutive\nunits with the same color, and so in the final painting, there must be $K$\nconsecutive units with the same color. \nConversely, consider an arbitrary painting which satisfies this condition. It is\nnot difficult to see that this painting must be attainable by some sequence of\nstampings: suppose the units in range $[i,i+K)$ have the same color. Start at\nthe left end and work rightwards, stamping $[1,K+1)$ with the desired color for\nunit $1$, then stamping $[2, K+2)$ with the desired color for unit $2$, all the\nway until we reach $[i, K+i)$. Then similarly start from the right end and work\nleftwards. Once $[i, K+i)$ has been reached a second time, we have produced the\ndesired painting.\nSo this problem is asking us to count the number of ways to pick $N$ numbers\nbetween $1$ and $M$ inclusive, so that some $K$ consecutive numbers are equal.\nAs is often the case, it is simpler to count the complement. We will count the\nnumber of ways to pick $N$ numbers between $1$ and $M$ so that no $K$\nconsecutive numbers are all equal. Since there are $M^N$ ways to pick the\nnumbers with no such restrictions, we will then subtract our complementary\nanswer from $M^N$, to obtain our final answer.\nWe can use dynamic programming to solve this reduced problem. Let $\\text{dp}(n)$\nbe the number of ways to pick $n$ numbers between $1$ and $M$ so that no $K$\nconsecutive numbers are equal. If $n<K$, this is a base case and the answer is\n$M^n$. Otherwise, note that in any good coloring, the last $K$ numbers cannot be\nequal. So for each good coloring, there is some $c < K$ so that the last $c$\nnumbers are equal, but the $c+1$-st number is different. Fix some $c$. Then\nthere are $\\text{dp}(n-c)$ ways to pick numbers for the first $n-c$ units, and\n$M-1$ ways to pick one number for the last $c$ units. This yields the recurrence\nrelation $$\\text{dp}(n) = (M-1) \\cdot \\sum_{c=1}^{K-1} \\text{dp}(n-c).$$\nWe immediately have a $O(NK)$ solution, which gets 75% of the points on this\nproblem. To get full credit, one must make the following final observation. Let\n$s(n) = \\sum_{i=1}^n \\text{dp}(n)$. Then the above recurrence implies the\nfollowing closed-form recurrence: $$s(n) - s(n-1) = (M-1)(s(n-1) - s(n-K))$$ or\n$$s(n) = Ms(n-1) - (M-1)s(n-K).$$\nSo rather than computing $\\text{dp}(n)$ directly, we compute $s(n)$, and observe\nthat $\\text{dp}(N) = s(N) - s(N-1)$. This yields an $O(N)$ algorithm.\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MOD 1000000007\n \nint s[10000001];\n \nint main()\n{\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\t\n\ts[0] = 0;\n\tfor(int i=1;i<K;i++)\n\t\ts[i] = (M*((long long)s[i-1]) + M)%MOD;\n\tfor(int i=K;i<=N;i++)\n\t\ts[i] = (M*((long long)s[i-1]) + MOD - ((M-1)*((long long)s[i-K]))%MOD)%MOD;\n \n\tint ans = 1;\n\tfor(int i=1;i<=N;i++)\n\t\tans = (M*((long long)ans))%MOD;\n\t\n\tcout << (((long long)ans) + MOD - ((long long)s[N]) + s[N-1])%MOD << '\\n';\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 2 2",
        "output": "6",
        "explanation": ""
      }
    ],
    "description_no_samples": "Bessie has found herself in possession of an $N$-unit long strip of canvas\n($1 \\leq N \\leq 10^6$), and she intends to paint it. However, she has been\nunable to acquire paint brushes. In their place she has $M$ rubber stamps of\ndifferent colors ($1 \\leq M \\leq 10^6$), each stamp $K$ units wide\n($1 \\leq K \\leq 10^6$). Astounded by the possibilities that lie before her, she\nwishes to know exactly how many different paintings she could conceivably\ncreate, by stamping her stamps in some order on the canvas.\n\nTo use a stamp, it must first be aligned with exactly $K$ neighboring units on\nthe canvas. The stamp cannot extend beyond the ends of the canvas, nor can it\ncover fractions of units. Once placed, the stamp paints the $K$ covered units\nwith its color. Any given stamp may be used multiple times, once, or even never\nat all. But by the time Bessie is finished, every unit of canvas must have been\npainted at least once.\n\nHelp Bessie find the number of different paintings that she could paint, modulo\n$10^9 + 7$. Two paintings that look identical but were painted by different\nsequences of stamping operations are counted as the same.\n\nFor at least 75% of the input cases, $N,K \\leq 10^3$.\n\nINPUT FORMAT:\nThe first and only line of input has three integers, $N$, $M$, and $K$. It is\nguaranteed that $K \\leq N$.\n\nOUTPUT FORMAT:\nA single integer: the number of possible paintings, modulo $10^9 + 7$.\n\n",
    "num_samples": 1
  },
  "127_gold_large_banner": {
    "name": "Large Banner",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=127",
    "test_data_link": "http://www.usaco.org/current/data/banner.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_banner.html",
    "contest_link": "http://www.usaco.org/index.php?page=mar12results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=mar12problems",
    "problem_level": "gold",
    "cp_id": "127",
    "problem_id": "127_gold_large_banner",
    "description": "Problem 1: Large Banner [Nathan Pinsker, 2010]\n\nBessie is returning from a long trip abroad to the Isle of Guernsey, and\nFarmer John wants to mount a nice \"Welcome Home\" banner for her arrival. \nFarmer John's field has integer dimensions M x N (1 <= M, N <= 100,000),\nand he has installed a post at every possible point in the field with\ninteger coordinates (if we assign a coordinate system to the field so that\n(0,0) is in the lower-left corner and (M,N) is in the upper-right corner).\nOf these (M+1) * (N+1) points, Farmer John must pick two as the endpoints\nof the banner.\n \nFarmer John, being the perfectionist that he is, insists that the banner\nmust be completely straight.  This means that, for the two posts he\nchooses, there cannot be any other post on the line segment that the banner\nwill form between them.  Additionally, Farmer John wants the banner to have\nlength at least L and at most H (1 <= L <= H <= 150,000).  Farmer John\nneeds your help to figure out how many possible ways he can hang the\nbanner. The banner is reversible, so switching the two endpoints of the\nbanner counts as the same way to hang the banner. As this number may be\nvery large, Farmer John simply wants to know what it is modulo B (1 <= B <=\n1,000,000,000). \n\nConsider the example below, with M = 2 and N = 2:\n\n* * *\n* * *\n* * *\n\nFarmer John wants the length of the banner to be between 1 and 3 inclusive.\nAny choice of posts satisfies this length requirement, but note that eight\npairs cannot be picked:\n\n(0, 0) and (2, 0): (1, 0) is on the line segment between them\n(0, 1) and (2, 1): (1, 1) is on the line segment between them\n(0, 2) and (2, 2): (1, 2) is on the line segment between them\n(0, 0) and (2, 2): (1, 1) is on the line segment between them\n(0, 0) and (0, 2): (0, 1) is on the line segment between them\n(1, 0) and (1, 2): (1, 1) is on the line segment between them\n(2, 0) and (2, 2): (2, 1) is on the line segment between them\n(0, 2) and (2, 0): (1, 1) is on the line segment between them\n\nTherefore, there are a total of (9 choose 2) - 8 = 28 possible locations. \n\nPROBLEM NAME: banner\n\nINPUT FORMAT:\n\n* Line 1: Five space-separated integers: M, N, L, H and B.\n\nSAMPLE INPUT:\n\n2 2 1 3 100\n\nOUTPUT FORMAT:\n\n* Line 1: One integer denoting the number of possible banners (modulo B).\n\nSAMPLE OUTPUT:\n\n28\n",
    "num_tests": 20,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes (Nathan Pinsker): The first step to solving this problem is to\nnotice that we can quickly find all banners of a certain width and\nheight. If a banner with width w and height h is allowed, then all\nother banners with width w and height h are allowed, and we can find\nthe number of them using some simple arithmetic. It is also fairly\nstraightforward to check if such a banner is allowed -- it is only if\nL*L <= (w*w + h*h) <= H*H and gcd(w, h) = 1. \nSince the field can potentially be of size 100,000 x 100,000, even\nconsidering each possible size of the banner once will take too much\ntime. However, if we consider each possible width that the banner can\nhave, and if, given that width, we can quickly sum the allowed heights\nfor the banner, then we will have solved the problem. For each width\nw, the sum that we want to obtain is equal to (all numbers between\nceil(sqrt(L*L - w*w)) and floor(sqrt(H*H - w*w)) inclusive) - (all\nnumbers in the same range that share a divisor with w). The first\nquantity is easy to obtain, while the second requires a little more\nwork. To calculate the second quantity, we note that, although w could\nhave a large variety of prime divisors, it does not have very many of\nthem. This important insight allows us to quickly find the sum: we\nfind the prime factors of w, then we use the inclusion-exclusion\nprinciple to calculate the sum of all numbers between L and H that are\ndivisible by at least one of the numbers.\n Below is Travis Hance's code.\n\n\n#include <cstdio>\n\n#define nmax 100005\n\ntypedef long long ll;\n\nint prime_divs[nmax][6];\nint num_prime_divs[nmax];\n\nll m,n,l,h,p;\n\ninline ll sum(ll lo, ll hi, ll mul) {\n\thi = hi / mul;\n\tlo = (lo + mul - 1) / mul;\n\treturn ((hi - lo + 1) * (m + 1) - mul * ((hi*(hi+1) - (lo-1)*lo) / 2)) % p;\n}\n\nint main() {\n\tfreopen(\"banner.in\",\"r\",stdin);\n\tfreopen(\"banner.out\",\"w\",stdout);\n\n\tscanf(\"%lld\", &m);\n\tscanf(\"%lld\", &n);\n\tscanf(\"%lld\", &l);\n\tscanf(\"%lld\", &h);\n\tscanf(\"%lld\", &p);\n\t\n\tfor(int i = 1; i <= n; i++)\n\t\tnum_prime_divs[i] = 0;\n\tfor(int i = 2; i <= n; i++)\n\t\tif(num_prime_divs[i] == 0)\n\t\t\tfor(int j = i; j <= n; j += i)\n\t\t\t\tprime_divs[j][num_prime_divs[j]++] = i;\n\n\tll ans = 0;\n\n\tll lo = l, hi = h;\n\n\tint minnh = (n < h ? n : h);\n\tfor(ll w = 1; w <= minnh; w++) {\n\t\twhile(lo > 1 && l*l - w*w <= (lo-1)*(lo-1))\n\t\t\tlo--;\n\t\twhile(h*h - w*w < hi*hi)\n\t\t\thi--;\n\t\tif(lo <= hi && lo <= m) {\n\t\t\tll a = 0;\n\t\t\tint p2 = (1 << num_prime_divs[w]);\n\t\t\tfor(int i = 0; i < p2; i++) {\n\t\t\t\tint i1 = i;\n\t\t\t\tll prod = 1;\n\t\t\t\tint parity = 1;\n\t\t\t\tfor(int j = 0; j < num_prime_divs[w]; j++) {\n\t\t\t\t\tif(i1 & 1) {\n\t\t\t\t\t\tprod *= prime_divs[w][j];\n\t\t\t\t\t\tparity *= -1;\n\t\t\t\t\t}\n\t\t\t\t\ti1 >>= 1;\n\t\t\t\t}\n\t\t\t\ta += parity * sum(lo, hi < m ? hi : m, prod);\n\t\t\t}\n\t\t\tans = (ans + a*(n-w+1)) % p;\n\t\t\tif(ans < 0) ans += p;\n\t\t\t//printf(\"w = %lld, ans = %lld, lo = %lld, hi = %lld\\n\", w, ans, lo, hi);\n\t\t}\n\t}\n\n\tif(l <= 1 && 1 <= h)\n\t\tans = (2*ans + n*(m+1) + m*(n+1)) % p;\n\telse\n\t\tans = (2 * ans) % p;\n\tprintf(\"%d\\n\", (int)ans);\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "2 2 1 3 100",
        "output": "28",
        "input_explanation": "",
        "output_explanation": "",
        "explanation": ""
      }
    ],
    "description_no_samples": "Problem 1: Large Banner [Nathan Pinsker, 2010]\n\nBessie is returning from a long trip abroad to the Isle of Guernsey, and\nFarmer John wants to mount a nice \"Welcome Home\" banner for her arrival. \nFarmer John's field has integer dimensions M x N (1 <= M, N <= 100,000),\nand he has installed a post at every possible point in the field with\ninteger coordinates (if we assign a coordinate system to the field so that\n(0,0) is in the lower-left corner and (M,N) is in the upper-right corner).\nOf these (M+1) * (N+1) points, Farmer John must pick two as the endpoints\nof the banner.\n \nFarmer John, being the perfectionist that he is, insists that the banner\nmust be completely straight.  This means that, for the two posts he\nchooses, there cannot be any other post on the line segment that the banner\nwill form between them.  Additionally, Farmer John wants the banner to have\nlength at least L and at most H (1 <= L <= H <= 150,000).  Farmer John\nneeds your help to figure out how many possible ways he can hang the\nbanner. The banner is reversible, so switching the two endpoints of the\nbanner counts as the same way to hang the banner. As this number may be\nvery large, Farmer John simply wants to know what it is modulo B (1 <= B <=\n1,000,000,000). \n\nConsider the example below, with M = 2 and N = 2:\n\n* * *\n* * *\n* * *\n\nFarmer John wants the length of the banner to be between 1 and 3 inclusive.\nAny choice of posts satisfies this length requirement, but note that eight\npairs cannot be picked:\n\n(0, 0) and (2, 0): (1, 0) is on the line segment between them\n(0, 1) and (2, 1): (1, 1) is on the line segment between them\n(0, 2) and (2, 2): (1, 2) is on the line segment between them\n(0, 0) and (2, 2): (1, 1) is on the line segment between them\n(0, 0) and (0, 2): (0, 1) is on the line segment between them\n(1, 0) and (1, 2): (1, 1) is on the line segment between them\n(2, 0) and (2, 2): (2, 1) is on the line segment between them\n(0, 2) and (2, 0): (1, 1) is on the line segment between them\n\nTherefore, there are a total of (9 choose 2) - 8 = 28 possible locations. \n\nPROBLEM NAME: banner\n\nINPUT FORMAT:\n\n* Line 1: Five space-separated integers: M, N, L, H and B.\n\nOUTPUT FORMAT:\n\n* Line 1: One integer denoting the number of possible banners (modulo B).",
    "description_raw": "Problem 1: Large Banner [Nathan Pinsker, 2010]\n\nBessie is returning from a long trip abroad to the Isle of Guernsey, and\nFarmer John wants to mount a nice \"Welcome Home\" banner for her arrival. \nFarmer John's field has integer dimensions M x N (1 <= M, N <= 100,000),\nand he has installed a post at every possible point in the field with\ninteger coordinates (if we assign a coordinate system to the field so that\n(0,0) is in the lower-left corner and (M,N) is in the upper-right corner).\nOf these (M+1) * (N+1) points, Farmer John must pick two as the endpoints\nof the banner.\n \nFarmer John, being the perfectionist that he is, insists that the banner\nmust be completely straight.  This means that, for the two posts he\nchooses, there cannot be any other post on the line segment that the banner\nwill form between them.  Additionally, Farmer John wants the banner to have\nlength at least L and at most H (1 <= L <= H <= 150,000).  Farmer John\nneeds your help to figure out how many possible ways he can hang the\nbanner. The banner is reversible, so switching the two endpoints of the\nbanner counts as the same way to hang the banner. As this number may be\nvery large, Farmer John simply wants to know what it is modulo B (1 <= B <=\n1,000,000,000). \n\nConsider the example below, with M = 2 and N = 2:\n\n* * *\n* * *\n* * *\n\nFarmer John wants the length of the banner to be between 1 and 3 inclusive.\nAny choice of posts satisfies this length requirement, but note that eight\npairs cannot be picked:\n\n(0, 0) and (2, 0): (1, 0) is on the line segment between them\n(0, 1) and (2, 1): (1, 1) is on the line segment between them\n(0, 2) and (2, 2): (1, 2) is on the line segment between them\n(0, 0) and (2, 2): (1, 1) is on the line segment between them\n(0, 0) and (0, 2): (0, 1) is on the line segment between them\n(1, 0) and (1, 2): (1, 1) is on the line segment between them\n(2, 0) and (2, 2): (2, 1) is on the line segment between them\n(0, 2) and (2, 0): (1, 1) is on the line segment between them\n\nTherefore, there are a total of (9 choose 2) - 8 = 28 possible locations. \n\nPROBLEM NAME: banner",
    "input_format": "* Line 1: Five space-separated integers: M, N, L, H and B.",
    "output_format": "* Line 1: One integer denoting the number of possible banners (modulo B).",
    "num_samples": 1
  },
  "694_gold_hoof,_paper,_scissors": {
    "name": "USACO 2017 January Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=694",
    "test_data_link": "http://www.usaco.org/current/data/hps_gold_jan17.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_hps_gold_jan17.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan17results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "694",
    "problem_id": "694_gold_hoof,_paper,_scissors",
    "description": "You have probably heard of the game \"Rock, Paper, Scissors\".  The cows like to\nplay a similar game they call \"Hoof, Paper, Scissors\".\nThe rules of \"Hoof, Paper, Scissors\" are simple.  Two cows play against\neach-other.  They both count to three and then each simultaneously makes a\ngesture that represents either a hoof, a piece of paper, or a pair of scissors. \nHoof beats scissors (since a hoof can smash a pair of scissors), scissors beats\npaper (since scissors can cut paper), and paper beats hoof (since the hoof can\nget a papercut).   For example, if the first cow makes a \"hoof\" gesture and the\nsecond a \"paper\" gesture, then the second cow wins.  Of course, it is also\npossible to tie, if both cows make the same gesture.\nFarmer John wants to play against his prize cow, Bessie, at $N$ games of  \"Hoof,\nPaper, Scissors\" ($1 \\leq N \\leq 100,000$).  Bessie, being an expert at the\ngame, can predict each of FJ's gestures before he makes it.  Unfortunately,\nBessie, being a cow, is also very lazy.  As a result, she tends to play the same\ngesture multiple times in a row.  In fact, she is only willing to switch\ngestures at most $K$ times over the entire set of games ($0 \\leq K \\leq 20$).  \nFor example, if $K=2$, she might play\n\"hoof\" for the first few games, then switch to \"paper\" for a while, then\nfinish the remaining games playing \"hoof\".\nGiven the sequence of gestures FJ will be playing, please determine the  maximum\nnumber of games that Bessie can win.\nINPUT FORMAT (file hps.in):\nThe first line of the input file contains $N$ and $K$.\nThe remaining $N$ lines contains FJ's gestures, each either H, P, or S.\nOUTPUT FORMAT (file hps.out):\nPrint the maximum number of games Bessie can win, given that she can only change\ngestures at most $K$ times.\nSAMPLE INPUT:\n5 1\nP\nP\nH\nP\nS\nSAMPLE OUTPUT:\n4\nProblem credits: Mark Chen and Brian Dean"
  },
  "1497_gold_bessie's_function": {
    "name": "USACO 2025 February Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1497",
    "test_data_link": "http://www.usaco.org/current/data/prob1_gold_feb25.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_gold_feb25.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb25results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "1497",
    "problem_id": "1497_gold_bessie's_function",
    "description": "Bessie has a special function $f(x)$ that takes as input an integer in $[1, N]$\nand  returns an integer in $[1, N]$ ($1 \\le N \\le 2 \\cdot 10^5$). Her function\n$f(x)$ is defined by  $N$ integers $a_1 \\ldots a_N$ where $f(x) = a_x$\n($1 \\le a_i \\le N$).\nBessie wants this function to be idempotent. In other words, it should satisfy\n$f(f(x)) = f(x)$  for all integers $x \\in [1, N]$.\nFor a cost of $c_i$, Bessie can change the value of $a_i$ to any integer in\n$[1, N]$ ($1 \\le c_i \\le 10^9$). Determine the minimum total cost Bessie needs \nto make $f(x)$ idempotent.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\nThe second line contains $N$ space-separated integers $a_1,a_2,\\dots,a_N$.\nThe third line contains $N$ space-separated integers $c_1,c_2,\\dots,c_N$.\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the minimum total cost Bessie needs to make $f(x)$ idempotent.\nSAMPLE INPUT:\n5\n2 4 4 5 3\n1 1 1 1 1\nSAMPLE OUTPUT:\n3\nWe can change $a_1 = 4$, $a_4 = 4$, $a_5 = 4$. Since all $c_i$ equal one, the\ntotal cost is equal to $3$, the number of changes. It can be shown that there is\nno solution with only $2$ or fewer changes.\nSAMPLE INPUT:\n8\n1 2 5 5 3 3 4 4\n9 9 2 5 9 9 9 9\nSAMPLE OUTPUT:\n7\nWe change $a_3 = 3$ and $a_4 = 4$. The total cost is $2+5=7$.\nSCORING:\nSubtasks:\nInput 3: $N\\le 20$\nInputs 4-9: $a_i\\ge i$\nInputs 10-15: All $a_i$ are distinct.\nInputs 16-21: No additional constraints.\nAdditionally, in each of the last three subtasks, the first half of tests  will\nsatisfy $c_i=1$ for all $i$.\nProblem credits: Avnith Vijayram"
  },
  "1402_gold_milk_exchange": {
    "name": "USACO 2024 February Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1402",
    "test_data_link": "http://www.usaco.org/current/data/prob2_gold_feb24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_gold_feb24.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb24results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "1402",
    "problem_id": "1402_gold_milk_exchange",
    "description": "Farmer John's $N$ $(1 \\leq N \\leq 5 \\cdot 10^5)$ cows are lined up in a circle.\nThe $i$th cow has a bucket with integer capacity $a_i$ $(1 \\leq a_i \\leq 10^9)$\nliters. All buckets are initially full.\nEvery minute, cow $i$ will pass all the milk in their bucket to cow $i+1$ for\n$1\\le i<N$, with cow $N$ passing its milk to cow $1$. All exchanges happen\nsimultaneously (i.e., if a cow has a full bucket but gives away $x$ liters of\nmilk and also receives $x$ liters, her milk is preserved). If a cow's total milk\never ends up exceeding $a_i$, then the excess milk will be lost.\nAfter each of $1, 2, \\dots, N$ minutes, how much total milk is left among all\ncows?\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\nThe next line contains integers $a_1,a_2,...,a_N$.\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $N$ lines, where the $i$-th line is the total milk left among all cows\nafter $i$ minutes.\nSAMPLE INPUT:\n6\n2 2 2 1 2 1\nSAMPLE OUTPUT:\n8\n7\n6\n6\n6\n6\nInitially, the amount of milk in each bucket is $[2, 2, 2, 1, 2, 1]$.\nAfter $1$ minute, the amount of milk in each bucket is $[1, 2, 2, 1, 1, 1]$\nso the total amount of milk is $8$.\nAfter $2$ minutes, the amount of\nmilk in each bucket is $[1, 1, 2, 1, 1, 1]$ so the total amount of milk is\n$7$.\nAfter $3$ minutes, the amount of milk in each bucket is\n$[1, 1, 1, 1, 1, 1]$ so the total amount of milk is $6$.\nAfter $4$\nminutes, the amount of milk in each bucket is  $[1, 1, 1, 1, 1, 1]$ so the total\namount of milk is $6$.\nAfter $5$ minutes, the amount of milk in each\nbucket is $[1, 1, 1, 1, 1, 1]$ so the total amount of milk is $6$.\nAfter $6$ minutes, the amount of milk in each bucket is $[1, 1, 1, 1, 1, 1]$\nso the total amount of milk is\n$6$.\nSAMPLE INPUT:\n8\n3 8 6 4 8 3 8 1\nSAMPLE OUTPUT:\n25\n20\n17\n14\n12\n10\n8\n8\nAfter $1$ minute, the amount of milk in each bucket is\n$[1, 3, 6, 4, 4, 3, 3, 1]$ so the total amount of milk is $25$.\nSAMPLE INPUT:\n10\n9 9 10 10 6 8 2 1000000000 1000000000 1000000000\nSAMPLE OUTPUT:\n2000000053\n1000000054\n56\n49\n42\n35\n28\n24\n20\n20\nSCORING:\nInputs 4-5: $N \\le 2000$\nInputs 6-8: $a_i \\le 2$\nInputs\n9-13: All $a_i$ are generated uniformly at random in the range $[1,10^9]$.\nInputs 14-23: No additional constraints.\nProblem credits: Chongtian Ma, Alex Liang, Patrick Deng"
  },
  "1378_gold_cowmpetency": {
    "name": "USACO 2024 January Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1378",
    "test_data_link": "http://www.usaco.org/current/data/prob2_gold_jan24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_gold_jan24.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan24results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "1378",
    "problem_id": "1378_gold_cowmpetency",
    "description": "Farmer John is hiring a new herd leader for his cows. To that end, he has\ninterviewed $N$ ($2 \\leq N \\leq 10^9$) cows for the position. After each\ninterview, he assigned an integer \"cowmpetency\" score to the candidate ranging from $1$\nto $C$ ($1 \\leq C \\leq 10^4$) that is correlated with their leadership\nabilities.\nBecause he has interviewed so many cows, Farmer John has forgotten all of their\ncowmpetency scores. However, he does remembers $Q$\n($1 \\leq Q \\leq \\min(N - 1, 100)$) pairs of numbers $(a_i, h_i)$ where cow $h_i$\nwas the first cow with a\nstrictly greater\ncowmpetency score than cows $1$\nthrough $a_i$ (so\n$1 \\leq a_i < h_i \\leq N$).\nFarmer John now tells you the $Q$ pairs of $(a_i, h_i)$. Help him count how many\nsequences of cowmpetency scores are consistent with this information! It is\nguaranteed that there is at least one such sequence. Because this number may be\nvery large, output its value modulo $10^9 + 7$.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, $Q$, and $C$.\nThe next $Q$ lines each contain a pair $(a_i, h_i)$. It is guaranteed that all\n$a_j$ are distinct.\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe number of sequences of cowmpetency scores consistent with what Farmer John\nremembers, modulo $10^9+7$.\nSAMPLE INPUT:\n6 2 3\n2 3\n4 5\nSAMPLE OUTPUT:\n6\nThe following six sequences are the only ones consistent with what Farmer John\nremembers:\n1 1 2 1 3 1\n1 1 2 1 3 2\n1 1 2 1 3 3\n1 1 2 2 3 1\n1 1 2 2 3 2\n1 1 2 2 3 3\nSAMPLE INPUT:\n10 1 20\n1 3\nSAMPLE OUTPUT:\n399988086\nMake sure to output the answer modulo $10^9+7$.\nSCORING:\nInputs 3-4 satisfy $N \\leq 10$ and $Q, C \\leq 4$.\nInputs 5-7\nsatisfy $N, C \\leq 100$.\nInputs 8-10 satisfy $N \\leq 2000$ and\n$C \\leq 200$.\nInputs 11-15 satisfy $N, C \\leq 2000$.\nInputs\n16-20 satisfy no additional constraints.\nProblem credits: Suhas Nagar"
  },
  "1065_gold_replication": {
    "name": "Replication",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1065",
    "test_data_link": "http://www.usaco.org/current/data/prob1_gold_dec20.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_gold_dec20.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec20results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "gold",
    "cp_id": "1065",
    "problem_id": "1065_gold_replication",
    "description": "The ill-fated result of watching too many \"do it yourself\" engineering videos on\nthe web, Farmer John has accidentally released a self-replicating robot on his\nfarm! \n\nThe farm can be represented by an $N\\times N$ grid ($3\\le N\\le 1000$) where \neach grid cell is either empty or filled with rock, and all border squares are \nfilled with rock.  Some non-rock cells are designated as possible starting \nlocations for the robot.\n\nFarmer John initially places the robot at one of the possible starting\npositions. In every hour that follows, all copies of the robot move in one\ncoordinated mass in the same direction, either north, south, east, or west. \nAfter every $D$ hours ($1 \\leq D \\leq 10^9$), every copy of the robot replicates\n--- a robot at cell $(x,y)$ that replicates creates new copies in cells\n$(x+1,y)$, $(x-1,y)$, $(x,y+1)$, and $(x,y-1)$; the original robot remains at\n$(x,y)$.  Over time, multiple robots might come to  occupy the same cell.\n\nIf moving or replicating would cause any of the robots to move into a rock, then\nall robots shut down immediately.  Note that this implies that the robots must\neventually shut down, due to the border of the farm being rock.\n\nHelp the cows figure out the number of empty squares that could potentially at\nsome point in time hold a robot.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two space-separated integers $N$ and $D$. The next $N$ lines of input each contain $N$ characters. Each character is one\nof '.', 'S', or '#'. '.' and 'S' both represent empty cells, with 'S' denoting\na possible starting position for the robot. '#' denotes a rock.\n\nAll characters in the first and last row and first and last column are '#'.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nAn integer counting the number of cells that could at some point in time hold a\nrobot.\n\nSAMPLE INPUT:\n10 1\n##########\n#........#\n#S.......#\n#........#\n##########\n#S....S..#\n##########\n##########\n##########\n##########\nSAMPLE OUTPUT: \n15\n\nIn the following diagrams, x's denote robots.\n\nLocations that could be occupied by robots:\n\n\n##########\n#xxx.....#\n#xxxx....#\n#xxx.....#\n##########\n#xx..xxx.#\n##########\n##########\n##########\n##########\n\nOne possible sequence of events could be as follows:\n\nFJ places the robot at the upper-left-most starting position.The robot moves one unit to the right.The robot replicates.All robots move one unit to the right.Another replication would cause a copy of the robot to move into a rock, so\nthe process terminates.\n\n##########    ##########    ##########    ##########\n#........#    #........#    #.x......#    #..x.....#\n#x.......#    #.x......#    #xxx.....#    #.xxx....#\n#........#    #........#    #.x......#    #..x.....#\n########## -> ########## -> ########## -> ##########\n#........#    #........#    #........#    #........#\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########\n\nSAMPLE INPUT:\n10 2\n##########\n#.#......#\n#.#......#\n#S.......#\n#.#......#\n#.#......#\n##########\n##########\n##########\n##########\nSAMPLE OUTPUT: \n28\n\nLocations that could be occupied by robots:\n\n\n##########\n#x#.xxx..#\n#x#xxxxx.#\n#xxxxxxxx#\n#x#xxxxx.#\n#x#.xxx..#\n##########\n##########\n##########\n##########\n\nSAMPLE INPUT:\n10 2\n##########\n#.S#.....#\n#..#.....#\n#S.......#\n#..#.....#\n#..#.....#\n##########\n##########\n##########\n##########\nSAMPLE OUTPUT: \n10\n\nLocations that could be occupied by robots:\n\n\n##########\n#xx#.....#\n#xx#.....#\n#xxx.....#\n#xx#.....#\n#x.#.....#\n##########\n##########\n##########\n##########\n\nSCORING:\nTest cases 4-5 satisfy $D=10^9$.Test cases 6-8 satisfy $D=1$.Test cases 9-12 satisfy $N\\le 100$.Test cases 13-20 satisfy no additional constraints.\n\n\nProblem credits: Benjamin Qi\n",
    "num_tests": 20,
    "solution": "\n(Analysis by Spencer Compton)\nFirst, we make an observation about what our swarm of robots will look like as\nthey replicate. As the robots replicate, they would take the following shape:\n\n.....    .....    ..X..\n.....    ..X..    .XXX.\n..X.. -> .XXX. -> XXXXX\n.....    ..X..    .XXX.\n.....    .....    ..X..\n\nMore intuitively, we can view the shape of our swarm as some cell with a center\nrobot, and after $i$ replications all cells within distance $i$ of the center\nwill have robots in the swarm.\nIf a cell can have a robot, then we know there is either a way to have a center\nrobot at that cell, or there is a way to have a center robot with $i$\nreplications within distance $i$ of the cell. \nThis motivates us to figure out which cells can have a center robot, and the\nmaximum number of replications it can have. To accomplish this, we intend to\nmake a modified BFS from the source cells to figure out which cells can have a\ncenter robot. In order to accomplish this, however, we will need to know if at\nsome time, the swarm is too big to go to a certain cell (and thus moving there\nwould cause robots to go into rocks). \nTo help with this, we will calculate the distance from every cell to its nearest\nrock cell. We can do this with a BFS where all the rocks are sources. We call\nthe distance from each cell to a rock $rock\\_dist[r][c]$. Now, we use a modified\nBFS to determine which cells could contain a center robot.  As we expand our\nBFS, we only move to a cell if it would not cause any robots to crash into\nrocks.  If we are moving from a cell $r_1,c_1$ to a cell $r_2,c_2$ for hour $t$\n(0-indexed), then this  condition is met if\n$t-1 < D \\times rock\\_dist[r_1][c_1]$ and \n$t \\le D \\times rock\\_dist[r_2][c_2]$.\nArmed with what cells can be center robots, we observe that we can stay at said\ncell until the swarm has replicated a total of $rock\\_dist[r][c]-1$ times.\nThus, our final condition for whether a cell $r,c$ can ever have a robot is if\nthere is some cell $r',c'$ where a center robot can be at $r',c'$ and\n$|r-r'|+|c-c'| \\le rock\\_dist[r'][c']-1$. To calculate this, we again utilize a\nmodified BFS. One such way of accomplishing this is having a set $centers[i]$\nthat contains all cells $r,c$ that can have a center robot and\n$rock\\_dist[r][c]=i$. We can do our BFS in stages from $n/2$ (because this is\nthe maximum possible $rock\\_dist$) to $0$, and at the end of each stage $i$ add\nall cells in $centers[i]$ as sources. A cell will then be reached by our\nmodified BFS exactly if it satisfies our condition, meaning we can determine the\ncells that can have robots.\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dr[4] = {-1,1,0,0};\nint dc[4] = {0,0,-1,1};\n\nint main(){\n\tint n;\n\tll d;\n\tcin >> n >> d;\n\tbool empty[n][n];\n\tvector<pair<int, int> > starts;\n\tvector<pair<int, int> > rocks;\n\tint dist_rock[n][n];\n\tint dist_source[n][n];\n\tbool ans[n][n];\n\tfor(int i = 0; i<n; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j<n; j++){\n\t\t\tif(s[j]=='#'){\n\t\t\t\tempty[i][j] = false;\n\t\t\t\trocks.push_back(make_pair(i,j));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tempty[i][j] = true;\n\t\t\t}\n\t\t\tif(s[j]=='S'){\n\t\t\t\tstarts.push_back(make_pair(i,j));\n\t\t\t}\n\t\t\tdist_rock[i][j] = -1;\n\t\t\tdist_source[i][j] = -1;\n\t\t\tans[i][j] = false;\n\t\t}\n\t}\n\t// First, we calculate distance of everything to a rock\n\tvector<pair<int, int> > bfs_list;\n\tfor(int i = 0; i<rocks.size(); i++){\n\t\tbfs_list.push_back(rocks[i]);\n\t\tdist_rock[rocks[i].first][rocks[i].second] = 0;\n\t}\n\tfor(int i = 0; i<bfs_list.size(); i++){\n\t\tpair<int, int> now = bfs_list[i];\n\t\tfor(int j = 0; j<4; j++){\n\t\t\tpair<int, int> to = make_pair(now.first+dr[j],now.second+dc[j]);\n\t\t\tif(!(to.first>=0 && to.first<n && to.second>=0 && to.second<n)){\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif(dist_rock[to.first][to.second]!=-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to_dist = dist_rock[now.first][now.second] + 1;\n\t\t\tdist_rock[to.first][to.second] = to_dist;\n\t\t\tbfs_list.push_back(to);\n\t\t}\n\t}\n\t// Then, we do a BFS from the sources\n\tbfs_list.clear();\n\tfor(int i = 0; i<starts.size(); i++){\n\t\tbfs_list.push_back(starts[i]);\n\t\tdist_source[starts[i].first][starts[i].second] = 0;\n\t}\n\t// centers[i] will store all empty cells i that our center \n\t// can reach, and who are distance i+1 from a rock\n\t// (meaning they can replicate i times)\n\tvector<pair<int, int> > centers[n*n];\n\tfor(int i = 0; i<bfs_list.size(); i++){\n\t\tpair<int, int> now = bfs_list[i];\n\t\tans[now.first][now.second] = true;\n\t\tint now_dist = dist_source[now.first][now.second];\n\t\tcenters[dist_rock[now.first][now.second]-1].push_back(now);\n\t\t// Do not continue if replicating would force robots to rocks\n\t\tif(now_dist>=d*dist_rock[now.first][now.second]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0; j<4; j++){\n\t\t\tpair<int, int> to = make_pair(now.first+dr[j],now.second+dc[j]);\n\n\t\t\tif(!(to.first>=0 && to.first<n && to.second>=0 && to.second<n)){\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif(dist_source[to.first][to.second]!=-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!empty[to.first][to.second]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to_dist = now_dist + 1;\n\t\t\t// Do not move if it would force robots to rocks\n\t\t\tif(to_dist > d*dist_rock[to.first][to.second]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist_source[to.first][to.second] = to_dist;\n\t\t\tbfs_list.push_back(to);\n\t\t}\n\t}\n\t// Do a modified BFS such that we reach every cell where\n\t// there is some other cell in centers[z] and the distance\n\t// between the two is <=z\n\tvector<pair<int, int> > next_stage;\n\tfor(int i = n*n-1; i>=0; i--){\n\t\tswap(bfs_list,next_stage);\n\t\tnext_stage.clear();\n\t\tfor(int j = 0; j<bfs_list.size(); j++){\n\t\t\tpair<int, int> now = bfs_list[j];\n\t\t\tfor(int k = 0; k<4; k++){\n\t\t\t\tpair<int, int> to = make_pair(now.first+dr[k],now.second+dc[k]);\n\n\t\t\t\tif(!(to.first>=0 && to.first<n && to.second>=0 && to.second<n)){\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t\tif(ans[to.first][to.second]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!empty[to.first][to.second]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans[to.first][to.second] = true;\n\t\t\t\tnext_stage.push_back(to);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j<centers[i].size(); j++){\n\t\t\tnext_stage.push_back(centers[i][j]);\n\t\t}\n\t}\n\tint tot = 0;\n\tfor(int i = 0; i<n; i++){\n\t\tfor(int j = 0; j<n; j++){\n\t\t\tif(ans[i][j]){\n\t\t\t\ttot++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << tot << endl;\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "10 1\n##########\n#........#\n#S.......#\n#........#\n##########\n#S....S..#\n##########\n##########\n##########\n##########",
        "output": "15",
        "explanation": "In the following diagrams, x's denote robots.\n\nLocations that could be occupied by robots:\n\n\n##########\n#xxx.....#\n#xxxx....#\n#xxx.....#\n##########\n#xx..xxx.#\n##########\n##########\n##########\n##########\n\nOne possible sequence of events could be as follows:\n\nFJ places the robot at the upper-left-most starting position.The robot moves one unit to the right.The robot replicates.All robots move one unit to the right.Another replication would cause a copy of the robot to move into a rock, so\nthe process terminates.\n\n##########    ##########    ##########    ##########\n#........#    #........#    #.x......#    #..x.....#\n#x.......#    #.x......#    #xxx.....#    #.xxx....#\n#........#    #........#    #.x......#    #..x.....#\n########## -> ########## -> ########## -> ##########\n#........#    #........#    #........#    #........#\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########"
      },
      {
        "input": "10 2\n##########\n#.#......#\n#.#......#\n#S.......#\n#.#......#\n#.#......#\n##########\n##########\n##########\n##########",
        "output": "28",
        "explanation": "Locations that could be occupied by robots:\n\n\n##########\n#x#.xxx..#\n#x#xxxxx.#\n#xxxxxxxx#\n#x#xxxxx.#\n#x#.xxx..#\n##########\n##########\n##########\n##########"
      },
      {
        "input": "10 2\n##########\n#.S#.....#\n#..#.....#\n#S.......#\n#..#.....#\n#..#.....#\n##########\n##########\n##########\n##########",
        "output": "10",
        "explanation": "Locations that could be occupied by robots:\n\n\n##########\n#xx#.....#\n#xx#.....#\n#xxx.....#\n#xx#.....#\n#x.#.....#\n##########\n##########\n##########\n##########"
      }
    ],
    "description_no_samples": "The ill-fated result of watching too many \"do it yourself\" engineering videos on\nthe web, Farmer John has accidentally released a self-replicating robot on his\nfarm! \n\nThe farm can be represented by an $N\\times N$ grid ($3\\le N\\le 1000$) where \neach grid cell is either empty or filled with rock, and all border squares are \nfilled with rock.  Some non-rock cells are designated as possible starting \nlocations for the robot.\n\nFarmer John initially places the robot at one of the possible starting\npositions. In every hour that follows, all copies of the robot move in one\ncoordinated mass in the same direction, either north, south, east, or west. \nAfter every $D$ hours ($1 \\leq D \\leq 10^9$), every copy of the robot replicates\n--- a robot at cell $(x,y)$ that replicates creates new copies in cells\n$(x+1,y)$, $(x-1,y)$, $(x,y+1)$, and $(x,y-1)$; the original robot remains at\n$(x,y)$.  Over time, multiple robots might come to  occupy the same cell.\n\nIf moving or replicating would cause any of the robots to move into a rock, then\nall robots shut down immediately.  Note that this implies that the robots must\neventually shut down, due to the border of the farm being rock.\n\nHelp the cows figure out the number of empty squares that could potentially at\nsome point in time hold a robot.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two space-separated integers $N$ and $D$. The next $N$ lines of input each contain $N$ characters. Each character is one\nof '.', 'S', or '#'. '.' and 'S' both represent empty cells, with 'S' denoting\na possible starting position for the robot. '#' denotes a rock.\n\nAll characters in the first and last row and first and last column are '#'.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nAn integer counting the number of cells that could at some point in time hold a\nrobot.\n\n",
    "num_samples": 3
  },
  "120_gold_nearby_cows": {
    "name": "Nearby Cows",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=120",
    "test_data_link": "http://www.usaco.org/current/data/nearcows.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_nearcows.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb12results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=feb12problems",
    "problem_level": "gold",
    "cp_id": "120",
    "problem_id": "120_gold_nearby_cows",
    "description": "Problem 3: Nearby Cows [Neal Wu and Eric Price, 2011]\n\nFarmer John has noticed that his cows often move between nearby fields. \nTaking this into account, he wants to plant enough grass in each of his\nfields not only for the cows situated initially in that field, but also for\ncows visiting from nearby fields.\n\nSpecifically, FJ's farm consists of N fields (1 <= N <= 100,000), where\nsome pairs of fields are connected with bi-directional trails (N-1 of them\nin total).  FJ has designed the farm so that between any two fields i and\nj, there is a unique path made up of trails connecting between i and j. \nField i is home to C(i) cows, although cows sometimes move to a different\nfield by crossing up to K trails (1 <= K <= 20).  \n\nFJ wants to plant enough grass in each field i to feed the maximum number\nof cows, M(i), that could possibly end up in that field -- that is, the\nnumber of cows that can potentially reach field i by following at most K\ntrails.  Given the structure of FJ's farm and the value of C(i) for each\nfield i, please help FJ compute M(i) for every field i.\n\nPROBLEM NAME: nearcows\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers, N and K.\n\n* Lines 2..N: Each line contains two space-separated integers, i and j\n        (1 <= i,j <= N) indicating that fields i and j are directly\n        connected by a trail.\n\n* Lines N+1..2N: Line N+i contains the integer C(i). (0 <= C(i) <=\n        1000)\n\nSAMPLE INPUT:\n\n6 2\n5 1\n3 6\n2 4\n2 1\n3 2\n1\n2\n3\n4\n5\n6\n\nINPUT DETAILS:\n\nThere are 6 fields, with trails connecting (5,1), (3,6), (2,4), (2,1), and\n(3,2).  Field i has C(i) = i cows.  \n\nOUTPUT FORMAT:\n\n* Lines 1..N: Line i should contain the value of M(i).\n\nSAMPLE OUTPUT:\n\n15\n21\n16\n10\n8\n11\n\nOUTPUT DETAILS:\n\nField 1 has M(1) = 15 cows within a distance of 2 trails, etc.\n",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes: This problem can be solved fairly easily by\ndynamic programming in O(NK) time.  Let A(x,r) denote the number of\ncows within a radius of r of node x.  As a base case, A(x,0) = C(x).\nWe then compute A(x,1) for all nodes x, then A(x,2) for all nodes x,\nup to A(x,k) for all nodes x.  To compute A(x,r), we sum up A(y,r-1)\nover all neighbors y of x, and then subtract out A(x,r-2) times the\ndegree of x (the number of neighbors of x) to correct for\ndouble-counting.  The total running time for each fixed value of r is\njust O(N), since the sum of the degrees of all the nodes in a graph is\ntwice the number of edges, which for a tree is O(N). \n\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\n#define MAXN 100000\nvector<int> E[MAXN];\nint F[4][MAXN];\n\nint main() {\n  freopen(\"nearcows.in\", \"r\", stdin);\n  freopen(\"nearcows.out\", \"w\", stdout);\n  int N, K; scanf(\"%d%d\", &N, &K);\n  assert(1 <= N && N <= 100000 && 1 <= K && K <= 20);\n  for(int i = 1; i < N; i++) {\n    int u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n    assert(0 <= u && u < N && 0 <= v && v < N);\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", F[0] + i);\n    assert(0 <= F[0][i] && F[0][i] <= 1000);\n    F[1][i] += F[0][i];\n    for(int j = 0; j < E[i].size(); j++) {\n      F[1][E[i][j]] += F[0][i];\n    }\n  }\n  for(int i = 2; i <= K; i++) {\n    for(int j = 0; j < N; j++) {\n      F[i & 3][j] = -(E[j].size() - 1) * F[i - 2 & 3][j];\n      for(int k = 0; k < E[j].size(); k++) {\n        F[i & 3][j] += F[i - 1 & 3][E[j][k]];\n      }\n    }\n  }\n  for(int i = 0; i < N; i++) printf(\"%d\\n\", F[K & 3][i]);\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "6 2\n5 1\n3 6\n2 4\n2 1\n3 2\n1\n2\n3\n4\n5\n6",
        "output": "15\n21\n16\n10\n8\n11",
        "input_explanation": "There are 6 fields, with trails connecting (5,1), (3,6), (2,4), (2,1), and\n(3,2).  Field i has C(i) = i cows.",
        "output_explanation": "Field 1 has M(1) = 15 cows within a distance of 2 trails, etc.",
        "explanation": "There are 6 fields, with trails connecting (5,1), (3,6), (2,4), (2,1), and\n(3,2).  Field i has C(i) = i cows.\nField 1 has M(1) = 15 cows within a distance of 2 trails, etc."
      }
    ],
    "description_no_samples": "Problem 3: Nearby Cows [Neal Wu and Eric Price, 2011]\n\nFarmer John has noticed that his cows often move between nearby fields. \nTaking this into account, he wants to plant enough grass in each of his\nfields not only for the cows situated initially in that field, but also for\ncows visiting from nearby fields.\n\nSpecifically, FJ's farm consists of N fields (1 <= N <= 100,000), where\nsome pairs of fields are connected with bi-directional trails (N-1 of them\nin total).  FJ has designed the farm so that between any two fields i and\nj, there is a unique path made up of trails connecting between i and j. \nField i is home to C(i) cows, although cows sometimes move to a different\nfield by crossing up to K trails (1 <= K <= 20).  \n\nFJ wants to plant enough grass in each field i to feed the maximum number\nof cows, M(i), that could possibly end up in that field -- that is, the\nnumber of cows that can potentially reach field i by following at most K\ntrails.  Given the structure of FJ's farm and the value of C(i) for each\nfield i, please help FJ compute M(i) for every field i.\n\nPROBLEM NAME: nearcows\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers, N and K.\n\n* Lines 2..N: Each line contains two space-separated integers, i and j\n        (1 <= i,j <= N) indicating that fields i and j are directly\n        connected by a trail.\n\n* Lines N+1..2N: Line N+i contains the integer C(i). (0 <= C(i) <=\n        1000)\n\nOUTPUT FORMAT:\n\n* Lines 1..N: Line i should contain the value of M(i).",
    "description_raw": "Problem 3: Nearby Cows [Neal Wu and Eric Price, 2011]\n\nFarmer John has noticed that his cows often move between nearby fields. \nTaking this into account, he wants to plant enough grass in each of his\nfields not only for the cows situated initially in that field, but also for\ncows visiting from nearby fields.\n\nSpecifically, FJ's farm consists of N fields (1 <= N <= 100,000), where\nsome pairs of fields are connected with bi-directional trails (N-1 of them\nin total).  FJ has designed the farm so that between any two fields i and\nj, there is a unique path made up of trails connecting between i and j. \nField i is home to C(i) cows, although cows sometimes move to a different\nfield by crossing up to K trails (1 <= K <= 20).  \n\nFJ wants to plant enough grass in each field i to feed the maximum number\nof cows, M(i), that could possibly end up in that field -- that is, the\nnumber of cows that can potentially reach field i by following at most K\ntrails.  Given the structure of FJ's farm and the value of C(i) for each\nfield i, please help FJ compute M(i) for every field i.\n\nPROBLEM NAME: nearcows",
    "input_format": "* Line 1: Two space-separated integers, N and K.\n\n* Lines 2..N: Each line contains two space-separated integers, i and j\n        (1 <= i,j <= N) indicating that fields i and j are directly\n        connected by a trail.\n\n* Lines N+1..2N: Line N+i contains the integer C(i). (0 <= C(i) <=\n        1000)",
    "output_format": "* Lines 1..N: Line i should contain the value of M(i).",
    "num_samples": 1
  },
  "1475_gold_photo_op": {
    "name": "USACO 2025 January Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1475",
    "test_data_link": "http://www.usaco.org/current/data/prob3_gold_jan25.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob3_gold_jan25.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan25results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "1475",
    "problem_id": "1475_gold_photo_op",
    "description": "Farmer John's farm is full of lush vegetation and every cow wants a photo of its\nnatural beauty. Unfortunately, Bessie still has places to be, but she doesn't\nwant to disrupt any  photo ops.\nBessie is currently standing at $(X,0)$ on the XY-plane and she wants to get to\n$(0,Y)$ ($1\\le X,Y\\le 10^6$). Unfortunately, $N$ ($1 \\leq N \\leq 3 \\cdot 10^5$)\nother cows have decided to pose on the $X$ axis. More specifically, cow $i$ will\nbe positioned at $(x_i,0)$ with a photographer at $(0,y_i)$ where\n$(1 \\leq x_i,y_i \\leq 10^6)$ ready to take their picture. They will begin posing\nmoments before time $s_i$ ($1 \\leq s_i < T$) and they will keep posing for a\nvery long time (they have to get their picture just right). Here,\n$1\\le T\\le N+1$.\nBessie knows the schedule for every cow's photo op, and she will take the\nshortest Euclidean distance to get to her destination, without crossing the line\nof sight from any photographer to their respective cow (her path will consist of\none or more line segments).\nIf Bessie leaves at time $t$, she will avoid the line of sights for all \nphotographer/cow pairs that started posing at time $s_i \\le t$, and let  the\ndistance to her final destination be $d_t$. Determine the values of \n$\\lfloor d_t\\rfloor$ for each integer $t$ from $0$ to $T-1$ inclusive.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of input contains $N$ and $T$, representing the number of cows\nposing on the $x$-axis and the timeframe that Bessie could leave at.\nThe second line of input contains $X$ and $Y$, representing Bessie's starting $X$\ncoordinate and her target $Y$ coordinate respectively.\nThe next $N$ lines contain $s_i$ $x_i$ and $y_i$. It is guaranteed that all\n$x_i$ are distinct from each other and $X$, and all $y_i$ are distinct from each\nother and $Y$. All $s_i$ will be given in increasing order, where\n$s_i \\leq s_{i+1}$.\nOUTPUT FORMAT (print output to the terminal / stdout):\nPrint $T$ lines, with the $t$th (0-indexed) line containing\n$\\lfloor d_t\\rfloor$.\nSAMPLE INPUT:\n4 5\n6 7\n1 7 5\n2 4 4\n3 1 6\n4 2 9\nSAMPLE OUTPUT:\n9\n9\n9\n10\n12\nSAMPLE INPUT:\n2 3\n10 7\n1 2 10\n1 9 1\nSAMPLE OUTPUT:\n12\n16\n16\nFor $t=0$ the answer is $\\lfloor \\sqrt{149} \\rfloor=12$.\nFor $t=1$ the answer is $\\lfloor 14+\\sqrt 5\\rfloor=16$.\nSAMPLE INPUT:\n5 6\n8 9\n1 3 5\n1 4 1\n3 10 7\n4 9 2\n5 6 6\nSAMPLE OUTPUT:\n12\n12\n12\n12\n14\n14\nFor $t=5$ the answer is $\\lfloor 1+\\sqrt{9^2+7^2}+2\\rfloor=14$. Path:\n$(8,0)\\to (9,0)\\to (0,7)\\to (0,9)$\nSCORING:\nInputs 4-6: $N\\le 100$\nInputs 7-9: $N\\le 3000$\nInputs 10-12: $T\\le 10$\nInputs 13-18: No additional constraints\nProblem credits: Suhas Nagar"
  },
  "102_gold_grass_planting": {
    "name": "Grass Planting",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=102",
    "test_data_link": "http://www.usaco.org/current/data/grassplant.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_grassplant.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec11results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=dec11problems",
    "problem_level": "gold",
    "cp_id": "102",
    "problem_id": "102_gold_grass_planting",
    "description": "Problem 3: Grass Planting [Travis Hance, 2011]\n\nFarmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 \nbidirectional roads, such that there is exactly one path between any two \npastures.  Bessie, a cow who loves her grazing time, often complains about \nhow there is no grass on the roads between pastures.  Farmer John loves \nBessie very much, and today he is finally going to plant grass on the\nroads.  He will do so using a procedure consisting of M steps (1 <= M <=\n100,000).\n\nAt each step one of two things will happen:\n\n- FJ will choose two pastures, and plant a patch of grass along each road in\nbetween the two pastures, or,\n\n- Bessie will ask about how many patches of grass on a particular road, and \nFarmer John must answer her question.\n\nFarmer John is a very poor counter -- help him answer Bessie's questions!\n\nPROBLEM NAME: grassplant\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers N and M\n\n* Lines 2..N: Two space-separated integers describing the endpoints of\n        a road.\n\n* Lines N+1..N+M: Line i+1 describes step i. The first character of\n        the line is either P or Q, which describes whether or not FJ\n        is planting grass or simply querying. This is followed by two\n        space-separated integers A_i and B_i (1 <= A_i, B_i <= N)\n        which describe FJ's action or query.\n\nSAMPLE INPUT:\n\n4 6\n1 4\n2 4\n3 4\nP 2 3\nP 1 3\nQ 3 4\nP 1 4\nQ 2 4\nQ 1 4\n\nOUTPUT FORMAT:\n\n* Lines 1..???: Each line has the answer to a query, appearing in the\n        same order as the queries appear in the input.\n\nSAMPLE OUTPUT:\n\n2\n1\n2\n\n",
    "num_tests": 13,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes (Albert Gu): There are many ways to do this\nproblem, some of which are faster than others. One solution uses a\ntechnique called heavy-light decomposition.  Root the tree\narbitrarily. Consider an edge between vertices u and v (let u be the\nparent of v). Call this edge heavy if the size of the subtree rooted\nat v is at least half the size of the subtree rooted at u, and light\notherwise. Note that each parent has at most one heavy edge to a\nchild, so the heavy edges form a set of chains. We will keep track of\neach heavy chain separately. \nFinally, any path from a vertex to the root has at most log n light\nedges, because advancing up a light edge at least doubles the size of\nthe subtree. This path also has at most log n heavy chains, since a\nlight edge separates every two heavy chains. This means we can divide\nthis path into log n pieces, so adding grass along a path from a\nvertex to a root will take O(log n) time by adding it to each light\nedge and heavy chain on the path. Note that we will need to augment\neach heavy chain with a structure such as a range tree or BIT (binary\nindexed tree) because we might need to plant grass on only a prefix of\na heavy chain.\nTo update an arbitrary path, we note the following: Planting 1 grass\non each edge along the path from A to B is the same as planting 1\ngrass on each edge from A to the root, 1 grass on each edge from B to\nthe root, and -2 grass on each edge from LCA(A, B) to the root, where\nLCA denotes the least common ancestor.\n (As a note, the memory limits for this problem were extremely\ntight --- probably a bit too tight; conserving memory was one of the\nmain problems faced by most competitors). \n Here is Mark Gordon's code: \n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\n\n/* Heavy Light Implementation */\n#define MAXN 100000\n\nint N; // Number of nodes\n\n/* Node fields. */\nint VC[MAXN];  // Vertex chain index\nint VPOS[MAXN]; // Vertex chain position\n\n/* Chain fields. */\nint CP[MAXN]; // Chain parent (-1 if none)\nint CLN[MAXN]; // Number of vertexes in chain.\n\nvector<int> E[MAXN];\n\npair<int, int> hang(int u, int p) {\n  int nodes = 1;\n  pair<int, int> result(0, -1);\n  for(int i = 0; i < E[u].size(); i++) {\n    int v = E[u][i];\n    if(v == p) continue;\n    pair<int, int> res = hang(v, u);\n    nodes += res.first;\n    result = max(result, res);\n  }\n  E[u].clear();\n\n  if(result.second == -1) result.second = u;\n  E[result.second].push_back(u);\n  CP[result.second] = p;\n  \n  result.first = nodes;\n  return result;\n}\n\n/* Before calling E[i] represents the edges of vertex i.  After calling E[i] is\n * a list (from root to child) of vertexes in chain i. */\nvoid prep_heavylight() {\n  hang(0, -1);\n  for(int i = 0; i < N; i++) {\n    CLN[i] = E[i].size();\n    for(int j = 0; j < E[i].size(); j++) {\n      VC[E[i][j]] = i;\n      VPOS[E[i][j]] = j;\n    }\n  }\n}\n\n/* Represents the nodes in the range [lo, hi) of chain. */\nstruct ChainPart {\n  ChainPart(int chain, int lo, int hi) : chain(chain), lo(lo), hi(hi) {}\n  int chain;\n  int lo; // lo node on the chain.\n  int hi; // hi node on the chain. hi=CLN[chain] means chain connects to parent\n};\n\n/* Returns a list of all the sections of the chains on the path from u to v. */\nvector<ChainPart> chain_path(int u, int v) {\n  vector<pair<int, int> > cu, cv;\n  for(; u != -1; u = CP[VC[u]]) cu.push_back(make_pair(VC[u], VPOS[u]));\n  for(; v != -1; v = CP[VC[v]]) cv.push_back(make_pair(VC[v], VPOS[v]));\n  reverse(cu.begin(), cu.end());\n  reverse(cv.begin(), cv.end());\n  if(cv.size() < cu.size()) cu.swap(cv);\n\n  int i;\n  for(i = 0; i < cu.size() && cu[i] == cv[i]; i++);\n\n  vector<ChainPart> ret;\n  if(i == cu.size()) {\n    ret.push_back(\n        ChainPart(cu.back().first, cu.back().second, cu.back().second));\n  } else if(cu[i].first == cv[i].first) {\n    ret.push_back(ChainPart(cu[i].first,\n                            min(cu[i].second, cv[i].second),\n                            max(cu[i].second, cv[i].second)));\n    ++i;\n  }\n  for(int j = i; j < cu.size(); j++) {\n    ret.push_back(ChainPart(cu[j].first, cu[j].second, CLN[cu[j].first]));\n  }\n  for(int j = i; j < cv.size(); j++) {\n    ret.push_back(ChainPart(cv[j].first, cv[j].second, CLN[cv[j].first]));\n  }\n  return ret;\n}\n\n/* Get rid of empty chain parts. */\nvector<ChainPart> filter(const vector<ChainPart>& ch) {\n  vector<ChainPart> res;\n  for(int i = 0; i < ch.size(); i++) {\n    if(ch[i].lo != ch[i].hi) {\n      res.push_back(ch[i]);\n    }\n  }\n  return res;\n}\n\nvector<int> bit[MAXN];\n\nvoid bit_add(vector<int>& A, int x, int v) {\n  for(int i = x | A.size(); i < (A.size() << 1); i += i & -i) {\n    A[i ^ A.size()] += v;\n  }\n}\n\nint bit_get(vector<int>& A, int x) {\n  int ret = A[0];\n  for(int i = x; i; i &= i - 1) ret += A[i];\n  return ret;\n}\n\nint main() {\n  freopen(\"grassplant.in\", \"r\", stdin);\n  freopen(\"grassplant.out\", \"w\", stdout);\n\n  int M;\n  scanf(\"%d%d\", &N, &M);\n  for(int i = 1; i < N; i++) {\n    int u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n  prep_heavylight();\n\n  for(int i = 0; i < N; i++) {\n    if(!CLN[i]) continue;\n    bit[i] = vector<int>(1 << (32 - __builtin_clz(CLN[i] - 1)), 0);\n  }\n\n  for(int i = 0; i < M; i++) {\n    char op[2]; int u, v; scanf(\"%1s%d%d\", op, &u, &v); u--; v--;\n    vector<ChainPart> ch = filter(chain_path(u, v));\n    if(op[0] == 'P') {\n      for(int i = 0; i < ch.size(); i++) {\n        bit_add(bit[ch[i].chain], ch[i].lo, 1);\n        if(ch[i].hi < CLN[ch[i].chain]) {\n          bit_add(bit[ch[i].chain], ch[i].hi, -1);\n        }\n      }\n    } else {\n      assert(ch.size() == 1 && ch[0].lo + 1 == ch[0].hi);\n      printf(\"%d\\n\", bit_get(bit[ch[0].chain], ch[0].lo));\n    }\n  }\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4 6\n1 4\n2 4\n3 4\nP 2 3\nP 1 3\nQ 3 4\nP 1 4\nQ 2 4\nQ 1 4",
        "output": "2\n1\n2",
        "input_explanation": "",
        "output_explanation": "",
        "explanation": ""
      }
    ],
    "description_no_samples": "Problem 3: Grass Planting [Travis Hance, 2011]\n\nFarmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 \nbidirectional roads, such that there is exactly one path between any two \npastures.  Bessie, a cow who loves her grazing time, often complains about \nhow there is no grass on the roads between pastures.  Farmer John loves \nBessie very much, and today he is finally going to plant grass on the\nroads.  He will do so using a procedure consisting of M steps (1 <= M <=\n100,000).\n\nAt each step one of two things will happen:\n\n- FJ will choose two pastures, and plant a patch of grass along each road in\nbetween the two pastures, or,\n\n- Bessie will ask about how many patches of grass on a particular road, and \nFarmer John must answer her question.\n\nFarmer John is a very poor counter -- help him answer Bessie's questions!\n\nPROBLEM NAME: grassplant\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers N and M\n\n* Lines 2..N: Two space-separated integers describing the endpoints of\n        a road.\n\n* Lines N+1..N+M: Line i+1 describes step i. The first character of\n        the line is either P or Q, which describes whether or not FJ\n        is planting grass or simply querying. This is followed by two\n        space-separated integers A_i and B_i (1 <= A_i, B_i <= N)\n        which describe FJ's action or query.\n\nOUTPUT FORMAT:\n\n* Lines 1..???: Each line has the answer to a query, appearing in the\n        same order as the queries appear in the input.",
    "description_raw": "Problem 3: Grass Planting [Travis Hance, 2011]\n\nFarmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 \nbidirectional roads, such that there is exactly one path between any two \npastures.  Bessie, a cow who loves her grazing time, often complains about \nhow there is no grass on the roads between pastures.  Farmer John loves \nBessie very much, and today he is finally going to plant grass on the\nroads.  He will do so using a procedure consisting of M steps (1 <= M <=\n100,000).\n\nAt each step one of two things will happen:\n\n- FJ will choose two pastures, and plant a patch of grass along each road in\nbetween the two pastures, or,\n\n- Bessie will ask about how many patches of grass on a particular road, and \nFarmer John must answer her question.\n\nFarmer John is a very poor counter -- help him answer Bessie's questions!\n\nPROBLEM NAME: grassplant",
    "input_format": "* Line 1: Two space-separated integers N and M\n\n* Lines 2..N: Two space-separated integers describing the endpoints of\n        a road.\n\n* Lines N+1..N+M: Line i+1 describes step i. The first character of\n        the line is either P or Q, which describes whether or not FJ\n        is planting grass or simply querying. This is followed by two\n        space-separated integers A_i and B_i (1 <= A_i, B_i <= N)\n        which describe FJ's action or query.",
    "output_format": "* Lines 1..???: Each line has the answer to a query, appearing in the\n        same order as the queries appear in the input.",
    "num_samples": 1
  },
  "842_platinum_disruption": {
    "name": "Disruption",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=842",
    "test_data_link": "http://www.usaco.org/current/data/disrupt_platinum_open18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_disrupt_platinum_open18.html",
    "contest_link": "http://www.usaco.org/index.php?page=open18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "842",
    "problem_id": "842_platinum_disruption",
    "description": "Farmer John prides himself on running a well-connected farm.  The farm is a \ncollection of $N$ pastures ($2 \\leq N \\leq 50,000$), pairs of which are \nconnected with $N-1$ bi-directional pathways, each having unit length. Farmer\nJohn notices that using an appropriate series of these pathways,  it is possible\nto travel from any pasture to any other pasture.\n\nAlthough FJ's farm is connected, he worries what might happen if one of  the\npathways gets blocked, as this would effectively partition his farm into two\ndisjoint sets of pastures, where the cows could travel within each set but not\nbetween the sets.  FJ therefore builds a set of $M$ additional  bi-directional\npathways ($1 \\leq M \\leq 50,000$), each with a positive integer length at most\n$10^9$.  The cows still only use the original pathways  for transit, unless one\nof these becomes blocked.  \n\nIf one of the original pathways becomes blocked, the farm becomes partitioned\ninto two disjoint pieces, and FJ will select from among his extra pathways a \nsingle replacement pathway that re-establishes connectivity between these two\npieces, so the cows can once again travel from any pasture to any other pasture.\n\nFor each of the original pathways on the farm, help FJ select the shortest\nsuitable replacement pathway.\n\nINPUT FORMAT:\nThe first line of input contains $N$ and $M$.  Each of the next $N-1$ lines\ndescribes an original pathway using integers $p$, $q$, where $p \\neq q$ are the\npastures connected by the pathway (in the range $1 \\ldots N$).  The remaining\n$M$ lines each describe an extra pathway in terms of three integers: $p$, $q$,\nand $r$, where $r$ is the length of the pathway. At most one pathway runs\nbetween any pair of pastures.\n\nOUTPUT FORMAT:\nFor each of the $N-1$ original pathways in the order they appear in the input,\noutput the length of the shortest suitable replacement pathway which would \nre-connect the farm if that original pathway were to be blocked.  If no suitable\nreplacement exists, output -1.\n\nSAMPLE INPUT:\n6 3\n1 2\n1 3\n4 1\n4 5\n6 5\n2 3 7\n3 6 8\n6 4 5\nSAMPLE OUTPUT: \n7\n7\n8\n5\n5\n\n\nProblem credits: Brian Dean\n",
    "num_tests": 15,
    "solution": "\nThis problem involves finding so-called \"replacement edges\" for a spanning tree,\na problem that is closely linked with the minimum spanning tree problem.  There \nare several nice ways to approach it, varying quite a bit in terms of complexity\nof implementation.  Below is one particularly nice solution, from coach Matt\nFontaine,  running in $O(n \\log m + m \\log^2 m)$ time.\nFirst we need a priority queue data structure -- capable of adding a new\nelement, removing an element, and querying for the minimum element.  Depending\non language, there are several suitable choices here (Matt uses a hash table\nplus a priority queue in Java; a C++ set would probably also suffice).  \nFor each candidate replacement edge, put a candidate \"token\" on each of its two\nendpoint nodes, with value equal to the weight of the edge.  We then traverse\nthe tree (say, with a post-order traversal), and for each of its  subtrees we\ncompute the minimum value of all the tokens appearing exactly once in the\nsubtree (since these tell us the weights of the edges with exactly one endpoint\nin the subtree, and one endpoint outside the subtree).  Our priority queue\nmaintains the set of tokens appearing exactly once in the current subtree.\nWhenever we try to add the second token for the same edge to the priority queue,\nwe instead remove the existing token, since now both edges lie within the same\nsubtree.\nAs the traversal works its way up the tree, we need to \"merge\" the priority\nqueue contents of subtrees together.  E.g., suppose we have finished traversing\nsubtrees rooted at nodes $x$ and $y$ and now we move up to the parent $p$ of $x$\nand $y$.  At this point, we have a separate priority queue for the contents of\n$x$'s subtree and for that  of $y$'s subtree.  To merge these together to get a\nsingle priority queue reflecting the contents of $p$'s subtree, we take all the\nelements in the smaller of $x$'s  and $y$'s priority queues and insert these\ninto the larger.  Using this relatively common \"merge the smaller into the\nlarger\" trick, we get good amortized performance since each element participates\nin at most $\\log m$ inserts, since each time it is inserted it finds that it is\npart of a priority queue of at least twice the size as before.  Since each\ninsert takes $O(\\log m)$ time, this is where we get the running time of\n$O(\\log^2 m)$ per potential replacement edge.\nMatt's code is below; note that a good chunk of it is a pre-built I/O class, so\nthe solution code is actually quite concise.  \nFinal note: in theory, the problem has a rather sophisticated $O(m\\alpha(n))$\nsolution on a graph with $n$ nodes and $m$ edges, where $\\alpha()$ denotes the \ninverse Ackermann function, although this solution is well beyond the scope of \nwhat would be expected in a contest setting.\n\nimport java.util.*;                                                                                                    \nimport java.io.*;                                                                                                      \n\npublic class dis\n{\n   public static void main(String[] args) throws Exception\n   {\n      FastScanner in = new FastScanner(new FileInputStream(\"disrupt.in\"));                                             \n      PrintWriter out = new PrintWriter(new File(\"disrupt.out\"));                                                      \n      new dis(in, out);                                                                                                \n      out.close();                                                                                                     \n   }\n\n   int N;                                                                                                              \n   ArrayList<Edge>[] adj;                                                                                              \n   Blob[] blobs;                                                                                                       \n   int[] res;                                                                                                          \n\n   void dfs(int i, int p)\n   {\n      for (Edge e : adj[i]) if (e.j != p)\n      {\n         dfs(e.j, i);                                                                                                  \n         res[e.id] = blobs[e.j].min();                                                                                 \n         blobs[i] = blobs[i].merge(blobs[e.j]);                                                                        \n      }\n   }\n\n   public dis(FastScanner in, PrintWriter out)\n   {\n      N = in.nextInt();                                                                                                \n      int M = in.nextInt();                                                                                            \n      res = new int[N-1];                                                                                              \n      blobs = new Blob[N];                                                                                             \n      for (int i=0; i<N; i++)                                                                                          \n         blobs[i] = new Blob();                                                                                        \n      adj = new ArrayList[N];                                                                                          \n      for (int i=0; i<N; i++)                                                                                          \n         adj[i] = new ArrayList<>();                                                                                   \n      for (int x=0; x<N-1; x++)                                                                                        \n      {\n         int i = in.nextInt()-1;                                                                                       \n         int j = in.nextInt()-1;                                                                                       \n         adj[i].add(new Edge(j, x));                                                                                   \n         adj[j].add(new Edge(i, x));                                                                                   \n      }\n\n      for (int x=0; x<M; x++)                                                                                          \n      {\n         int i = in.nextInt()-1;                                                                                       \n         int j = in.nextInt()-1;                                                                                       \n         int w = in.nextInt();                                                                                         \n         blobs[i].add(new Node(x, w));                                                                                 \n         blobs[j].add(new Node(x, w));                                                                                 \n      }\n\n      dfs(0,0);                                                                                                        \n      for (int rr : res)\n         out.println(rr);                                                                                              \n   }\n}\n\nclass Blob\n{\n   PriorityQueue<Node> q;                                                                                              \n   HashSet<Integer> active;                                                                                            \n\n   Blob()\n   {\n      q = new PriorityQueue<>();                                                                                       \n      active = new HashSet<>();                                                                                        \n   }\n\n   void mergeInto(Blob rhs)\n   {\n      for (Node n : rhs.q)\n         if (rhs.active.contains(n.id))\n            add(n);                                                                                                    \n   }\n\n   Blob merge(Blob rhs)\n   {\n      if (active.size() > rhs.active.size())\n      {\n         mergeInto(rhs);                                                                                               \n         return this;                                                                                                  \n      }\n      else\n      {\n         rhs.mergeInto(this);                                                                                          \n         return rhs;                                                                                                   \n      }\n   }\n\n   void add(Node n)\n   {\n      if (active.contains(n.id))\n      {\n         active.remove(n.id);                                                                                          \n      }\n      else\n      {\n         active.add(n.id);                                                                                             \n         q.add(n);                                                                                                     \n      }\n   }\n\n   int min()\n   {\n      while (q.size() > 0 && !active.contains(q.peek().id))\n         q.poll();                                                                                                     \n      return q.size() > 0 ? q.peek().w : -1;                                                                           \n   }\n}\n\nclass Node implements Comparable<Node>\n{\n   int id, w;                                                                                                          \n\n   Node(int id, int w)\n   {\n      this.id = id;                                                                                                    \n      this.w = w;                                                                                                      \n   }\n\n   public int compareTo(Node rhs)\n   {\n      return Integer.compare(w, rhs.w);                                                                                \n   }\n}\n\nclass Edge\n{\n   int j, id;                                                                                                          \n\n   Edge(int jj, int ii)\n   {\n      j=jj; id=ii;                                                                                                     \n   }\n}\n\nclass FastScanner{\n   private InputStream stream;                                                                                         \n   private byte[] buf = new byte[1024];                                                                                \n   private int curChar;                                                                                                \n   private int numChars;                                                                                               \n\n   public FastScanner(InputStream stream)\n   {\n      this.stream = stream;                                                                                            \n   }\n\n   int read()\n   {\n      if (numChars == -1)\n         throw new InputMismatchException();                                                                           \n      if (curChar >= numChars){\n         curChar = 0;                                                                                                  \n         try{\n            numChars = stream.read(buf);                                                                               \n         } catch (IOException e) {\n            throw new InputMismatchException();                                                                        \n         }\n         if (numChars <= 0)\n            return -1;                                                                                                 \n      }\n      return buf[curChar++];                                                                                           \n   }\n\n   boolean isSpaceChar(int c)\n   {\n      return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;                                                                 \n   }\n\n   boolean isEndline(int c)\n   {\n      return c=='\\n'||c=='\\r'||c==-1;                                                                                  \n   }\n\n   int nextInt()\n   {\n      return Integer.parseInt(next());                                                                                 \n   }\n\n   long nextLong()\n   {\n      return Long.parseLong(next());                                                                                   \n   }\n\n   double nextDouble()\n   {\n      return Double.parseDouble(next());                                                                               \n   }\n\n   String next(){\n      int c = read();                                                                                                  \n      while (isSpaceChar(c))\n         c = read();                                                                                                   \n      StringBuilder res = new StringBuilder();                                                                         \n      do{\n         res.appendCodePoint(c);                                                                                       \n         c = read();                                                                                                   \n      }while(!isSpaceChar(c));                                                                                         \n      return res.toString();                                                                                           \n   }\n\n   String nextLine(){\n      int c = read();                                                                                                  \n      while (isEndline(c))\n         c = read();                                                                                                   \n      StringBuilder res = new StringBuilder();                                                                         \n      do{\n         res.appendCodePoint(c);                                                                                       \n         c = read();                                                                                                   \n      }while(!isEndline(c));                                                                                           \n      return res.toString();                                                                                           \n   }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "6 3\n1 2\n1 3\n4 1\n4 5\n6 5\n2 3 7\n3 6 8\n6 4 5",
        "output": "7\n7\n8\n5\n5",
        "explanation": ""
      }
    ],
    "description_no_samples": "Farmer John prides himself on running a well-connected farm.  The farm is a \ncollection of $N$ pastures ($2 \\leq N \\leq 50,000$), pairs of which are \nconnected with $N-1$ bi-directional pathways, each having unit length. Farmer\nJohn notices that using an appropriate series of these pathways,  it is possible\nto travel from any pasture to any other pasture.\n\nAlthough FJ's farm is connected, he worries what might happen if one of  the\npathways gets blocked, as this would effectively partition his farm into two\ndisjoint sets of pastures, where the cows could travel within each set but not\nbetween the sets.  FJ therefore builds a set of $M$ additional  bi-directional\npathways ($1 \\leq M \\leq 50,000$), each with a positive integer length at most\n$10^9$.  The cows still only use the original pathways  for transit, unless one\nof these becomes blocked.  \n\nIf one of the original pathways becomes blocked, the farm becomes partitioned\ninto two disjoint pieces, and FJ will select from among his extra pathways a \nsingle replacement pathway that re-establishes connectivity between these two\npieces, so the cows can once again travel from any pasture to any other pasture.\n\nFor each of the original pathways on the farm, help FJ select the shortest\nsuitable replacement pathway.\n\nINPUT FORMAT:\nThe first line of input contains $N$ and $M$.  Each of the next $N-1$ lines\ndescribes an original pathway using integers $p$, $q$, where $p \\neq q$ are the\npastures connected by the pathway (in the range $1 \\ldots N$).  The remaining\n$M$ lines each describe an extra pathway in terms of three integers: $p$, $q$,\nand $r$, where $r$ is the length of the pathway. At most one pathway runs\nbetween any pair of pastures.\n\nOUTPUT FORMAT:\nFor each of the $N-1$ original pathways in the order they appear in the input,\noutput the length of the shortest suitable replacement pathway which would \nre-connect the farm if that original pathway were to be blocked.  If no suitable\nreplacement exists, output -1.\n\n",
    "num_samples": 1
  },
  "866_platinum_the_cow_gathering": {
    "name": "The Cow Gathering",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=866",
    "test_data_link": "http://www.usaco.org/current/data/gathering_platinum_dec18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_gathering_platinum_dec18.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "866",
    "problem_id": "866_platinum_the_cow_gathering",
    "description": "Cows have assembled from around the world for a massive gathering. There are $N$\ncows, and $N-1$ pairs of cows who are friends with each other. Every cow knows\nevery other cow through some chain of friendships. \n\nThey had great fun, but the time has come for them to leave, one by one. They\nwant to leave in some order such that as long as there are still at least two\ncows left, every remaining cow has a remaining friend. Furthermore, due to\nissues with luggage storage, there are $M$ pairs of cows $(a_i, b_i)$ such that\ncow $a_i$ must leave before cow $b_i$. Note that the cows $a_i$ and $b_i$ may or\nmay not be friends.\n\nHelp the cows figure out, for each cow, whether she could be the last cow to\nleave. It may be that there is no way for the cows to leave satisfying the above\nconstraints.\n\nINPUT FORMAT:\nLine $1$ contains two space-separated integers $N$ and $M$.\n\nLines $2 \\leq i \\leq N$ each contain two integers $x_i$ and $y_i$ with\n$1 \\leq x_i, y_i \\leq N$ and $x_i \\neq y_i$ indicating that cows $x_i$ and $y_i$\nare friends.\n\nLines $N+1 \\leq i \\leq N+M$ each contain two integers $a_i$ and $b_i$ with\n$1 \\leq a_i, b_i \\leq N$ and $a_i \\neq b_i$ indicating that cow $a_i$ must leave\nthe gathering before cow $b_i$. \n\nIt is guaranteed that $1 \\leq N, M \\leq 10^5$. In test cases worth $20\\%$\nof the points, it is further guaranteed that $N, M \\leq 3000$.\n\nOUTPUT FORMAT:\nThe output should consist of $N$ lines, with one integer $d_i$ on each line such\nthat $d_i = 1$ if cow $i$ could be the last to leave, and $d_i = 0$ otherwise.\n\nSAMPLE INPUT:\n5 1\n1 2\n2 3\n3 4\n4 5\n2 4\nSAMPLE OUTPUT: \n0\n0\n1\n1\n1\n\n\nProblem credits: Dhruv Rohatgi\n",
    "num_tests": 17,
    "solution": "\n(Analysis by  Dhruv Rohatgi )\nThe problem can be rephrased as follows: removing leaves from a tree one by one\nwhile respecting order constraints, determine the possible final nodes. Let's\nstart with an easier variant: determine whether there exists a feasible\nordering, and if so, find a possible final node. This can be solved by greedily\nremoving \"free\" leaves: that is, leaves which are not constrained to be removed\nafter nodes which still remain in the tree. \nTo prove that this works, note that if there is no feasible ordering, than this\ngreedy process cannot possibly succeed. Conversely, if the process does not\nsucceed, then there is some contiguous subtree in which every leaf of the\nsubtree is constrained to be removed after some other node in the subtree. Any\nordering has to break at least one of these constraints, since out of all the\nnodes in the subtree, some leaf is removed first. So there is no feasible\nordering.\nNow we want to find all possible final nodes. If the above greedy algorithm\nfails, then we're done: there are no possible final nodes. Otherwise, we've\nfound one final node $r$ and want to find all others. Intuitively, the possible\nfinal nodes should form a contiguous subtree. This intuition is correct. \nLet $s$ be any neighbor of $r$. If there is some constraint that $s$ must be\nremoved before some other node, then $s$ is clearly not a possible final node.\nIt turns out this is sufficient: fix a feasible ordering in which $r$ is the\nfinal node, and find the location where $s$ is removed. Swapping $s$ with the\nnext node in the ordering does not break any constraints, so $s$ can be\niteratively swapped towards the end of the ordering. Hence, $s$ is a possible\nfinal node.\nThis means that if we consider the induced subgraph of all nodes $a$ with no\nconstraints of the form \"remove $a$ before $b$\", then every node in the\nconnected component of $r$ is a possible final node.\nIn fact, such nodes are the only possible final nodes. Fix some node $s$ such\nthat there is some node $a$ along the path from $s$ to $r$, and some constraint\n\"remove $a$ before $b$\". Root the tree at $a$. Then $r$ and $s$ are in different\nsubtrees. If $b$ is not in the subtree of $r$, then $a$ is on the path from $r$\nto $b$, so $r$ must be removed before $a$, so $r$ is not a possible final node.\nContradiction, so $b$ is in the subtree of $r$. But then it's not in the subtree\nof $s$, so by the same reasoning, $s$ is not a possible final node.\nThis yields our final algorithm: run the greedy process to find $r$, and run DFS\nfrom $r$, avoiding nodes $a$ which have constraints \"remove $a$ before $b$\". The\nset of visited nodes is the set of possible final nodes.\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MAXN 100000\n \nint N,M;\nvector<int> edges[MAXN];\nvector<int> inConstraints[MAXN];\t//i: must remove j before i\nvector<int> outConstraints[MAXN];\t//i: must remove i before j\nint numInConstraints[MAXN];\nint numEdges[MAXN];\nbool isfree[MAXN];\nbool isroot[MAXN];\n \nvoid dfs(int i,int par)\n{\n\tif(outConstraints[i].size() > 0)\n\t\treturn;\n\tisroot[i] = 1;\n\tfor(int j=0;j<edges[i].size();j++)\n\t\tif(edges[i][j] != par)\n\t\t\tdfs(edges[i][j], i);\n}\n \n \nint main()\n{\n\tcin >> N >> M;\n\tint a,b;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t\tnumEdges[a]++, numEdges[b]++;\n\t}\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tinConstraints[b].push_back(a);\n\t\toutConstraints[a].push_back(b);\n\t\tnumInConstraints[b]++;\n\t}\n\tvector<int> freeNodes;\n\tfor(int i=0;i<N;i++)\n\t\tif(numEdges[i]<=1 && numInConstraints[i]==0)\n\t\t{\n\t\t\tfreeNodes.push_back(i);\n\t\t\tisfree[i] = 1;\n\t\t}\n\tfor(int i=0;i<N-1;i++)\n\t{\n\t\tif(i == freeNodes.size())\n\t\t{\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\tcout << 0 << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tint cur = freeNodes[i];\n\t\tfor(int j=0;j<edges[cur].size();j++)\n\t\t{\n\t\t\tint e = edges[cur][j];\n\t\t\tnumEdges[e]--;\n\t\t\tif(numEdges[e]<=1 && numInConstraints[e]==0 && !isfree[e])\n\t\t\t{\n\t\t\t\tfreeNodes.push_back(e);\n\t\t\t\tisfree[e] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<outConstraints[cur].size();j++)\n\t\t{\n\t\t\tint e = outConstraints[cur][j];\n\t\t\tnumInConstraints[e]--;\n\t\t\tif(numEdges[e]<=1 && numInConstraints[e]==0 && !isfree[e])\n\t\t\t{\n\t\t\t\tfreeNodes.push_back(e);\n\t\t\t\tisfree[e] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint root = freeNodes[N-1];\n\tdfs(root, -1);\n\tint num = 0;\n\tfor(int i=0;i<N;i++)\n\t\tnum += isroot[i];\n\tfor(int i=0;i<N;i++)\n\t\tcout << isroot[i] << '\\n';\n}\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5 1\n1 2\n2 3\n3 4\n4 5\n2 4",
        "output": "0\n0\n1\n1\n1",
        "explanation": ""
      }
    ],
    "description_no_samples": "Cows have assembled from around the world for a massive gathering. There are $N$\ncows, and $N-1$ pairs of cows who are friends with each other. Every cow knows\nevery other cow through some chain of friendships. \n\nThey had great fun, but the time has come for them to leave, one by one. They\nwant to leave in some order such that as long as there are still at least two\ncows left, every remaining cow has a remaining friend. Furthermore, due to\nissues with luggage storage, there are $M$ pairs of cows $(a_i, b_i)$ such that\ncow $a_i$ must leave before cow $b_i$. Note that the cows $a_i$ and $b_i$ may or\nmay not be friends.\n\nHelp the cows figure out, for each cow, whether she could be the last cow to\nleave. It may be that there is no way for the cows to leave satisfying the above\nconstraints.\n\nINPUT FORMAT:\nLine $1$ contains two space-separated integers $N$ and $M$.\n\nLines $2 \\leq i \\leq N$ each contain two integers $x_i$ and $y_i$ with\n$1 \\leq x_i, y_i \\leq N$ and $x_i \\neq y_i$ indicating that cows $x_i$ and $y_i$\nare friends.\n\nLines $N+1 \\leq i \\leq N+M$ each contain two integers $a_i$ and $b_i$ with\n$1 \\leq a_i, b_i \\leq N$ and $a_i \\neq b_i$ indicating that cow $a_i$ must leave\nthe gathering before cow $b_i$. \n\nIt is guaranteed that $1 \\leq N, M \\leq 10^5$. In test cases worth $20\\%$\nof the points, it is further guaranteed that $N, M \\leq 3000$.\n\nOUTPUT FORMAT:\nThe output should consist of $N$ lines, with one integer $d_i$ on each line such\nthat $d_i = 1$ if cow $i$ could be the last to leave, and $d_i = 0$ otherwise.\n\n",
    "num_samples": 1
  },
  "1190_platinum_multiple_choice_test": {
    "name": "Multiple Choice Test",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1190",
    "test_data_link": "http://www.usaco.org/current/data/prob3_platinum_jan22.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob3_platinum_jan22.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan22results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "1190",
    "problem_id": "1190_platinum_multiple_choice_test",
    "description": "The cows are taking a multiple choice test. But instead of a standard test where your\nselected choices are scored for each question individually and then summed, in\nthis test your selected choices are summed before being scored.\n\nSpecifically, you are given $N$ ($2\\le N\\le 10^5$) groups of integer vectors  on\nthe 2D plane, where each vector is denoted by an ordered pair $(x,y)$. Choose\none vector from each group such that the sum of the vectors is as far away from\nthe origin as possible.\n\nIt is guaranteed that the total number of vectors is at most $2\\cdot 10^5$. \nEach group has size at least $2$, and within a group, all vectors are distinct. \nIt is also guaranteed that every $x$ and $y$ coordinate has absolute value at\nmost $\\frac{10^9}{N}$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, the number of groups.\n\nEach group starts with $G$, the number of vectors in the group, followed by $G$\nlines containing the vectors in that group. Consecutive groups are separated by\nnewlines.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe maximum possible squared Euclidean distance.\n\nSAMPLE INPUT:\n3\n\n2\n-2 0\n1 0\n\n2\n0 -2\n0 1\n\n3\n-5 -5\n5 1\n10 10\nSAMPLE OUTPUT: \n242\n\nIt is optimal to select $(1,0)$ from the first group, $(0,1)$ from the second\ngroup, and $(10,10)$ from the third group. The sum of these vectors is\n$(11,11)$, which is squared distance $11^2+11^2=242$ from the origin.\n\nSCORING:\nIn test cases 1-5, the total number of vectors is at most $10^3$.In test cases 6-9, every group has size exactly two.Test cases 10-17 satisfy no additional constraints.\n\n\nProblem credits: Benjamin Qi\n",
    "num_tests": 17,
    "solution": "\n(Analysis by Benjamin Qi)\nLet $f(x,y)=x^2+y^2$ be the function we want to maximize. It turns out that for\nany convex\nfunction $f$, we can apply the same solution.\nClaim: We only need to consider evaluating $f$ at the vertices of the\nconvex hull of the set of all\npossible Minkowski sums.\nProof: Any point $p$ within the convex hull that is not a vertex can be\nwritten as  $p=\\lambda_1v_1+\\lambda_2v_2+\\cdots+\\lambda_kv_k$ for some\n$\\lambda_i>0, \\sum \\lambda_i=1$, $k>1$, and $v_1,\\ldots,v_k$ distinct vertices\nof the convex hull. Then assuming $f$ is convex,\n$$f(p)\\le f\\left(\\sum \\lambda_iv_i\\right)\\le \\sum \\lambda_i f(v_i)\\implies \\max_i f(v_i)\\ge f(p).$$\nIt remains to describe how to efficiently compute the convex hull of the\nMinkowski sum.\nFor a slow solution, we may directly compute the convex hull of the Minkowski\nsum of two sets  of sizes $|A|$ and $|B|$, by summing every pair of points and\nthen computing the convex hull in $\\mathcal O(|A|\\cdot |B|\\log (|A|\\cdot |B|))$\ntime. It turns out the convex hull of the Minkowski sum always has at most\n$|A|+|B|$ vertices, leading to an  $\\mathcal O(T^2\\log T)$ time solution if we\napply this reasoning for every group in the input, where $T$ is the total number\nof vectors.\nMy code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n#define f first\n#define s second\n\nusing ll = long long;\n\nP operator+(P a, P b) { return {a.f + b.f, a.s + b.s}; }\nP operator-(P a, P b) { return {a.f - b.f, a.s - b.s}; }\nll cross(P a, P b) { return (ll)a.f * b.s - (ll)a.s * b.f; }\nll cross(P a, P b, P c) { return cross(b - a, c - a); }\nll sq(ll x) { return x * x; }\nll norm(P p) { return sq(p.f) + sq(p.s); }\n\n// Graham Scan, assumes the hull has size > 1\nvector<P> convex_hull(vector<P> v) {\n\tnth_element(begin(v), begin(v), end(v));\n\tconst P leftmost = v[0];\n\tfor (P &p : v) p = p - leftmost;\n\tsort(begin(v), end(v), [](P a, P b) { // sort points by argument\n\t\tif (cross(a, b) == 0) return norm(a) < norm(b);\n\t\treturn cross(a, b) > 0;\n\t});\n\tvector<P> hull;\n\tfor (P p : v) {\n\t\twhile (hull.size() >= 2 && cross(end(hull)[-2], end(hull)[-1], p) <= 0)\n\t\t\thull.pop_back();\n\t\thull.push_back(p);\n\t}\n\tfor (P &p : hull) p = p + leftmost;\n\treturn hull;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint N;\n\tcin >> N;\n\tvector<P> prefix_hull{{}};\n\twhile (N--) {\n\t\tint G;\n\t\tcin >> G;\n\t\tvector<P> group(G);\n\t\tfor (P &p : group) cin >> p.f >> p.s;\n\t\tvector<P> next_prefix;\n\t\tfor (P a : prefix_hull)\n\t\t\tfor (P b : group) next_prefix.push_back(a + b);\n\t\tprefix_hull = convex_hull(next_prefix);\n\t}\n\tll ans = 0;\n\tfor (P p : prefix_hull) ans = max(ans, norm(p));\n\tcout << ans << \"\\n\";\n}\n\nFor a more efficient solution, let's start by computing the convex hull of each\ngroup. Then consider the following question: How can we more efficiently compute\nthe convex hull of the Minkowski sum of two convex polygons $A$ and $B$ (and why\nis it  true that it  has size at most $|A|+|B|$)? \nDefine the offset sequence  of a  convex polygon to be the sequence of\nvectors traversed when touring the hull starting at the lexicographically least\nvertex of the hull and going in counterclockwise order. It turns out that the\noffset sequence of the Minkowski sum is always a permutation of the combined\noffset sequences of the summands. Consider the following example:\n\nA = [(0, 0), (2, -1), (3, 0), (2, 2)]\noffsets_A = [(2, -1), (1, 1), (-1, 2), (-2, -2)]\n\nB = [(0, 0), (4, -3), (0, 5)]\noffsets_B = [(4, -3), (-4, 8), (0, -5)]\n\nsum(A,B) = C = [(0, 0), (4, -3), (6, -4), (7, -3), (6, -1), (2, 7), (0, 5)]\noffsets_C = [(4, -3), (2, -1), (1, 1), (-1, 2), (-4, 8), (-2, -2), (0, -5)]\n\nObserve that $\\texttt{offsets}_C$ may be computed by merging the sequences\n$\\texttt{offsets}_A$ and $\\texttt{offsets}_B$ such that the final sequence is\nsorted in order of \nargument (as\ndescribed\nhere).\nFor a more complete explanation of Minkowski sums, you can check the editorial\nfor this problem.\nIf we want to compute the offsets of the Minkowski sum of more than two convex\nhulls, we can place all of the offsets into a single sequence and sort the\nentire sequence by argument. The overall time complexity is\n$\\mathcal O(T\\log T)$.\nMy code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n#define f first\n#define s second\n\nusing ll = long long;\n\nP operator+(P a, P b) { return {a.f + b.f, a.s + b.s}; }\nP operator-(P a, P b) { return {a.f - b.f, a.s - b.s}; }\nll cross(P a, P b) { return (ll)a.f * b.s - (ll)a.s * b.f; }\nll cross(P a, P b, P c) { return cross(b - a, c - a); }\nll sq(ll x) { return x * x; }\nll norm(P p) { return sq(p.f) + sq(p.s); }\nint half(P p) {\n\tif (p.f > 0 || (p.f == 0 && p.s > 0)) return 0;\n\treturn 1;\n}\n\n// Graham Scan, assumes the hull has size > 1\nvector<P> convex_hull(vector<P> v) {\n\tnth_element(begin(v), begin(v), end(v));\n\tconst P leftmost = v[0];\n\tfor (P &p : v) p = p - leftmost;\n\tsort(begin(v), end(v), [](P a, P b) { // sort points by argument\n\t\tif (cross(a, b) == 0) return norm(a) < norm(b);\n\t\treturn cross(a, b) > 0;\n\t});\n\tvector<P> hull;\n\tfor (P p : v) {\n\t\twhile (hull.size() >= 2 && cross(end(hull)[-2], end(hull)[-1], p) <= 0)\n\t\t\thull.pop_back();\n\t\thull.push_back(p);\n\t}\n\tfor (P &p : hull) p = p + leftmost;\n\treturn hull;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint N;\n\tcin >> N;\n\tP start{}; // lexicographically minimum reachable point\n\tvector<P> offsets;\n\twhile (N--) {\n\t\tint G;\n\t\tcin >> G;\n\t\tvector<P> group(G);\n\t\tfor (P &p : group) cin >> p.f >> p.s;\n\t\tvector<P> hull = convex_hull(group);\n\t\tstart = start + hull[0];\n\t\tfor (int i = 1; i <= hull.size(); ++i)\n\t\t\toffsets.push_back(hull[i % hull.size()] - hull[i - 1]);\n\t}\n\t// sort offsets by CCW angle such that (0, -1) comes last\n\tsort(begin(offsets), end(offsets), [](P a, P b) {\n\t\tif (half(a) != half(b)) return half(a) < half(b);\n\t\treturn cross(a, b) > 0;\n\t});\n\tll ans = 0;\n\t// tour the hull in counterclockwise order\n\tfor (int i = 0; i < offsets.size(); ++i) {\n\t\tans = max(ans, norm(start));\n\t\tstart = start + offsets[i];\n\t}\n\tcout << ans << \"\\n\";\n}\n\nDanny Mittal's code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n \npublic class MultipleChoiceTest {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        List<Vector> exchanges = new ArrayList<>();\n        Vector curr = new Vector(0, 0);\n        for (; n > 0; n--) {\n            in.readLine();\n            int g = Integer.parseInt(in.readLine());\n            Vector[] group = new Vector[g];\n            for (int j = 0; j < g; j++) {\n                StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n                long x = Long.parseLong(tokenizer.nextToken());\n                long y = Long.parseLong(tokenizer.nextToken());\n                group[j] = new Vector(x, y);\n            }\n            Arrays.sort(group, (u, v) -> {\n                if (v.x == u.x) {\n                    return Long.compare(v.y, u.y);\n                } else {\n                    return Long.compare(v.x, u.x);\n                }\n            });\n            List<Vector> upperHull = new ArrayList<>();\n            for (Vector v : group) {\n                while (upperHull.size() >= 2 && sideOfLine(upperHull.get(upperHull.size() - 2), upperHull.get(upperHull.size() - 1), v) >= 0L) {\n                    upperHull.remove(upperHull.size() - 1);\n                }\n                upperHull.add(v);\n            }\n            List<Vector> lowerHull = new ArrayList<>();\n            for (Vector v : group) {\n                while (lowerHull.size() >= 2 && sideOfLine(lowerHull.get(lowerHull.size() - 2), lowerHull.get(lowerHull.size() - 1), v) <= 0L) {\n                    lowerHull.remove(lowerHull.size() - 1);\n                }\n                lowerHull.add(v);\n            }\n            for (int j = upperHull.size() - 1; j > 0; j--) {\n                Vector before = upperHull.get(j);\n                Vector after = upperHull.get(j - 1);\n                exchanges.add(after.minus(before));\n            }\n            for (int j = 0; j < lowerHull.size() - 1; j++) {\n                Vector before = lowerHull.get(j);\n                Vector after = lowerHull.get(j + 1);\n                exchanges.add(after.minus(before));\n            }\n            Vector lowest = group[0];\n            for (Vector v : group) {\n                if (v.y < lowest.y || (v.y == lowest.y && v.x < lowest.x)) {\n                    lowest = v;\n                }\n            }\n            curr = curr.plus(lowest);\n        }\n        exchanges.sort((u, v) -> {\n            int uHalf = u.y > 0L || (u.y == 0L && u.x > 0L) ? 0 : 1;\n            int vHalf = v.y > 0L || (v.y == 0L && v.x > 0L) ? 0 : 1;\n            if (vHalf != uHalf) {\n                return uHalf - vHalf;\n            }\n            int uWhetherZero = u.y == 0L ? 0 : 1;\n            int vWhetherZero = v.y == 0L ? 0 : 1;\n            if (uWhetherZero == 0 || vWhetherZero == 0) {\n                return uWhetherZero - vWhetherZero;\n            }\n            return Long.compare(v.x * u.y, u.x * v.y);\n        });\n        long answer = curr.magnitude();\n        for (Vector exchange : exchanges) {\n            curr = curr.plus(exchange);\n            answer = Math.max(answer, curr.magnitude());\n        }\n        System.out.println(answer);\n    }\n \n    static class Vector {\n        final long x;\n        final long y;\n \n        Vector(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n \n        Vector plus(Vector other) {\n            return new Vector(x + other.x, y + other.y);\n        }\n \n        Vector minus(Vector other) {\n            return new Vector(x - other.x, y - other.y);\n        }\n \n        long magnitude() {\n            return (x * x) + (y * y);\n        }\n \n        @Override\n        public String toString() {\n            return \"Vector{\" +\n                    \"x=\" + x +\n                    \", y=\" + y +\n                    '}';\n        }\n    }\n \n    static long sideOfLine(Vector a, Vector b, Vector c) {\n        long left = (b.x - a.x) * (c.y - a.y);\n        long right = (b.y - a.y) * (c.x - a.x);\n        return left - right;\n    }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3\n\n2\n-2 0\n1 0\n\n2\n0 -2\n0 1\n\n3\n-5 -5\n5 1\n10 10",
        "output": "242",
        "explanation": "It is optimal to select $(1,0)$ from the first group, $(0,1)$ from the second\ngroup, and $(10,10)$ from the third group. The sum of these vectors is\n$(11,11)$, which is squared distance $11^2+11^2=242$ from the origin."
      }
    ],
    "description_no_samples": "The cows are taking a multiple choice test. But instead of a standard test where your\nselected choices are scored for each question individually and then summed, in\nthis test your selected choices are summed before being scored.\n\nSpecifically, you are given $N$ ($2\\le N\\le 10^5$) groups of integer vectors  on\nthe 2D plane, where each vector is denoted by an ordered pair $(x,y)$. Choose\none vector from each group such that the sum of the vectors is as far away from\nthe origin as possible.\n\nIt is guaranteed that the total number of vectors is at most $2\\cdot 10^5$. \nEach group has size at least $2$, and within a group, all vectors are distinct. \nIt is also guaranteed that every $x$ and $y$ coordinate has absolute value at\nmost $\\frac{10^9}{N}$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, the number of groups.\n\nEach group starts with $G$, the number of vectors in the group, followed by $G$\nlines containing the vectors in that group. Consecutive groups are separated by\nnewlines.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe maximum possible squared Euclidean distance.\n\n",
    "num_samples": 1
  },
  "998_platinum_falling_portals": {
    "name": "Falling Portals",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=998",
    "test_data_link": "http://www.usaco.org/current/data/falling_platinum_jan20.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_falling_platinum_jan20.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan20results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "998",
    "problem_id": "998_platinum_falling_portals",
    "description": "There are $N$ ($2\\le N\\le 2\\cdot 10^5$) worlds, each with a portal. Initially,\nworld $i$ (for $1 \\leq i \\leq N$) is at $x$-coordinate $i$, and $y$-coordinate\n$A_i$ ($1\\le A_i\\le 10^9$). There is also a cow on each world. At time $0$, all\n$y$-coordinates are distinct and the worlds start falling: world $i$ moves\ncontinuously in the negative-$y$ direction at a speed of $i$ units per second. \n\nAt any time when two worlds are at the same $y$-coordinate (possibly a\nfractional time), the portals \"align\", meaning that a cow on one of the worlds\ncan choose to travel instantaneously to the other world.\n\nFor each $i$, the cow on world $i$ wants to travel to world $Q_i$ ($Q_i\\neq i$).\nHelp each cow determine how long her journey will take, if she travels\noptimally.\n\nEach query output should be a fraction $a/b$ where $a$ and $b$ are positive and\nrelatively prime integers, or $-1$ if it the journey is impossible.\n\nSCORING:\nTest cases 2-3 satisfy $N\\le 100.$Test cases 4-5 satisfy $N\\le 2000.$Test cases 6-14 satisfy no additional constraints.\n\nINPUT FORMAT:\nThe first line of input contains a single integer $N.$\n\nThe next line contains $N$ space-separated integers $A_1,A_2,\\ldots,A_N.$\n\nThe next line contains $N$ space-separated integers $Q_1,Q_2,\\ldots,Q_N.$\n\nOUTPUT FORMAT:\nPrint $N$ lines, the $i$-th of which contains the journey length for cow $i.$\n\nSAMPLE INPUT:\n4\n3 5 10 2\n3 3 2 1\nSAMPLE OUTPUT: \n7/2\n7/2\n5/1\n-1\n\nConsider the answer for the cow originally on world 2. At time $2$ worlds 1 and\n2 align, so the cow can travel to world 1. At time $\\frac{7}{2}$ worlds 1 and 3\nalign, so the cow can  travel to world 3.\n\n\nProblem credits: Dhruv Rohatgi\n",
    "num_tests": 14,
    "solution": "\n(Analysis by Benjamin Qi)\nFix $i.$ Consider a graph of time versus\n$y$-coordinate; then world $i$ is represented by a line of slope $-i$. Call a \npoint $(T,Y)$ on this graph \"attainable\" if it is possible for cow $i$ to be at\n$y$-coordinate $Y$ at time $T.$\nSubtask 1: $O(N^3)$ BFS\nSubtask 2: It can be shown that the shortest path between any two worlds\ncontains at most one intermediate world. So for each query, iterate over all \nworlds aside from the start and the end and check if it can be the intermediate\none in $O(N^2)$ time. Alternatively, speed up the solution from subtask 1 with\nbitset.\nSubtask 3: WLOG suppose that $A[Q_i]<A_i.$ Clearly no attainable points lie below the lower convex hull\nof all lines representing worlds $j$ such that $A_j\\ge A_i$. Furthermore, all\npoints on this hull are attainable. Thus, it suffices to find the $t$-coordinate\nof the intersection of the line $y=-Q_it+A[Q_i]$ with this lower hull. We can\ncompute the hulls for all $i$ by sorting the lines by $A_i$ in decreasing order\nand adding them to the hull one by one. This can be done using a deque. After\ncomputing the hull for $i,$ we can binary search to find the intersection of the\nline with the hull.\nSpencer's Code:\n\nimport java.io.*;\nimport java.util.*;\n\npublic class falling {\n\tpublic static class Obj implements Comparable<Obj>{\n\t\tpublic long y, d;\n\t\tpublic int ind;\n\t\tpublic Obj(long a, long b, int c) {\n\t\t\ty = a;\n\t\t\td = b;\n\t\t\tind = c;\n\t\t}\n\t\tpublic int compareTo(Obj o) {\n\t\t\treturn Long.compare(y, o.y);\n\t\t}\n\t}\n\tpublic static long gc(long a, long b) {\n\t\tif(a==0L || b==0L) {\n\t\t\treturn a+b;\n\t\t}\n\t\treturn gc(b%a,a);\n\t}\n\tpublic static class Pair{\n\t\tpublic long first, second;\n\t\tPair(long a, long b){\n\t\t\tfirst = a;\n\t\t\tsecond = b;\n\t\t}\n\t}\n\tpublic static Pair make_pair(long a, long b) {\n\t\treturn new Pair(a,b);\n\t}\n\tpublic static Pair ev(Obj a, Obj b) {\n\t\treturn make_pair(Math.abs(a.y-b.y),Math.abs(a.d-b.d));\n\t}\n\tpublic static int cmp(Obj a, Obj b, Obj c) {\n\t\tPair l = ev(a,c);\n\t\tPair r = ev(b,c);\n\t\tlong res = l.first*r.second-r.first*l.second;\n\t\tif(res<0L) {\n\t\t\treturn -1;\n\t\t}\n\t\tif(res==0L) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tpublic static boolean used(Obj a, Obj b, Obj c) {\n\t\tPair l = ev(a,b);\n\t\tPair r = ev(b,c);\n\t\tlong res = l.first*r.second-r.first*l.second;\n\t\treturn (res<0L);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader in = new BufferedReader(new FileReader(\"falling.in\"));\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tString[] line = in.readLine().split(\" \");\n\t\tlong[] a = new long[n];\n\t\tint[] q = new int[n];\n\t\tlong[] num = new long[n];\n\t\tlong[] dem = new long[n];\n\t\tfor(int i = 0; i<line.length; i++) {\n\t\t\ta[i] = Integer.parseInt(line[i]);\n\t\t}\n\t\tline = in.readLine().split(\" \");\n\t\tfor(int i =0 ; i<line.length; i++) {\n\t\t\tq[i] = Integer.parseInt(line[i])-1;\n\t\t}\n\t\tArrayList<Obj> li = new ArrayList<Obj>();\n\t\tArrayList<Obj> all = new ArrayList<Obj>();\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tli.add(new Obj(a[i],-(i+1),i));\n\t\t\tall.add(new Obj(a[i],-(i+1),i));\n\t\t}\n\t\tCollections.sort(li);\n\t\tArrayList<Obj> cur = new ArrayList<Obj>();\n\t\tfor(int i = li.size()-1; i>=0; i--) {\n\t\t\tObj now = li.get(i);\n\t\t\twhile(cur.size()>0) {\n\t\t\t\tif(now.d < cur.get(cur.size()-1).d) {\n\t\t\t\t\tcur.remove(cur.size()-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cur.size()>1 && !used(now,cur.get(cur.size()-1),cur.get(cur.size()-2))) {\n\t\t\t\t\tcur.remove(cur.size()-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur.add(now);\n\t\t\tint ind = li.get(i).ind;\n\t\t\tif(a[ind]>a[(int)q[(int)ind]]) {\n\t\t\t\tif(cur.get(0).d > -(q[ind]+1)) {\n\t\t\t\t\tnum[ind]=-1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = cur.size()-1;\n \n\t\t\t\t\twhile(lo<hi){\n\t\t\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\t\t\tint l = mid;\n\t\t\t\t\t\tint r = mid+1;\n\t\t\t\t\t\tif(cur.get(r).d > - (q[ind]+1)){\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res = cmp(cur.get(l),cur.get(r),all.get((int)q[(int)ind]));\n\t\t\t\t\t\tif(res<0){\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(res==0){\n\t\t\t\t\t\t\tlo = l;\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlo = r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tPair got = ev(cur.get(lo),all.get((int)q[(int)ind]));\n\t\t\t\t\tlong g = gc(got.first,got.second);\n\t\t\t\t\tnum[ind] = got.first/g;\n\t\t\t\t\tdem[ind] = got.second/g;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur.clear();\n\t\tfor(int i = 0; i<li.size(); i++){\n\t\t\tObj now = li.get(i);\n\t\t\twhile(cur.size()>0){\n\t\t\t\tif(now.d > cur.get(cur.size()-1).d){\n\t\t\t\t\tcur.remove(cur.size()-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cur.size()>1 && !used(now, cur.get(cur.size()-1), cur.get(cur.size()-2))){\n\t\t\t\t\tcur.remove(cur.size()-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur.add(now);\n\t\t\tint ind = li.get(i).ind;\n\t\t\tif(a[ind]<a[(int)q[(int)ind]]){\n\t\t\t\tif(cur.get(0).d < -(q[ind]+1)){\n\t\t\t\t\tnum[ind] = -1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = cur.size()-1;\n\t\t\t\t\twhile(lo<hi){\n\t\t\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\t\t\tint l = mid;\n\t\t\t\t\t\tint r = mid+1;\n\t\t\t\t\t\tif(cur.get(r).d < - (q[ind]+1)){\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res = cmp(cur.get(l),cur.get(r),all.get((int)q[(int)ind]));\n\t\t\t\t\t\tif(res<0){\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(res==0){\n\t\t\t\t\t\t\tlo = l;\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlo = r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tPair got = ev(cur.get(lo),all.get((int)q[(int)ind]));\n\t\t\t\t\tlong g = gc(got.first,got.second);\n\t\t\t\t\tnum[ind] = got.first/g;\n\t\t\t\t\tdem[ind] = got.second/g;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"falling.out\")));\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tif (num[i]==-1) out.println(-1);\n\t\t\telse out.println(num[i]+\"/\"+dem[i]);\n\t\t}\n\t\tout.close();\n\t}\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4\n3 5 10 2\n3 3 2 1",
        "output": "7/2\n7/2\n5/1\n-1",
        "explanation": "Consider the answer for the cow originally on world 2. At time $2$ worlds 1 and\n2 align, so the cow can travel to world 1. At time $\\frac{7}{2}$ worlds 1 and 3\nalign, so the cow can  travel to world 3."
      }
    ],
    "description_no_samples": "There are $N$ ($2\\le N\\le 2\\cdot 10^5$) worlds, each with a portal. Initially,\nworld $i$ (for $1 \\leq i \\leq N$) is at $x$-coordinate $i$, and $y$-coordinate\n$A_i$ ($1\\le A_i\\le 10^9$). There is also a cow on each world. At time $0$, all\n$y$-coordinates are distinct and the worlds start falling: world $i$ moves\ncontinuously in the negative-$y$ direction at a speed of $i$ units per second. \n\nAt any time when two worlds are at the same $y$-coordinate (possibly a\nfractional time), the portals \"align\", meaning that a cow on one of the worlds\ncan choose to travel instantaneously to the other world.\n\nFor each $i$, the cow on world $i$ wants to travel to world $Q_i$ ($Q_i\\neq i$).\nHelp each cow determine how long her journey will take, if she travels\noptimally.\n\nEach query output should be a fraction $a/b$ where $a$ and $b$ are positive and\nrelatively prime integers, or $-1$ if it the journey is impossible.\n\nSCORING:\nTest cases 2-3 satisfy $N\\le 100.$Test cases 4-5 satisfy $N\\le 2000.$Test cases 6-14 satisfy no additional constraints.\n\nINPUT FORMAT:\nThe first line of input contains a single integer $N.$\n\nThe next line contains $N$ space-separated integers $A_1,A_2,\\ldots,A_N.$\n\nThe next line contains $N$ space-separated integers $Q_1,Q_2,\\ldots,Q_N.$\n\nOUTPUT FORMAT:\nPrint $N$ lines, the $i$-th of which contains the journey length for cow $i.$\n\n",
    "num_samples": 1
  },
  "769_platinum_push_a_box": {
    "name": "Push a Box",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=769",
    "test_data_link": "http://www.usaco.org/current/data/pushabox_platinum_dec17.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_pushabox_platinum_dec17.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec17results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "769",
    "problem_id": "769_platinum_push_a_box",
    "description": "Bessie and her friends have invented a new game. The game is named accurately,\nbut not particularly creatively. They call it the \"Push A Box Around The Barn To\nGet It In The Right Spot And Don't Move The Hay\" game (if you think that's\nexcessive, you should see some of the variable names the cows use when they\nwrite code...)\n\nThe barn can be modeled as an $N \\times M$ rectangular grid. Some of the grid\ncells have hay in them. Bessie occupies one cell in this grid, and a large\nwooden box occupies another cell.  Bessie and the box are not able to fit in the\nsame  cell at the same time, and neither can fit into a cell containing hay.\n\nBessie can move in the 4 orthogonal directions (north, east, south, west) as\nlong as she does not walk into hay. If she attempts to walk to the space with\nthe box, then the box will be pushed one space in that direction, as long as\nthere is an empty cell on the other side. If there is no empty cell, then Bessie\nwill not be able to make that move.\n\nA certain grid cell is designated as the goal. Bessie's goal is to get the box\ninto that location.  \n\nGiven the layout of the barn, including the starting positions of the box and\nthe cow, and the target position of the box, determine if it possible to win the\ngame.\n\nNote: This problem allows 512MB of memory usage, up from the default limit of 256MB.\n\nINPUT FORMAT:\nThe first line has three numbers, $N$, $M$, and $Q$, where $N$ is the number of\nrows in the grid and $M$ is the number of columns.\n\n\n$1 \\le N,M \\le 1500$.\n\n$1 \\le Q \\le 50,000$.\n\nOn the next $N$ lines is a representation of the grid, where characters\nrepresent empty cells (.), hay (#), Bessie's starting position (A), and the\nbox's initial location (B).\n\nThis is followed by $Q$ lines, each with a pair of integers $(R, C)$. For each\npair, you should determine if it is possible to get the box to that cell at row\n$R$, column $C$, starting from the initial state of the barn. The top row is row\n1, and the left column is column 1.\n\n\nOUTPUT FORMAT:\n$Q$ lines, each with either the string \"YES\" or \"NO\".\n\nSAMPLE INPUT:\n5 5 4\n##.##\n##.##\nA.B..\n##.##\n##.##\n3 2\n3 5\n1 3\n5 3\nSAMPLE OUTPUT: \nNO\nYES\nNO\nNO\n\nTo push the box to the position (3, 5), the cow just needs to move 3 spaces to\nthe right.\n\nNone of the other three positions are attainable.\n\n\nProblem credits: Nathan Pinsker\n",
    "num_tests": 15,
    "solution": "\n(Analysis by Nathan Pinsker)\nOne immediate thought that is to use some flavor of graph search to solve this\nproblem, since the state space is fairly tractable and straightforward (it only\nconsists of Bessie's and the box's position). Unfortunately, with\n$M, N \\leq 1,500$, this approach is both too slow and too time-consuming, since\nit takes $O(N^2M^2)$ space and time. However, notice that this naive approach\nkeeps track of a lot of unnecessary state information. In particular, Bessie's\nposition isn't terribly important to us most of the time -- only the box's\nposition -- and Bessie's position only matters insofar as it determines where\nthe box will be pushed next. In other words, we don't actually care about\nBessie's precise position, only from which directions she can push the box at\nthe next step.\nWe can take advantage of this insight by redefining our state slightly. It still\nconsists of Bessie's and the box's position, but we limit ourselves to\nconsidering only states where Bessie is directly next to the box. This is\n$O(MN)$ states, which is possible to work with.\nHowever, the state transition becomes more complicated as a result. Bessie can\ntransition between states in one of two ways: either she can push the box, or\nshe can walk around the box and reach another side. The first type of transition\nis easy to handle, so we turn our attention to handling the second type.\nHandling this type of transition is equivalent to asking \"Can I get from point A\nto point B, without walking over the square containing the box?\" Luckily, this\nquestion is well-studied, and is known as\nbiconnected\ncomponents. We consider the lattice graph formed by taking each unoccupied\nspot in the barn as a vertex and edges between each pair of adjacent vertices.\nSince A and B are clearly part of the same connected component, there is an\nalternate path from A to B if and only if they are part of the same biconnected\ncomponent in this graph.\nTherefore, we can solve the problem by precomputing all biconnected components\nof the lattice graph described above. We perform a BFS over our $O(NM)$ states;\nif we want to check whether Bessie can walk around the box to reach another side\nwithout moving it, we simply query our graph to see if Bessie's start and end\nvertex are part of the same biconnected component. This operation is $O(1)$, so\nour overall BFS runtime will be $O(NM)$. The runtime of our biconnected\ncomponents algorithm is also $O(NM)$. Once we have run these two algorithms, we\ncan answer queries in $O(1)$ time, so our overall running time is\n$O(NM + Q)$.\nTravis's solution is below:\n\n#include <cstdio>\n#include <cassert>\n#include <vector>\nusing namespace std;\n \n#define NMAX 1500\n \nstruct P {\n  int x, y;\n  P(int x, int y): x(x), y(y) { }\n  P() {}\n  bool operator ==(P b) {\n    return x == b.x && y == b.y;\n  }\n  bool operator !=(P b) {\n    return !(x == b.x && y == b.y);\n  }\n};\n \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n \nint getDIndex(P v1, P v2) {\n  for (int d = 0; d < 4; d++) {\n    if (v1.x + dx[d] == v2.x && v1.y + dy[d] == v2.y) {\n      return d;\n    }\n  }\n  assert(false);\n}\n \nint width, height;\nint blockStartX, blockStartY;\nint blockEndX, blockEndY;\nint humanStartX, humanStartY;\n \nbool isOpen[NMAX][NMAX];\n \nbool visited[NMAX][NMAX];\nint depth[NMAX][NMAX];\nint low[NMAX][NMAX];\n \nunsigned short adjacency[NMAX][NMAX];\nint initialD = -1;\n \nvoid biconnected_component_dfs(P v, P parent, int myDepth) {\n  visited[v.x][v.y] = true;\n  depth[v.x][v.y] = myDepth;\n  low[v.x][v.y] = myDepth;\n  int childCount = 0;\n \n  vector<vector<P>> components;\n \n  for (int d = 0; d < 4; d++) {\n    int x1 = v.x + dx[d];\n    int y1 = v.y + dy[d];\n    if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height && isOpen[x1][y1]) {\n      if (!visited[x1][y1]) {\n        if (x1 == blockStartX && y1 == blockStartY) {\n          initialD = (d + 2) % 4;\n        }\n \n        bool alreadyVisited[4];\n        for (int d2 = 0; d2 < 4; d2++) {\n          int x2 = v.x + dx[d2];\n          int y2 = v.y + dy[d2];\n          alreadyVisited[d2] = (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height && isOpen[x2][y2] && visited[x2][y2]);\n        }\n \n        biconnected_component_dfs(P(x1, y1), v, myDepth+1);\n        childCount++;\n        if (low[x1][y1] >= depth[v.x][v.y]) {\n          vector<P> cmp;\n \n          for (int d2 = 0; d2 < 4; d2++) {\n            int x2 = v.x + dx[d2];\n            int y2 = v.y + dy[d2];\n            if (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height && isOpen[x2][y2] && visited[x2][y2] && !alreadyVisited[d2]) {\n              cmp.push_back(P(x2,y2));\n            }\n          }\n \n          components.push_back(cmp);\n        }\n        low[v.x][v.y] = min(low[v.x][v.y], low[x1][y1]);\n      } else {\n        if (parent != P(x1,y1)) {\n          low[v.x][v.y] = min(low[v.x][v.y], depth[x1][y1]);\n        }\n      }\n    }\n  }\n \n  vector<P> lastComponent;\n  for (int d = 0; d < 4; d++) {\n    int x1 = v.x + dx[d];\n    int y1 = v.y + dy[d];\n    if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height && isOpen[x1][y1]) {\n      bool exist = false;\n      for (int i = 0; i < components.size(); i++) {\n        for (int j = 0; j < components[i].size(); j++) {\n          if (components[i][j] == P(x1,y1)) {\n            exist = true;\n          }\n        }\n      }\n      if (!exist) {\n        lastComponent.push_back(P(x1,y1));\n      }\n    }\n  }\n  if (lastComponent.size() > 0) {\n    components.push_back(lastComponent);\n  }\n \n  unsigned short bits = 0;\n \n  for (auto& component : components) {\n    for (int i = 1; i < component.size(); i++) {\n      int dIndex = getDIndex(v, component[i-1]);\n      int dIndex2 = getDIndex(v, component[i]);\n      bits |= ((unsigned short)1) << (dIndex*4 + dIndex2);\n      bits |= ((unsigned short)1) << (dIndex2*4 + dIndex);\n    }\n  }\n \n  adjacency[v.x][v.y] = bits;\n}\n \npair<P, char> bfs[NMAX * NMAX * 4];\nbool bfsVisited[NMAX][NMAX][4];\nvoid do_bfs(pair<P, char> startV) {\n  bfs[0] = startV;\n  int index = 0;\n  int len = 1;\n  for (int i = 0; i < width; i++) {\n    for (int j = 0; j < height; j++) {\n      for (int d = 0; d < 4; d++) {\n        bfsVisited[i][j][d] = false;\n      }\n    }\n  }\n  bfsVisited[startV.first.x][startV.first.y][(int)startV.second] = true;\n  while (index < len) {\n    pair<P, char> v = bfs[index];\n    index++;\n \n    P p = v.first;\n    int d = v.second;\n \n    int x1 = p.x;\n    int y1 = p.y;\n    int x2 = x1 - dx[d];\n    int y2 = y1 - dy[d];\n    if (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height && isOpen[x2][y2]) {\n      pair<P, char> w = make_pair(P(x2, y2), d);\n      if (!bfsVisited[w.first.x][w.first.y][(int)w.second]) {\n        bfsVisited[w.first.x][w.first.y][(int)w.second] = true;\n        bfs[len++] = w;\n      }\n    }\n \n    for (int d1 = 0; d1 < 4; d1++) {\n      if (adjacency[p.x][p.y] & (((unsigned short)1) << (d*4 + d1))) {\n        pair<P, char> w = make_pair(P(p.x, p.y), d1);\n        if (!bfsVisited[w.first.x][w.first.y][(int)w.second]) {\n          bfsVisited[w.first.x][w.first.y][(int)w.second] = true;\n          bfs[len++] = w;\n        }\n      }\n    }\n  }\n}\n \nchar rowInput[NMAX + 5];\n \nint main() {\n  int q;\n  scanf(\"%d\", &height);\n  scanf(\"%d\", &width);\n  scanf(\"%d\", &q);\n  blockStartX = -1;\n  blockStartY = -1;\n  humanStartX = -1;\n  humanStartY = -1;\n  for (int i = 0; i < height; i++) {\n    scanf(\"%s\", rowInput);\n    for (int j = 0; j < width; j++) {\n      isOpen[j][i] = (rowInput[j] != '#');\n      if (rowInput[j] == 'A') {\n        assert(humanStartX == -1);\n        humanStartX = j;\n        humanStartY = i;\n      } else if (rowInput[j] == 'B') {\n        assert(blockStartX == -1);\n        blockStartX = j;\n        blockStartY = i;\n      } else {\n        assert(rowInput[j] == '.' || rowInput[j] == '#');\n      }\n    }\n  }\n \n  for (int x = 0; x < width; x++) {\n    for (int y = 0; y < height; y++) {\n      visited[x][y] = false;\n    }\n  }\n \n  biconnected_component_dfs(P(humanStartX, humanStartY), P(-1, -1), 0);\n \n  if (initialD == -1) {\n    for (int i = 0; i < q; i++) {\n      int blockEndX, blockEndY;\n      scanf(\"%d\", &blockEndY);\n      scanf(\"%d\", &blockEndX);\n      blockEndX--;\n      blockEndY--;\n      printf(\"%s\\n\", blockStartX == blockEndX && blockStartY == blockEndY ? \"YES\" : \"NO\");\n    }\n    return 0;\n  }\n \n  do_bfs(make_pair(P(blockStartX, blockStartY), (char)initialD));\n \n  for (int i = 0; i < q; i++) {\n    int blockEndX, blockEndY;\n    scanf(\"%d\", &blockEndY);\n    scanf(\"%d\", &blockEndX);\n    blockEndX--;\n    blockEndY--;\n    assert(isOpen[blockEndX][blockEndY]);\n    bool isPossible =\n      bfsVisited[blockEndX][blockEndY][0] ||\n      bfsVisited[blockEndX][blockEndY][1] ||\n      bfsVisited[blockEndX][blockEndY][2] ||\n      bfsVisited[blockEndX][blockEndY][3];\n    printf(\"%s\\n\", isPossible ? \"YES\" : \"NO\");\n  }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5 5 4\n##.##\n##.##\nA.B..\n##.##\n##.##\n3 2\n3 5\n1 3\n5 3",
        "output": "NO\nYES\nNO\nNO",
        "explanation": "To push the box to the position (3, 5), the cow just needs to move 3 spaces to\nthe right.\n\nNone of the other three positions are attainable."
      }
    ],
    "description_no_samples": "Bessie and her friends have invented a new game. The game is named accurately,\nbut not particularly creatively. They call it the \"Push A Box Around The Barn To\nGet It In The Right Spot And Don't Move The Hay\" game (if you think that's\nexcessive, you should see some of the variable names the cows use when they\nwrite code...)\n\nThe barn can be modeled as an $N \\times M$ rectangular grid. Some of the grid\ncells have hay in them. Bessie occupies one cell in this grid, and a large\nwooden box occupies another cell.  Bessie and the box are not able to fit in the\nsame  cell at the same time, and neither can fit into a cell containing hay.\n\nBessie can move in the 4 orthogonal directions (north, east, south, west) as\nlong as she does not walk into hay. If she attempts to walk to the space with\nthe box, then the box will be pushed one space in that direction, as long as\nthere is an empty cell on the other side. If there is no empty cell, then Bessie\nwill not be able to make that move.\n\nA certain grid cell is designated as the goal. Bessie's goal is to get the box\ninto that location.  \n\nGiven the layout of the barn, including the starting positions of the box and\nthe cow, and the target position of the box, determine if it possible to win the\ngame.\n\nNote: This problem allows 512MB of memory usage, up from the default limit of 256MB.\n\nINPUT FORMAT:\nThe first line has three numbers, $N$, $M$, and $Q$, where $N$ is the number of\nrows in the grid and $M$ is the number of columns.\n\n\n$1 \\le N,M \\le 1500$.\n\n$1 \\le Q \\le 50,000$.\n\nOn the next $N$ lines is a representation of the grid, where characters\nrepresent empty cells (.), hay (#), Bessie's starting position (A), and the\nbox's initial location (B).\n\nThis is followed by $Q$ lines, each with a pair of integers $(R, C)$. For each\npair, you should determine if it is possible to get the box to that cell at row\n$R$, column $C$, starting from the initial state of the barn. The top row is row\n1, and the left column is column 1.\n\n\nOUTPUT FORMAT:\n$Q$ lines, each with either the string \"YES\" or \"NO\".\n\n",
    "num_samples": 1
  },
  "1452_platinum_all_pairs_similarity": {
    "name": "USACO 2024 December Contest, Platinum",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1452",
    "test_data_link": "http://www.usaco.org/current/data/prob1_platinum_dec24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_platinum_dec24.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec24results",
    "inner_contest_link": null,
    "problem_level": "platinum",
    "cp_id": "1452",
    "problem_id": "1452_platinum_all_pairs_similarity",
    "description": "**Note: The memory limit for this problem is 512MB, twice the default.**\nFarmer John's $N$ ($1\\le N\\le 5\\cdot 10^5$) cows are each assigned a  bitstring\nof length $K$ that is not all zero ($1\\le K\\le 20$). Different cows may be\nassigned the same bitstring.\nThe Jaccard similarity of two bitstrings is defined as the number of set bits in\ntheir bitwise intersection divided by the number of set bits in their bitwise union.\nFor example, the Jaccard similarity of the bitstrings $\\texttt{11001}$ and\n$\\texttt{11010}$ would be $2/4$.\nFor each cow, output the sum of her bitstring's Jaccard similarity with each of\nthe $N$ cows' bitstrings including her own, modulo $10^9+7$. Specifically, if\nthe sum is equal to a rational number $a/b$ where $a$ and $b$ are integers\nsharing no common factors, output the unique integer $x$ in the range\n$[0,10^9+7)$ such that $bx-a$ is divisible by $10^9+7$.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $K$.\nThe next $N$ lines each contain an integer $i\\in (0,2^K)$, representing a cow\nassociated with the length-$K$ binary representation of $i$.\nINPUT FORMAT (input arrives from the terminal / stdin):\nOutput the sum modulo $10^9+7$ for each cow on a separate line.\nSAMPLE INPUT:\n4 2\n1\n1\n2\n3\nSAMPLE OUTPUT:\n500000006\n500000006\n500000005\n500000006\nThe cows are associated with the following bitstrings:\n$[\\texttt{01}, \\texttt{01}, \\texttt{10}, \\texttt{11}]$.\nFor the first cow, the sum is\n$\\text{sim}(1,1)+\\text{sim}(1,1)+\\text{sim}(1,2)+\\text{sim}(1,3)=1+1+0+1/2\\equiv 500000006\\pmod{10^9+7}$.\nThe second cow's bitstring is the same as the first cow's, so her sum is the\nsame as above.\nFor the third cow, the sum is\n$\\text{sim}(2,1)+\\text{sim}(2,1)+\\text{sim}(2,2)+\\text{sim}(2,3)=0+0+1+1/2\\equiv 500000005\\pmod{10^9+7}$.\nSCORING:\nInputs 2-15: There will be two test cases for each of\n$K\\in \\{10,15,16,17,18,19,20\\}$.\nProblem credits: Benjamin Qi"
  },
  "1404_platinum_lazy_cow": {
    "name": "USACO 2024 February Contest, Platinum",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1404",
    "test_data_link": "http://www.usaco.org/current/data/prob1_platinum_feb24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_platinum_feb24.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb24results",
    "inner_contest_link": null,
    "problem_level": "platinum",
    "cp_id": "1404",
    "problem_id": "1404_platinum_lazy_cow",
    "description": "Bessie is hard at work preparing test cases for the USA Cowmputing Olympiad\nFebruary contest. Each minute, she can choose to not prepare any tests,\nexpending no energy; or expend $3^{a-1}$ energy preparing $a$ test cases, for\nsome positive integer $a$.\nFarmer John has $D$ ($1\\le D\\le 2\\cdot 10^5$) demands. For the $i$th demand, he\ntells Bessie that within the first $m_i$ minutes, she needs to have prepared  at\nleast $b_i$ test cases in total ($1\\le m_i\\le 10^6, 1 \\leq b_i \\leq 10^{12}$).\nLet $e_i$ be the smallest amount of energy Bessie needs to spend to satisfy the\nfirst $i$ demands. Print $e_1,\\dots,e_D$ modulo $10^9+7$.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $D$. The $i$th of the next $D$ lines contains two\nspace-separated integers $m_i$ and $b_i$.\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput $D$ lines, the $i$th containing $e_i \\text{ mod } 10^9+7$.\nSAMPLE INPUT:\n4\n5 11\n6 10\n10 15\n10 30\nSAMPLE OUTPUT:\n21\n21\n25\n90\nFor the first test case,\n$i=1$: If Bessie creates $[2, 3, 2, 2, 2]$ test cases on the first $5$\ndays, respectively, she would have expended $3^1 + 3^2 + 3^1 + 3^1 + 3^1 = 21$\nunits of energy and created $11$ test cases by the end of day $5$.\n$i=2$: Bessie can follow the above strategy to ensure $11$ test cases are\ncreated by the end of day $5$, and this will automatically satisfy the second\ndemand.\n$i=3$: If Bessie creates $[2, 3, 2, 2, 2, 0, 1, 1, 1, 1]$ test\ncases on the first $10$ days, respectively, she would have expended $25$ units\nof energy and satisfied all demands. It can be shown that she cannot expend less\nenergy.\n$i=4$: If Bessie creates 3 test cases on each of the first\n$10$ days she would have expended $3^{2}\\cdot 10 = 90$ units of energy and\nsatisfied all demands.\nFor each $i$, it can be shown that Bessie cannot satisfy the first $i$ demands using\nless energy.\nSAMPLE INPUT:\n2\n100 5\n100 1000000000000\nSAMPLE OUTPUT:\n5\n627323485\nSAMPLE INPUT:\n20\n303590 482848034083\n180190 112716918480\n312298 258438719980\n671877 605558355401\n662137 440411075067\n257593 261569032231\n766172 268433874550\n8114 905639446594\n209577 11155741818\n227183 874665904430\n896141 55422874585\n728247 456681845046\n193800 632739601224\n443005 623200306681\n330325 955479269245\n377303 177279745225\n880246 22559233849\n58084 155169139314\n813702 758370488574\n929760 785245728062\nSAMPLE OUTPUT:\n108753959\n108753959\n108753959\n148189797\n148189797\n148189797\n148189797\n32884410\n32884410\n32884410\n32884410\n32884410\n32884410\n32884410\n3883759\n3883759\n3883759\n3883759\n3883759\n3883759\nSCORING:\nInputs 4-5: $D\\le 100$ and $m_i \\le 100$ for all $i$\nInputs 6-8: $D\\le 3000$\nInputs 9-20: No additional constraints.\nProblem credits: Brandon Wang and Claire Zhang"
  },
  "974_platinum_tree_depth": {
    "name": "Tree Depth",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=974",
    "test_data_link": "http://www.usaco.org/current/data/treedepth_platinum_dec19.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_treedepth_platinum_dec19.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec19results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "974",
    "problem_id": "974_platinum_tree_depth",
    "description": "For the new year, Farmer John decided to give his cows a festive binary search tree\n(BST)! \n\nTo generate the BST, FJ starts with a permutation $a=\\{a_1,a_2,\\ldots,a_N\\}$\nof the integers $1\\ldots N$, where $N\\le 300$.  He then runs the following\npseudocode with arguments $1$ and $N.$\n\n\ngenerate(l,r):\n  if l > r, return empty subtree;\n  x = argmin_{l <= i <= r} a_i; // index of min a_i in {a_l,...,a_r}\n  return a BST with x as the root, \n    generate(l,x-1) as the left subtree,\n    generate(x+1,r) as the right subtree;\n\nFor example, the permutation $\\{3,2,5,1,4\\}$ generates the following BST:\n\n\n    4\n   / \\\n  2   5\n / \\ \n1   3\n\nLet $d_i(a)$ denote the depth of node $i$ in the tree corresponding to $a,$ \nmeaning the number of nodes on the path from $a_i$ to the root. In the above\nexample, $d_4(a)=1, d_2(a)=d_5(a)=2,$ and $d_1(a)=d_3(a)=3.$\n\nThe number of inversions of $a$ is equal to the number of pairs of integers\n$(i,j)$ such that $1\\le i<j\\le N$ and $a_i>a_j.$ The cows know that the $a$ that\nFJ will use to generate the BST has exactly $K$ inversions\n$(0\\le K\\le \\frac{N(N-1)}{2})$.  Over all $a$ satisfying this condition, compute\nthe remainder when $\\sum_ad_i(a)$ is divided by $M$ for each $1\\le i\\le N.$\n\nINPUT FORMAT:\nThe only line of input consists of three space-separated integers $N, K,$ and\n$M$, followed by a new line. $M$ will be a prime number in the range\n$[10^8,10^9+9].$\n\nOUTPUT FORMAT:\nPrint $N$ space-separated integers denoting $\\sum_ad_i(a)\\pmod{M}$ for each \n$1\\le i\\le N.$\n\nBATCHING:\nTest cases 3-4 satisfy $N\\le 8.$ Test cases 5-7 satisfy $N\\le 20.$ Test cases 8-10 satisfy $N\\le 50.$ \n\nSAMPLE INPUT:\n3 0 192603497\nSAMPLE OUTPUT: \n1 2 3 \nHere, the only permutation is $a=\\{1,2,3\\}.$ \n\nSAMPLE INPUT:\n3 1 144408983\nSAMPLE OUTPUT: \n3 4 4 \nHere, the two permutations are $a=\\{1,3,2\\}$ and $a=\\{2,1,3\\}.$\n\n\nProblem credits: Yinzhan Xu\n",
    "num_tests": 14,
    "solution": "\n(Analysis by Benjamin Qi) \nFor $N\\le 20,$ any reasonable polynomial-time solution should work. One possible\napproach is to calculate the result for all $n\\le N, k\\le \\binom{n}{2}$ in\n$O(N^7).$\nFor additional points, we should find a way to compute $d_i(a)$ without\nexplicitly constructing the tree. The key condition is that $j$ is an ancestor\nof $i$ if $a[j]=\\min(a[i\\ldots j]),$ so it follows that\n$$d_i(a)=1+\\sum_{1\\le j<i}(a[j] == \\min(a[j\\ldots i]))+\\sum_{i<j\\le n}(a[j] == \\min(a[i\\ldots j])).$$\nLet's focus on counting the number of permutations $a$ such that\n$a[j] == \\min(a[i\\ldots j])$ for some fixed pair $(i,j)$ satisfying $i<j.$ We'll\ndo this by constructing $a$ one element at a time.\nFirst, we start with a sequence consisting of $a[i]$ only. Then $a[i+1]$ can be\neither greater than $a[i]$ or less than $a[i],$ contributing $0$ or $1$\ninversion. Then $a[i+2]$ can take on any of three different values relative to\n$a[i]$ and $a[i+1],$ contributing anywhere from $0$ to $2$ inversions.\nContinuing in this fashion, the possible numbers of inversions in the\nsub-permutation $a[i\\ldots j-1]$ can be represented by the polynomial product\n$$\\prod_{t=1}^{j-i}\\left(\\sum_{u=0}^{t-1}x^u\\right).$$\nThis is known as a generating function because we are encoding a sequence\nusing a polynomial. If we expand it and group together the terms with the same\npower of $x,$ then a term in the form $cx^d$ means that there are exactly $c$\npermutations with $d$ inversions.\nAdding $a[j]$ contributes $j-i$ inversions regardless of how many inversions\n$a[i\\ldots j-1]$ has. Then we should add the remaining elements of the\npermutation, each of which can go anywhere in the sorted order. Thus, the final\nresult is given by the generating function\n$$\\prod_{t=1}^{n}\\left(\\sum_{u=0}^{t-1}x^u\\right)\\cdot \\frac{1}{\\sum_{u=0}^{j-i}x^u}\\cdot x^{j-i}.$$\nThe first part of this product does not depend on $i$ or $j,$ and we can\ncalculate it in $O(N^3)$ time with prefix sums. We can divide it by\n$\\sum_{u=0}^{j-i}x^u$ in $O(N^2)$ time by reversing the process we used to\nmultiply.\nAfter dividing, all we need is the coefficient of $x^{k-(j-i)}.$ Since the\nproduct depends only on $j-i,$ we only need to do $N$ different divisions.\nAlternatively, we can maintain prefix and suffix products without needing to do\ndivision. The process for $i>j$ is almost exactly the same, except $a[j]$\ncontributes $0$ inversions rather than $i-j.$\nThe whole solution runs in $O(N^3)$ time and $O(N^2)$ memory. My code follows. It turns out that $M$\nbeing prime is irrelevant ...\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi; \n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \n#define pb push_back\n#define rsz resize\n#define sz(x) int(x.size())\n \nvoid setIO(string name) {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfreopen((name+\".in\").c_str(),\"r\",stdin);\n\tfreopen((name+\".out\").c_str(),\"w\",stdout);\n}\n\nint MOD;\nint n,k;\n\ntypedef int T;\nstruct mi {\n\tT val; \n\tmi() { val = 0; }\n\tmi(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tmi& operator+=(const mi& m) { \n\t\tif ((val += m.val) >= MOD) val -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((val -= m.val) < 0) val += MOD; \n\t\treturn *this; }\n};\ntypedef vector<mi> vmi;\n \nvoid ad(vmi& a, int b) { // multiply by (x^0+x^1+...+x^{b-1})\n\ta.rsz(sz(a)+b-1);\n\tR0F(i,sz(a)-b) a[i+b] -= a[i];\n\tFOR(i,1,sz(a)) a[i] += a[i-1];\n}\nvoid sub(vmi& a, int b) {\n\tROF(i,1,sz(a)) a[i] -= a[i-1];\n\tF0R(i,sz(a)-b) a[i+b] += a[i];\n\ta.rsz(sz(a)-b+1); \n}\nmi get(vmi& a, int b) {\n\tif (b < 0 || b >= sz(a)) return 0;\n\treturn a[b];\n}\n \nint main() {\n\tsetIO(\"treedepth\"); \n\tcin >> n >> k >> MOD;\n\tvmi v = {1}; FOR(i,1,n+1) ad(v,i);\n\tvmi ans(n,v[k]);\n\tFOR(dif,1,n) {\n\t\tsub(v,dif+1);\n\t\tmi x = get(v,k-dif), y = get(v,k);\n\t\tad(v,dif+1);\n\t\tF0R(a,n-dif) {\n\t\t\tans[a] += x;\n\t\t\tans[a+dif] += y;\n\t\t}\n\t}\n\tF0R(i,n) cout << ans[i].val << ' ';\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 0 192603497",
        "output": "1 2 3",
        "explanation": "Here, the only permutation is $a=\\{1,2,3\\}.$"
      },
      {
        "input": "3 1 144408983",
        "output": "3 4 4",
        "explanation": "Here, the two permutations are $a=\\{1,3,2\\}$ and $a=\\{2,1,3\\}.$"
      }
    ],
    "description_no_samples": "For the new year, Farmer John decided to give his cows a festive binary search tree\n(BST)! \n\nTo generate the BST, FJ starts with a permutation $a=\\{a_1,a_2,\\ldots,a_N\\}$\nof the integers $1\\ldots N$, where $N\\le 300$.  He then runs the following\npseudocode with arguments $1$ and $N.$\n\n\ngenerate(l,r):\n  if l > r, return empty subtree;\n  x = argmin_{l <= i <= r} a_i; // index of min a_i in {a_l,...,a_r}\n  return a BST with x as the root, \n    generate(l,x-1) as the left subtree,\n    generate(x+1,r) as the right subtree;\n\nFor example, the permutation $\\{3,2,5,1,4\\}$ generates the following BST:\n\n\n    4\n   / \\\n  2   5\n / \\ \n1   3\n\nLet $d_i(a)$ denote the depth of node $i$ in the tree corresponding to $a,$ \nmeaning the number of nodes on the path from $a_i$ to the root. In the above\nexample, $d_4(a)=1, d_2(a)=d_5(a)=2,$ and $d_1(a)=d_3(a)=3.$\n\nThe number of inversions of $a$ is equal to the number of pairs of integers\n$(i,j)$ such that $1\\le i<j\\le N$ and $a_i>a_j.$ The cows know that the $a$ that\nFJ will use to generate the BST has exactly $K$ inversions\n$(0\\le K\\le \\frac{N(N-1)}{2})$.  Over all $a$ satisfying this condition, compute\nthe remainder when $\\sum_ad_i(a)$ is divided by $M$ for each $1\\le i\\le N.$\n\nINPUT FORMAT:\nThe only line of input consists of three space-separated integers $N, K,$ and\n$M$, followed by a new line. $M$ will be a prime number in the range\n$[10^8,10^9+9].$\n\nOUTPUT FORMAT:\nPrint $N$ space-separated integers denoting $\\sum_ad_i(a)\\pmod{M}$ for each \n$1\\le i\\le N.$\n\nBATCHING:\nTest cases 3-4 satisfy $N\\le 8.$ Test cases 5-7 satisfy $N\\le 20.$ Test cases 8-10 satisfy $N\\le 50.$ \n\n",
    "num_samples": 2
  },
  "818_platinum_cow_gymnasts": {
    "name": "Cow Gymnasts",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=818",
    "test_data_link": "http://www.usaco.org/current/data/gymnasts_platinum_feb18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_gymnasts_platinum_feb18.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "818",
    "problem_id": "818_platinum_cow_gymnasts",
    "description": "Bored of farm life, the cows have sold all their earthly possessions and joined\nthe crew of a traveling circus. So far, the cows had been given easy acts:\njuggling torches, walking tightropes, riding unicycles -- nothing a handy-hoofed\ncow couldn't handle.  However, the ringmaster wants to create a much more\ndramatic  act for their next show.\n\nThe stage layout for the new act involves $N$ platforms arranged in a circle. \nOn each platform, between $1$ and $N$ cows must form a stack, cow upon cow upon\ncow. When the ringmaster gives the signal, all stacks must simultaneously fall\nclockwise, so that the bottom cow in a stack doesn't move, the cow above her\nmoves one platform clockwise, the next cow moves two platforms clockwise, and so\nforth.  Being accomplished gymnasts, the cows know they will have no trouble\nwith the technical aspect of this act. The various stacks of cows will not\n\"interfere\" with each other as they fall, so every cow will land on the intended\nplatform. All of the cows landing on a platform form a new stack, which does not\nfall over.\n\nThe ringmaster thinks the act will be particularly dramatic if after the stacks\nfall, the new stack on each platform contains the same number of cows as the\noriginal stack on that platform.  We call a configuration of stack sizes\n\"magical\" if it satisfies this condition.  Please help the cows by computing the\nnumber of magical configurations. Since this number may be very large, compute\nits remainder modulo $10^9 + 7$.\n\nTwo configurations are considered distinct if there is any platform for which\nthe configurations assign a different number of cows. \n\nINPUT FORMAT:\nThe input is a single integer, $N$ ($1 \\leq N \\leq 10^{12}$).\n\nOUTPUT FORMAT:\nA single integer giving the number of magical configurations modulo $10^9 + 7$.\n\nSAMPLE INPUT:\n4\nSAMPLE OUTPUT: \n6\n\nFor $N = 4$, the valid configurations are $(1,1,1,1)$, $(2,2,2,2)$, $(3,3,3,3)$,\n$(4,4,4,4)$, $(2,3,2,3)$, and $(3,2,3,2)$.\n\nProblem credits: Dhruv Rohatgi\n",
    "num_tests": 12,
    "solution": "\n(Analysis by  Dhruv Rohatgi )\nConsider any magical configuration. Let $m$ be the minimum number of cows in any\nstack, and consider some stack $i$ achieving this minimum. Then the $m-1$ stacks\nbefore it will all \"contribute\": that is, one cow from each of these stacks will\nland on stack $i$. But of course stack $i$ contributes to itself, so we have\nalready accounted for all $m$ cows which land on stack $i$. This means that\nstack $i-m$ (wrapping around the index if necessary) cannot contribute to stack\n$m$. So stack $i-m$ must also have only $m$ cows. Applying the above proof\nrepeatedly, we see that if $j \\equiv i \\pmod{g}$, where $g = \\gcd(N,m)$, then\nstack $j$ must have only $m$ cows.\nWe will show inductively that none of stacks $i-1, i-2, \\dots, i-g+1$ can have\nmore than $m+1$ cows. Start with stack $i-1$. If it had more than $m+1$ cows,\nthen it would contribute to stack $i+m$. But we know that stack $i+m$ has only\n$m$ cows, and we know that these $m$ cows come from stacks\n$i+1, i+2, \\dots, i+m$. So this is impossible.\nMore generally, consider stack $i-k$ for some $k>0$. There are two cases.\nIf stack $i-k+1$ has $m$ cows, then the logic we described for stack $i-1$\napplies: stack $i-k$ cannot contribute to stack $i-k+m+1$, so it must have at\nmost $m+1$ cows. \nIf on the other hand stack $i-k+1$ does not have $m$ cows, then by our inductive\nhypothesis it must have $m+1$ cows. This implies that every stack $j$, where\n$j \\equiv i-k+1 \\pmod{g}$, must have exactly $m+1$ cows: by a parallel\ninduction, we know that every such stack can have at most $m+1$ cows, and by the\nprevious periodicity fact we proved above, if any such stack had $m$ cows then\nstack $i-k+1$ would also have $m$ cows.\nSo in particular, stack $i-k+m+1$ has exactly $m+1$ cows. We know that each of\nthe stacks $i-k+2, i-k+3, \\dots, i-k+m+1$ contribute to stack $i-k+m+1$, simply\nbecause they all have at least $m$ cows. And we know that stack $i-k+1$\ncontributes, since it has $m+1$ cows. So stack $i-k$ must not contribute to\nstack $i-k+m+1$. We conclude that stack $i-k$ cannot have more than $m+1$ cows.\nThis argument shows that every stack has either $m$ or $m+1$ cows. Together with\nthe periodicity fact, this means that for every $j$, stack $j$ has the same\nnumber of cows as stack $j+g$. So the configuration is periodic with period $g$.\nIt is not hard to verify that any configuration satisfying these two properties\nis magical.\nNow that we have characterized magical configurations, it remains to count them.\nFix some $m$, and assume that $m < N$. Then by our characterization above, there\nare $2^{\\gcd(N,m)} - 1$ magical configurations for which the minimum number of\ncows in any stack is $m$. Taking care of the case $m = N$, the total number of\nmagical configurations is $$2 - 2^N + \\sum_{m=1}^N \\left ( 2^{\\gcd(m,N)} - 1 \\right ).$$ Calculating\nthis sum directly is too slow, and only receives partial credit. To speed it up,\nobserve that for a fixed gcd $g$, the summand $2^g$ is fixed. Furthermore, the\nnumber of times this summand appears in the sum is the number of $m$ with\n$1 \\leq m \\leq N$ and $\\gcd(m,N) = g$. Equivalently, it is the number of $m'$\nwith $1 \\leq m' \\leq \\frac{N}{g}$ and $\\gcd(m', \\frac{N}{g}) = 1$. But this is\nprecisely $\\varphi(\\frac{N}{g})$, the Euler totient function of $\\frac{N}{g}$.\nTherefore the sum is equal to\n$$2 - N - 2^N + \\sum_{g \\mid N} 2^g \\varphi(\\frac{N}{g}).$$\nTo efficiently compute this sum, we start by prime factorizing $N$ in\n$O(\\sqrt{N})$ time: simply divide out all prime divisors of magnitude at most\n$\\sqrt{N}$; the remaining number must be either $1$ or prime, since $N$ cannot\nhave multiple prime factors of magnitude greater than $\\sqrt{N}$.\nNow the $O(\\sqrt{N})$ divisors of $N$ can be enumerated quickly. For each\ndivisor, we use fast exponentiation to compute $2^g$, and we compute the totient\nfunction using the formula\n$$\\varphi(p_1^{e_1}p_2^{e_2}\\cdots p_i^{e_i}) = p_1^{e_1-1}p_2^{e_2-1}\\cdots p_i^{e_i-1}(p_1-1)(p_2-1)\\cdots(p_i-1).$$\nA simple (though by no means tight) bound on the overall time complexity is $O(\\sqrt{N}\\log N)$. Below is an implementation\nof the algorithm described above. Note that depth-first search is used to\niterate over the divisors of $N$, allowing the totient function to be computed\nwith only constant overhead.\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n \n \nvector<long long> p;\nvector<int> e;\nint ans;\nlong long origN;\n \nint fexp(int a,long long e)\n{\n\tif(e==0) return 1;\n\tint tmp = fexp(a,e/2);\n\ttmp = (tmp*((long long)tmp))%MOD;\n\tif(e&1) tmp = (tmp*((long long)a))%MOD;\n\treturn tmp;\n}\n \nlong long gcd(long long a,long long b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n \nvoid dfs(int i,long long cdiv, long long sdiv, long long smult)\n{\n\tif(i == p.size())\n\t{\n\t\tif(cdiv < origN)\n\t\t\tans = (ans + fexp(2,cdiv)*((long long)((origN/(cdiv*sdiv))*smult)))%MOD;\n\t\treturn;\n\t}\n\tfor(int j=0;j<e[i];j++)\n\t{\n\t\tdfs(i+1,cdiv,sdiv*p[i],smult*(p[i]-1));\n\t\tcdiv *= p[i];\n\t}\n\tdfs(i+1,cdiv,sdiv,smult);\n}\n \nint main()\n{\n\tlong long N;\n\tcin >> N;\n\torigN = N;\n\tint i = 2;\n\tlong long bound = N;\n\tfor(i=2;i*((long long)i) < bound;i++)\n\t\tif(N%i == 0)\n\t\t{\n\t\t\tint mult = 0;\n\t\t\twhile(N%i == 0)\n\t\t\t{\n\t\t\t\tmult++;\n\t\t\t\tN /= i;\n\t\t\t}\n\t\t\tp.push_back(i);\n\t\t\te.push_back(mult);\n\t\t}\n\tif(i*((long long)i) == bound && N%i == 0)\n\t{\n\t\tint mult = 0;\n\t\twhile(N%i == 0)\n\t\t{\n\t\t\tmult++;\n\t\t\tN /= i;\n\t\t}\n\t\tp.push_back(i);\n\t\te.push_back(mult);\n\t}\n\tif(N > 1)\n\t{\n\t\tp.push_back(N);\n\t\te.push_back(1);\n\t}\n\tdfs(0,1,1,1);\n\tans = (ans + MOD - (origN - 1)%MOD)%MOD;\n\tans = (ans+1)%MOD;\n\tcout << ans << '\\n';\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4",
        "output": "6",
        "explanation": ""
      }
    ],
    "description_no_samples": "Bored of farm life, the cows have sold all their earthly possessions and joined\nthe crew of a traveling circus. So far, the cows had been given easy acts:\njuggling torches, walking tightropes, riding unicycles -- nothing a handy-hoofed\ncow couldn't handle.  However, the ringmaster wants to create a much more\ndramatic  act for their next show.\n\nThe stage layout for the new act involves $N$ platforms arranged in a circle. \nOn each platform, between $1$ and $N$ cows must form a stack, cow upon cow upon\ncow. When the ringmaster gives the signal, all stacks must simultaneously fall\nclockwise, so that the bottom cow in a stack doesn't move, the cow above her\nmoves one platform clockwise, the next cow moves two platforms clockwise, and so\nforth.  Being accomplished gymnasts, the cows know they will have no trouble\nwith the technical aspect of this act. The various stacks of cows will not\n\"interfere\" with each other as they fall, so every cow will land on the intended\nplatform. All of the cows landing on a platform form a new stack, which does not\nfall over.\n\nThe ringmaster thinks the act will be particularly dramatic if after the stacks\nfall, the new stack on each platform contains the same number of cows as the\noriginal stack on that platform.  We call a configuration of stack sizes\n\"magical\" if it satisfies this condition.  Please help the cows by computing the\nnumber of magical configurations. Since this number may be very large, compute\nits remainder modulo $10^9 + 7$.\n\nTwo configurations are considered distinct if there is any platform for which\nthe configurations assign a different number of cows. \n\nINPUT FORMAT:\nThe input is a single integer, $N$ ($1 \\leq N \\leq 10^{12}$).\n\nOUTPUT FORMAT:\nA single integer giving the number of magical configurations modulo $10^9 + 7$.\n\n",
    "num_samples": 1
  },
  "649_platinum_bull_in_a_china_shop": {
    "name": "Bull in a China Shop",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=649",
    "test_data_link": "http://www.usaco.org/current/data/bcs_platinum_open16.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_bcs_platinum_open16.html",
    "contest_link": "http://www.usaco.org/index.php?page=open16results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "649",
    "problem_id": "649_platinum_bull_in_a_china_shop",
    "description": "Farmer John has decided his home needs more decoration.  Visiting the local\nchina shop, he finds a delicate glass cow figurine that he decides to purchase,\nknowing that it will fit perfectly on the mantel above his fireplace.\n\nThe shape of the cow figurine is described by an $N \\times M$ grid of characters\nlike the one below ($3 \\leq N, M \\leq 500$), where lowercase letter characters\nare each part of the figurine (indicating different colors) and '.' characters\nare not.\n\n\n...............\n...............\nx..x...........\nxxxx...........\nxxxxaaaaaaa...\n.xx.aaaaaaaaa..\n....aaaaaaa.aa.\n....ll...ll....\n....vv...vv....\n...............\n\nUnfortunately, right before FJ can make his purchase, a bull runs through the\nshop  and breaks not only FJ's figurine, but many of the other glass objects on\nthe shelves as well!  FJ's figurine breaks into 3 pieces, which quickly become\nlost  among $K$ total pieces lying on the ground ($4 \\leq K \\leq 100$).  Each of\nthe $K$ pieces is described by a grid of characters, just like the original\nfigurine.\n\nPlease help FJ determine how many sets of 3 pieces (out of the $K$ on the floor)\ncould be glued back together to mend his broken figurine.  \n\nThe pieces on the ground might have been flipped vertically or horizontally, or\nrotated by some multiple of 90 degrees. Therefore, given the original grid as\nwell as $K$ grids describing pieces, you want to find sets of 3 pieces that can\nbe joined together to form the original picture, allowing the pieces to be\ntranslated, flipped, or rotated multiples of 90 degrees.  When then\nsuperimposed, the 3 pieces should exactly form the original picture, with each\ncolored square in the original picture represented in exactly one of the pieces.\n\nINPUT FORMAT:\nThe first line contains a single integer $K$. Following that will be $K + 1$\npiece descriptions.  The first description will describe the original glass cow,\nthe following $K$ descriptions will be of the broken pieces.\n\nEach description begins with a line containing two integers $R$ and $C$\n($1 \\le R, C \\le 100$).  The following $R$ lines contain $C$ lowercase alphabet\ncharacters describing the color of each cell.  Each piece will be\nhorizontally/vertically connected and have at least one non-empty cell.\n\nOUTPUT FORMAT:\nOutput the number of triples $i, j, k$ ($i < j < k$) such that pieces $i$, $j$,\nand $k$ can be arranged to form the original glass cow.\n\nSAMPLE INPUT:\n5\n5 5\naaaaa\n..a..\nbbabb\n..a..\naaaaa\n3 5\n..abb\n..a..\naaaaa\n5 2\na.\na.\naa\na.\na.\n1 2\nbb\n1 5\nbbabb\n2 5\naaaaa\n..a..\nSAMPLE OUTPUT: \n3\n\nThe three solutions use pieces $(0, 1, 2)$, $(0, 2, 4)$, $(1, 3, 4)$.\n\nNote that this problem has a time limit of 6 seconds per test case (and twice that for Java and Python submissions).\n\n\nProblem credits: Brian Dean\n",
    "num_tests": 10,
    "solution": "\n(Analysis by Mark Gordon)\nThe most basic approach to this problem would loop over tuples of three pieces\nand try all offsets and orientations of the pieces to try and make the figurine.\nObviously, this approach would be too slow with $k^3$ tuples and $(8N^2)^3$\nways to arrange them.\nHowever,  The need to try all offsets can be eliminated by simply trying the\noffset such that the bottom most (breaking ties by rightmost) uncovered cell is\ncovered by the new piece.  We can do this because this cell must eventually be\ncovered and there is at most one way to do it for a given piece and orientation.\nThis observation alone can bring us down to a $O(8k^3N^2)$ solution.  The next\npiece of the puzzle is to use\npolynomial\nhashing to eliminate a $O(k)$ factor on the critical path.  After placing\nthe first two pieces we can calculate the appropriate offset of the final piece\nand quickly test if its hash is one of the input pieces.\nThe final bit of the puzzle is how to calculate offsets quickly.  This amounts\nto being able to quickly calculate the position of the bottom most, right most\nuncovered cell.  This can be done in $O(log N)$ time by precomputing the suffix sums in \nRow Major Order and binary searching to\nfind the last non-zero suffix sum when subtracting out the suffix sums of already placed pieces.0\nHere's my solution to this problem annotated with what each section of code aims\nto accomplish.\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef vector<string> pat;\n\nint POLYMOD[2] = {\n  975919579,\n  975979579,\n};\n\nint POLYMUL[2] = {\n  382737283,\n  382878283,\n};\n\n#define MAXCOL 1010\n#define MAXROW 510\n\n#define HASHES 2\n#define MAXPOW (MAXROW * MAXCOL)\n\nint POWTAB[HASHES][MAXPOW];\n\nvoid init_tab() {\n  if (POWTAB[0][0]) {\n    return;\n  }\n  for (int i = 0; i < HASHES; i++) {\n    for (int j = POWTAB[i][0] = 1; j < MAXPOW; j++) {\n      POWTAB[i][j] = (1ll * POWTAB[i][j - 1] * POLYMUL[i]) % POLYMOD[i];\n    }\n  }\n}\n\n/* Tracks a polynomial hash over a 2D array. */\nstruct xhash {\n  xhash() {\n    init_tab();\n    memset(H, 0, sizeof(H));\n  }\n\n  xhash(const pat& p) {\n    init_tab();\n    memset(H, 0, sizeof(H));\n\n    /* Calculate the hash of the given input matrix. We linearize the array by\n     * setting a[r * MAXCOL + c] = p[i][j] and then apply a standard polynomial\n     * hash. */\n    for (int i = 0; i < p.size(); i++) {\n      for (int j = 0; j < p[0].size(); j++) {\n        if (p[i][j] == '.') {\n          continue;\n        }\n\n        /* We set v this way to ensure that v_1 - v_2 could never represent a\n         * valid character.  This is important for ensuring the integrity of\n         * subtracting two hashes. */\n        int v = 26 + (p[i][j] - 'a');\n        for (int k = 0; k < HASHES; k++) {\n          H[k] = (H[k] + 1ll * POWTAB[k][i * MAXCOL + j] * v) %\n                      POLYMOD[k];\n        }\n      }\n    }\n  }\n\n  void offset(int r, int c) {\n    /* Offsetting the matrix by (r, c) translates into offsetting the\n     * linearized array by r * MAXCOL + c.  Therefore we multiply each hash\n     * by x^(r * MAXCOL + c). */\n    for (int i = 0; i < HASHES; i++) {\n      H[i] = (1ll * H[i] * POWTAB[i][r * MAXCOL + c]) % POLYMOD[i];\n    }\n  }\n\n  /* Compute the difference of hashes.  This gives you a hash of what would\n   * remain in *this if you got rid of everything present in x.  In the case\n   * that x isn't actually a subset of *this the hash should just represent\n   * garbage and won't get matched. */\n  xhash operator-(const xhash& x) const {\n    xhash nh;\n    for (int i = 0; i < HASHES; i++) {\n      nh.H[i] = H[i] - x.H[i];\n      if (nh.H[i] < 0) {\n        nh.H[i] += POLYMOD[i];\n      }\n    }\n    return nh;\n  }\n\n  bool operator==(const xhash& x) const {\n    return !memcmp(H, x.H, sizeof(H));\n  }\n\n  bool operator<(const xhash& x) const {\n    return memcmp(H, x.H, sizeof(H)) < 0;\n  }\n\n  int H[HASHES];\n};\n\n/* For use in C++'s unordered_map. */\nstruct xhash_downhash {\n  int operator()(const xhash& h) const {\n    return h.H[0];\n  }\n};\n\n/* Vertically flips the pattern. */\nvoid vflip(pat& p) {\n  int R = p.size();\n  for (int i = 0; i < R - i - 1; i++) {\n    p[i].swap(p[R - i - 1]);\n  }\n}\n\n/* Rotates the pattern 90 degrees. */\nvoid rotate(pat& p) {\n  int R = p.size();\n  int C = p[0].size();\n  pat op(C, string(R, '.'));\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      op[C - j - 1][i] = p[i][j];\n    }\n  }\n  p = op;\n}\n\n/* Read in a pattern and canonicalize it. */\npat read_pat() {\n  int R, C;\n  cin >> R >> C;\n\n  pat res(R);\n  for (int i = 0; i < R; i++) {\n    cin >> res[i];\n  }\n\n  /* Remove unneeded padding from the sides. */\n  int mnr = R, mxr = 0;\n  int mnc = C, mxc = 0; \n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      if (res[i][j] != '.') {\n        mnr = min(mnr, i);\n        mxr = max(mxr, i + 1);\n        mnc = min(mnc, j);\n        mxc = max(mxc, j + 1);\n      }\n    }\n  }\n\n  pat nres;\n  for (int i = mnr; i < mxr; i++) {\n    nres.push_back(res[i].substr(mnc, mxc - mnc));\n  }\n\n  /* Try all orientations and take the lexicographically least one.  This\n   * ensures that all equivalant piece representations are actually equal. */\n  res = nres;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 4; j++) {\n      if (nres < res) {\n        res = nres;\n      }\n      rotate(nres);\n    }\n    vflip(nres);\n  }\n  return res;\n}\n\n\ntypedef vector<vector<int> > sum_table;\n\nsum_table target_sums;\nvector<sum_table> piece_sums;\n\n/* Calculate the number of non-empty entries after every position in the\n * linearized array.  This gets used in find_offset later. */\nsum_table calc_sums(const pat& p) {\n  int N = p.size();\n  int M = p[0].size();\n  sum_table sums(N, vector<int>(M));\n\n  int lst = 0;\n  for (int i = N - 1; i >= 0; i--) {\n    for (int j = M - 1; j >= 0; j--) {\n      if (p[i][j] != '.') {\n        lst++;\n      }\n      sums[i][j] = lst;\n    }\n  }\n  return sums;\n}\n\n/* Efficiently find the last non-zero position in base after subtracting\n * (possibly) several other matricies. */\npair<int, int> find_offset(const sum_table& base,\n                           const vector<int>& subtract_inds = {},\n                           const vector<pair<int, int> >& offsets = {}) {\n  /* Binary search over the linearized array. */\n  int N = base.size();\n  int M = base[0].size();\n  int lo = 0;\n  int hi = N * M - 1;\n  while (lo < hi) {\n    int md = (lo + hi + 1) / 2;\n    int r = md / M;\n    int c = md % M;\n\n    /* Calculate how many non-zero entries there are after (r, c) in the\n     * linearized array. */\n    int val = base[r][c];\n    for (int i = 0; i < subtract_inds.size(); i++) {\n      int j = subtract_inds[i];\n      int er = r - offsets[i].first;\n      int ec = c - offsets[i].second;\n      int PN = piece_sums[j].size();\n      int PM = piece_sums[j][0].size();\n      if (ec >= PM) {\n        er++;\n        ec = 0;\n      }\n      if (er >= PN) {\n        /* Do nothing. */\n      } else if (er < 0) {\n        val -= piece_sums[j][0][0];\n      } else {\n        val -= piece_sums[j][er][max(0, ec)];\n      }\n    }\n\n    /* Search right if there are more non-zero entries, otherwise search left.\n     */\n    if (val) {\n      lo = md;\n    } else {\n      hi = md - 1;\n    }\n  }\n\n  return make_pair(lo / M, lo % M);\n}\n\nint main() {\n  freopen(\"bcs.in\", \"r\", stdin);\n  freopen(\"bcs.out\", \"w\", stdout);\n  int K; cin >> K;\n  pat target = read_pat();\n\n  int R = target.size();\n  int C = target[0].size();\n  xhash target_hash = target;\n  target_sums = calc_sums(target);\n\n  /* Read in the pieces into a map after canonicalization.  Keep track of\n   * how many times an equivalant piece occurs and deduplicate. */\n  map<pat, int> piece_map;\n  for (int i = 0; i < K; i++) {\n    piece_map[read_pat()]++;\n  }\n\n  /* Build data structures based on the deduplicated pieces in each of\n   * their orientations. */\n  vector<int> piece_counts;\n  vector<pair<int, int> > piece_offsets;\n  vector<int> piece_index;\n  vector<xhash> piece_hashes;\n\n  unordered_map<xhash, int, xhash_downhash> the_hash;\n  for (auto it : piece_map) {\n    pat p = it.first;\n    int index = piece_counts.size();\n    piece_counts.push_back(it.second);\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < 4; k++) {\n        if (p.size() > R || p[0].size() > C) {\n          rotate(p);\n          continue;\n        }\n\n        xhash h(p);\n        piece_sums.push_back(calc_sums(p));\n        piece_offsets.push_back(find_offset(piece_sums.back()));\n        piece_hashes.push_back(h);\n        piece_index.push_back(index);\n\n        h.offset(R - piece_offsets.back().first,\n                 C - piece_offsets.back().second);\n\n        /* Deduplication ensures that no two pieces should have the same hash.\n         */\n        the_hash[h] = index;\n        rotate(p);\n      }\n      vflip(p);\n    }\n  }\n\n  set<tuple<int, int, int> > sols;\n  pair<int, int> base_1 = find_offset(target_sums);\n  for (int i = 0; i < piece_hashes.size(); i++) {\n    /* Find the offset so that the last item in piece_hashes[i] covers the last\n     * item in the target. */\n    pair<int, int> off_1 = base_1;\n    off_1.first -= piece_offsets[i].first;\n    off_1.second -= piece_offsets[i].second;\n    if (off_1.first < 0 || off_1.second < 0) {\n      continue;\n    }\n\n    xhash hash_1 = piece_hashes[i];\n    hash_1.offset(off_1.first, off_1.second);\n\n    pair<int, int> base_2 = find_offset(target_sums, {i}, {off_1});\n    for (int j = 0; j < piece_hashes.size(); j++) {\n      /* Find the offset so that the last uncovered item in * piece_hashes[j]\n       * covers the last still uncovered item in the target. */\n      pair<int, int> off_2 = base_2;\n      off_2.first -= piece_offsets[j].first;\n      off_2.second -= piece_offsets[j].second;\n      if (off_2.first < 0 || off_2.second < 0) {\n        continue;\n      }\n\n      xhash hash_2 = piece_hashes[j];\n      hash_2.offset(off_2.first, off_2.second);\n\n      /* Canonicalize the position of the last still uncovered item of the\n       * target so we can look up if we have a matching hash. */\n      pair<int, int> off_3 = find_offset(target_sums, {i, j}, {off_1, off_2});\n      if (off_3.first < 0 || off_3.second < 0) {\n        continue;\n      }\n      xhash hash_remains = target_hash - hash_1 - hash_2;\n      hash_remains.offset(R - off_3.first, C - off_3.second);\n\n      /* Check if we have a match, if we do insert it into the solutions list.\n       */\n      auto it = the_hash.find(hash_remains);\n      if (it != the_hash.end()) {\n        int L[3];\n        L[0] = piece_index[i];\n        L[1] = piece_index[j];\n        L[2] = it->second;\n        sort(L, L + 3);\n        sols.insert(make_tuple(L[0], L[1], L[2]));\n      }\n    }\n  }\n\n  /* Convert the solutions list into an actual result on the input array.  This\n   * takes into account the pieces that were deduplicated in the beginning. */\n  int result = 0;\n  for (auto sol : sols) {\n    int c0 = piece_counts[get<0>(sol)];\n    int c1 = piece_counts[get<1>(sol)];\n    int c2 = piece_counts[get<2>(sol)];\n    if (get<0>(sol) == get<2>(sol)) {\n      result += c0 * (c0 - 1) * (c0 - 2) / 6;\n    } else if (get<0>(sol) == get<1>(sol)) {\n      result += c0 * (c0 - 1) / 2 * c2;\n    } else if (get<1>(sol) == get<2>(sol)) {\n      result += c0 * c1 * (c1 - 1) / 2;\n    } else {\n      result += c0 * c1 * c2;\n    }\n  }\n  cout << result << endl;\n\n  return 0;\n}\n\n",
    "runtime_limit_sentences": [
      "\n\nNote that this problem has a time limit of 6 seconds per test case (and twice that for Java and Python submissions)."
    ],
    "memory_limit_sentences": [],
    "runtime_limit": 12,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5\n5 5\naaaaa\n..a..\nbbabb\n..a..\naaaaa\n3 5\n..abb\n..a..\naaaaa\n5 2\na.\na.\naa\na.\na.\n1 2\nbb\n1 5\nbbabb\n2 5\naaaaa\n..a..",
        "output": "3",
        "explanation": "The three solutions use pieces $(0, 1, 2)$, $(0, 2, 4)$, $(1, 3, 4)$.\n\nNote that this problem has a time limit of 6 seconds per test case (and twice that for Java and Python submissions)."
      }
    ],
    "description_no_samples": "Farmer John has decided his home needs more decoration.  Visiting the local\nchina shop, he finds a delicate glass cow figurine that he decides to purchase,\nknowing that it will fit perfectly on the mantel above his fireplace.\n\nThe shape of the cow figurine is described by an $N \\times M$ grid of characters\nlike the one below ($3 \\leq N, M \\leq 500$), where lowercase letter characters\nare each part of the figurine (indicating different colors) and '.' characters\nare not.\n\n\n...............\n...............\nx..x...........\nxxxx...........\nxxxxaaaaaaa...\n.xx.aaaaaaaaa..\n....aaaaaaa.aa.\n....ll...ll....\n....vv...vv....\n...............\n\nUnfortunately, right before FJ can make his purchase, a bull runs through the\nshop  and breaks not only FJ's figurine, but many of the other glass objects on\nthe shelves as well!  FJ's figurine breaks into 3 pieces, which quickly become\nlost  among $K$ total pieces lying on the ground ($4 \\leq K \\leq 100$).  Each of\nthe $K$ pieces is described by a grid of characters, just like the original\nfigurine.\n\nPlease help FJ determine how many sets of 3 pieces (out of the $K$ on the floor)\ncould be glued back together to mend his broken figurine.  \n\nThe pieces on the ground might have been flipped vertically or horizontally, or\nrotated by some multiple of 90 degrees. Therefore, given the original grid as\nwell as $K$ grids describing pieces, you want to find sets of 3 pieces that can\nbe joined together to form the original picture, allowing the pieces to be\ntranslated, flipped, or rotated multiples of 90 degrees.  When then\nsuperimposed, the 3 pieces should exactly form the original picture, with each\ncolored square in the original picture represented in exactly one of the pieces.\n\nINPUT FORMAT:\nThe first line contains a single integer $K$. Following that will be $K + 1$\npiece descriptions.  The first description will describe the original glass cow,\nthe following $K$ descriptions will be of the broken pieces.\n\nEach description begins with a line containing two integers $R$ and $C$\n($1 \\le R, C \\le 100$).  The following $R$ lines contain $C$ lowercase alphabet\ncharacters describing the color of each cell.  Each piece will be\nhorizontally/vertically connected and have at least one non-empty cell.\n\nOUTPUT FORMAT:\nOutput the number of triples $i, j, k$ ($i < j < k$) such that pieces $i$, $j$,\nand $k$ can be arranged to form the original glass cow.\n\n",
    "num_samples": 1
  }
}