{
  "735_1_bronze_the_lost_cow": {
    "name": "The Lost Cow",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=735",
    "test_data_link": "http://www.usaco.org/current/data/lostcow_bronze_open17.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_lostcow_bronze_open17.html",
    "contest_link": "http://www.usaco.org/index.php?page=open17results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "735",
    "problem_id": "735_1_bronze_the_lost_cow",
    "description": "Captain Jack is on a treasure hunt and needs to find the hidden treasure!\n\nLuckily, there is only one long trail stretching across the island, and Captain Jack knows that the treasure must be somewhere along this trail. If we imagine the trail as a number line, Captain Jack is currently at position $a$, and the treasure is at position $b$ (unknown to Captain Jack). If Captain Jack knew the exact location of the treasure, he could walk directly to it, covering a distance of $|a - b|$. However, it's a foggy night, and Captain Jack can't see anything. The only way for him to find the treasure is to walk back and forth until he eventually stumbles upon it.\n\nSeeking the best strategy for his search, Captain Jack reads some old pirate journals and is amused to learn that this exact problem was not only studied by navigators in the past but is actually known as the \"Hidden Treasure Problem\" (this is actually true!).\n\nThe recommended strategy for Captain Jack to locate the treasure is to first move to position $a+1$, then reverse course and move to position $a-2$, then to position $a+4$, and so forth, in a \"zig zag\" pattern, with each step moving twice the distance from his initial starting point as the previous. As noted in his readings, this method ensures he will at worst travel 9 times the direct distance $|a-b|$ between himself and the treasure before finding it (this is also true, and the factor of 9 is the smallest worst-case guarantee achievable).\n\nCaptain Jack is eager to verify this finding. Given $a$ and $b$, please compute the total distance he will travel according to the zig-zag search strategy above until he discovers the treasure.\n\nINPUT FORMAT:\nThe single line of input contains two distinct space-separated integers $a$ and $b$. Both are in the range $0 \\ldots 1,000$.\n\nOUTPUT FORMAT:\nPrint one line of output, containing the distance Captain Jack will travel to reach the treasure.",
    "num_tests": 10,
    "solution": "\nby Nathan Pinsker\nWe can simulate this problem by running each step of Farmer John's movement. At\neach step, we check Farmer John's starting position and his intended ending\nposition, and check to see whether that overlaps Bessie's position. If it does\nnot, then we add the full distance to a running total and move poor Farmer John\nback to his starting position. Otherwise, we add the distance between FJ's\ncurrent position and Bessie's position to the running total, and return that\ntotal as our answer.\nHere's Jonathan Paulson's code. See the comments for some more insight on what\nhe's doing:\n\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  ll x, y;\n  cin >> x >> y;\n\n  ll ans = 0;\n  ll by = 1;\n  ll dir = 1;\n  while(true) {\n    // dir == 1 means Farmer John is moving to the right, and\n    // dir == -1 means he is moving to the left.\n    if((dir==1 && x<=y && y<=x+by) || (dir==-1 && x-by<=y && y<=x)) {\n      // We found Bessie!\n      ans += abs(y-x);\n      cout << ans << endl;\n      break;\n    } else {\n      // Didn't find Bessie! Add to our running total the cost of\n      // moving 'by' units away from the start and back again.\n      // Then multiply our next move's length by 2 and switch direction.\n      ans += by*2;\n      by *= 2;\n      dir *= -1;\n    }\n  }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 6",
        "output": "9"
      }
    ],
    "description_no_samples": "Captain Jack is on a treasure hunt and needs to find the hidden treasure!\n\nLuckily, there is only one long trail stretching across the island, and Captain Jack knows that the treasure must be somewhere along this trail. If we imagine the trail as a number line, Captain Jack is currently at position $a$, and the treasure is at position $b$ (unknown to Captain Jack). If Captain Jack knew the exact location of the treasure, he could walk directly to it, covering a distance of $|a - b|$. However, it's a foggy night, and Captain Jack can't see anything. The only way for him to find the treasure is to walk back and forth until he eventually stumbles upon it.\n\nSeeking the best strategy for his search, Captain Jack reads some old pirate journals and is amused to learn that this exact problem was not only studied by navigators in the past but is actually known as the \"Hidden Treasure Problem\" (this is actually true!).\n\nThe recommended strategy for Captain Jack to locate the treasure is to first move to position $a+1$, then reverse course and move to position $a-2$, then to position $a+4$, and so forth, in a \"zig zag\" pattern, with each step moving twice the distance from his initial starting point as the previous. As noted in his readings, this method ensures he will at worst travel 9 times the direct distance $|a-b|$ between himself and the treasure before finding it (this is also true, and the factor of 9 is the smallest worst-case guarantee achievable).\n\nCaptain Jack is eager to verify this finding. Given $a$ and $b$, please compute the total distance he will travel according to the zig-zag search strategy above until he discovers the treasure.\n\nINPUT FORMAT:\nThe single line of input contains two distinct space-separated integers $a$ and $b$. Both are in the range $0 \\ldots 1,000$.\n\nOUTPUT FORMAT:\nPrint one line of output, containing the distance Captain Jack will travel to reach the treasure.",
    "num_samples": 1,
    "mapping": [
      "Farmer John -> Captain Jack",
      "Bessie -> the treasure",
      "x -> a",
      "y -> b",
      "path -> trail",
      "dark outside -> foggy night",
      "Lost Cow Problem -> Hidden Treasure Problem"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "546_1_bronze_bessie_gets_even": {
    "name": "Bessie Gets Even",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=546",
    "test_data_link": "http://www.usaco.org/current/data/geteven_bronze.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_geteven_bronze.html",
    "contest_link": "http://www.usaco.org/index.php?page=open15results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "546",
    "problem_id": "546_1_bronze_bessie_gets_even",
    "description": "RoboChef, a renowned culinary robot, is creating a new recipe to impress the judges at the Galactic Culinary Championship. To make it more challenging for his fellow competitors, he designed a recipe with a mathematical twist.\nRoboChef provides the expression $(A+P+P+L+E)(P+I+E)(S+A+U+C+E)$, involving seven variables $A,P,L,E,I,S,U$. Each variable is associated with a list of up to 20 integer quantities it can be, representing different ingredient amounts. RoboChef asks you to determine the number of different ways to assign quantities to the variables such that the entire expression results in an even total.\nINPUT FORMAT:\nThe first line of the input contains an integer $N$. The next $N$ lines each contain a variable and a possible quantity for that variable. Each variable will appear in this list at least once and at most 20 times. No possible quantity will be listed more than once for the same variable. All possible quantities will be in the range $-300$ to $300$.\n\nOUTPUT FORMAT:\nPrint a single integer, giving the number of ways to assign quantities to variables so the expression evaluates to an even result.",
    "num_tests": 10,
    "solution": "\n(Analysis by Nick Wu)\nIn a pure brute-force solution, we would try every possible combination of\nassignments of variables to values. There are 7 variables, with at most 20\nvalues per variable, for a total of $20^7$ combinations. This is over one\nbillion combinations to check, which is too many to check.\nOne approach you can try is to count the number of ways you can force the\nexpression to be odd. When checking if a combination is odd, you can immediately\nnote a couple things - for example, M must be odd. Also, if you recursively\nassign values to variables and you see that one of the three terms in the\nproduct is even, you can stop all combinations for variables that you haven't\nyet inspected.\nThere is a much faster approach though that removes the dependency on checking\ndifferent combinations. Since you want to check if the product is even or odd,\nthe important thing to know for each variable is how many even values that\nvariable can take on, and how many odd values that variable can take on. Once\nyou've done that, you can assign to each variable a parity and see if with those\nparities, the product is even. If so, you can count how many combinations there\nare with those parities, and then sum the parities.\nWith this approach, there are only $2^7=128$ combinations of parities to check,\nwhich is guaranteed to work quickly enough.\nHere is Mark Gordon's code:\n\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint num[256][2];\n\nbool is_even(int x) {\n  return x % 2 == 0;\n}\n\nint main() {\n  freopen(\"geteven.in\", \"r\", stdin);\n  freopen(\"geteven.out\", \"w\", stdout);\n\n  int N;\n  cin >> N;\n\n  for (int i = 0; i < N; i++) {\n    char letter;\n    int val;\n    cin >> letter >> val;\n\n    if (is_even(val)) {\n      num[letter][0]++;\n    } else {\n      num[letter][1]++;\n    }\n  }\n\n  int result = 0;\n\n  /* Try every possible way that the variables could be even or odd. */\n  for(int B = 0; B < 2; B++)\n  for(int E = 0; E < 2; E++)\n  for(int S = 0; S < 2; S++)\n  for(int I = 0; I < 2; I++)\n  for(int G = 0; G < 2; G++)\n  for(int O = 0; O < 2; O++)\n  for(int M = 0; M < 2; M++) {\n    if (is_even((B + E + S + S + I + E) * (G + O + E + S) * (M + O + O))) {\n      /* If the expression is even then add the number of variable assignments\n       * that have the variables odd/even.\n       */\n      result += num['B'][B] * num['E'][E] * num['S'][S] * num['I'][I] *\n                num['G'][G] * num['O'][O] * num['M'][M];\n    }\n  }\n  cout << result << endl;\n\n  return 0;\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "10\nA 2\nP 5\nL 7\nE 10\nI 16\nS 19\nA 3\nP 1\nE 9\nU 2",
        "output": "6"
      }
    ],
    "description_no_samples": "RoboChef, a renowned culinary robot, is creating a new recipe to impress the judges at the Galactic Culinary Championship. To make it more challenging for his fellow competitors, he designed a recipe with a mathematical twist.\nRoboChef provides the expression $(A+P+P+L+E)(P+I+E)(S+A+U+C+E)$, involving seven variables $A,P,L,E,I,S,U$. Each variable is associated with a list of up to 20 integer quantities it can be, representing different ingredient amounts. RoboChef asks you to determine the number of different ways to assign quantities to the variables such that the entire expression results in an even total.\nINPUT FORMAT:\nThe first line of the input contains an integer $N$. The next $N$ lines each contain a variable and a possible quantity for that variable. Each variable will appear in this list at least once and at most 20 times. No possible quantity will be listed more than once for the same variable. All possible quantities will be in the range $-300$ to $300$.\n\nOUTPUT FORMAT:\nPrint a single integer, giving the number of ways to assign quantities to variables so the expression evaluates to an even result.",
    "num_samples": 1,
    "mapping": [
      "Bessie -> RoboChef",
      "Farmer John -> fellow competitors",
      "B, E, S, I, G, O, M -> A, P, L, E, I, S, U",
      "expression (B+E+S+S+I+E)(G+O+E+S)(M+O+O) -> expression (A+P+P+L+E)(P+I+E)(S+A+U+C+E)",
      "list of integer values -> list of integer quantities",
      "even number result -> even total"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text.replace('B', 'A').replace('G', 'P').replace('M', 'U')\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "855_1_bronze_mixing_milk": {
    "name": "Mixing Milk",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=855",
    "test_data_link": "http://www.usaco.org/current/data/mixmilk_bronze_dec18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_mixmilk_bronze_dec18.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "855",
    "problem_id": "855_1_bronze_mixing_milk",
    "description": "In a world of magic and alchemy, Potion Master Arlin is known for crafting the most exquisite elixirs. To achieve the perfect balance of potency and flavor, he must carefully combine three different magical potions. Each potion is stored in a cauldron, which may vary in size and might not be completely filled. Arlin plans to pour potion from cauldron 1 to cauldron 2, from cauldron 2 to cauldron 3, from cauldron 3 to cauldron 1, and repeat this cycle until he completes 100 pour operations (meaning the 100th pour is from cauldron 1 to cauldron 2). During each pour from cauldron $a$ to cauldron $b$, as much potion is poured as possible until either cauldron $a$ is empty or cauldron $b$ is full. Can you help Potion Master Arlin determine how much potion remains in each cauldron after all the pours are completed?\n\nINPUT FORMAT:\nThe first line of the input file contains two space-separated integers: the capacity $c_1$ of the first cauldron, and the amount of potion $p_1$ in the first cauldron. Both $c_1$ and $p_1$ are positive and at most 1 billion, with $c_1 \\geq p_1$. The second and third lines are similar, containing capacities and potion amounts for the second and third cauldrons.\n\nOUTPUT FORMAT:\nPlease print three lines of output, giving the final amount of potion in each cauldron, after 100 pour operations.",
    "num_tests": 10,
    "solution": "\n(Analysis by  Dhruv Rohatgi )\nWe can simulate the pours one by one, keeping track of the amount of milk in\neach bucket. For example, if we pour from bucket $1$ into bucket $2$, and bucket\n$1$ has size $c_1$ and bucket $2$ has size $c_2$, and before the pour, bucket\n$1$ has $m_1$ units of milk and bucket $2$ has $m_2$ units, then the amount of\nmilk poured is $\\min(m_1, c_2 - m_2)$. Therefore after the pour, the amount of\nmilk in bucket $1$ is $m_1 - \\min(m_1, c_2 - m_2)$. And the amount of milk in\nbucket $2$ is $m_2 + \\min(m_1, c_2 - m_2)$. The formulas for pouring bucket $2$\ninto bucket $3$, or bucket $3$ into bucket $1$, are analogous.\nSince there are only $100$ pours, and each pour takes only a constant number of\narithmetic operations to simulate, this algorithm will run very fast.\nHere is Travis Hance's code:\n\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n \nvoid pour(int& c1, int& m1, int& c2, int& m2) {\n  int amt = min(m1, c2 - m2);\n  m1 -= amt;\n  m2 += amt;\n}\n \nint main() {\n  int c1, c2, c3;\n  int m1, m2, m3;\n  scanf(\"%d %d\", &c1, &m1);\n  scanf(\"%d %d\", &c2, &m2);\n  scanf(\"%d %d\", &c3, &m3);\n \n  for (int i = 0; i < 33; i++) {\n    pour(c1, m1, c2, m2);\n    pour(c2, m2, c3, m3);\n    pour(c3, m3, c1, m1);\n  }\n  pour(c1, m1, c2, m2);\n \n  printf(\"%d\\n%d\\n%d\\n\", m1, m2, m3);\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "10 3\n11 4\n12 5",
        "output": "0\n10\n2"
      }
    ],
    "description_no_samples": "In a world of magic and alchemy, Potion Master Arlin is known for crafting the most exquisite elixirs. To achieve the perfect balance of potency and flavor, he must carefully combine three different magical potions. Each potion is stored in a cauldron, which may vary in size and might not be completely filled. Arlin plans to pour potion from cauldron 1 to cauldron 2, from cauldron 2 to cauldron 3, from cauldron 3 to cauldron 1, and repeat this cycle until he completes 100 pour operations (meaning the 100th pour is from cauldron 1 to cauldron 2). During each pour from cauldron $a$ to cauldron $b$, as much potion is poured as possible until either cauldron $a$ is empty or cauldron $b$ is full. Can you help Potion Master Arlin determine how much potion remains in each cauldron after all the pours are completed?\n\nINPUT FORMAT:\nThe first line of the input file contains two space-separated integers: the capacity $c_1$ of the first cauldron, and the amount of potion $p_1$ in the first cauldron. Both $c_1$ and $p_1$ are positive and at most 1 billion, with $c_1 \\geq p_1$. The second and third lines are similar, containing capacities and potion amounts for the second and third cauldrons.\n\nOUTPUT FORMAT:\nPlease print three lines of output, giving the final amount of potion in each cauldron, after 100 pour operations.",
    "num_samples": 1,
    "mapping": [
      "Farmer John -> Potion Master Arlin",
      "dairy cows -> magical potions",
      "buckets -> cauldrons",
      "milk -> potion",
      "m1, m2, m3 -> p1, p2, p3"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "430_1_bronze_odometer": {
    "name": "Odometer",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=430",
    "test_data_link": "http://www.usaco.org/current/data/odometer_bronze.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_odometer_bronze.html",
    "contest_link": "http://www.usaco.org/index.php?page=open14results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=open14problems",
    "problem_level": "bronze",
    "cp_id": "430",
    "problem_id": "430_1_bronze_odometer",
    "description": "Astronauts aboard the space station are monitoring a communication signal. The signal strength is represented as an integer, starting at S (100 <= S <= 10^16) at the beginning of the observation and ending at T (S <= T <= 10^16) at the end. Whenever the signal strength displays a 'noteworthy' value (including at the start and end of the observation) the astronauts record it. A value is 'noteworthy' if when you look at all its digits except for leading zeros, all of these are the same except for one single digit that is different. For example, the values 77787 and 220 are noteworthy, while the values 6886 and 44444 are not.\n\nHelp the astronauts count how many times they will record a noteworthy signal during the observation period.\n\nFor half of the test cases, the constraint S <= T <= 10^6 will hold. Note that to store a number as large as 10^16, you will need a 64-bit integer data type such as a \"long long\" in C/C++.\n\nPROBLEM NAME: space_signal_variation\n\nINPUT FORMAT:\n\n* Line 1: The first line will contain two integers, S and T, separated by a space.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer containing how many times the astronauts will record a noteworthy signal during the observation.",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Odometer by Nathan Pinsker\n\nAlthough the numbers we are working with can be quite large (up to 10^16!) \r\nit actually turns out that the number of interesting numbers is quite small. In \r\nfact, we can construct all such numbers by taking every number with repeated \r\ndigits (e.g. 3333333333) and changing exactly one digit, then checking whether \r\nthe new number is between X and Y. There are at most 17 digits in our number \r\nthat we can change, and there are 9 possible new digits to change it to, so the \r\nnumber of interesting numbers we could possibly find is about 17*9, which is \r\ndefinitely small enough to deal with. We can solve this problem by actually \r\nconstructing all possible numbers composed of a single unique digit, then \r\nbrute-force changing these numbers in every possible allowed way, and checking \r\neach of these numbers to see if it is in the interval [X, Y].\r\n\r\nBelow is Mark Gordon's solution. He uses the variable 'sz' to denote the size \r\nof the number he is considering, 'd0' to denote the digit of the original \r\nnumber, and 'd1' to denote the new digit's value.  A full list of all 10774\r\ninteresting numbers within the constraints of this problem is given here.\r\n\r\n\r\n#include <iostream>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <cstdio>\r\n#include <cassert>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n  freopen(\"odometer.in\", \"r\", stdin);\r\n  freopen(\"odometer.out\", \"w\", stdout);\r\n\r\n  long long X, Y;\r\n  cin >> X >> Y;\r\n\r\n  int result = 0;\r\n  for(int sz = 3; sz <= 17; sz++) {\r\n    for(int d0 = 0; d0 < 10; d0++) {\r\n      string S(sz, '0' + d0);\r\n      for(int d1 = 0; d1 < 10; d1++) {\r\n        if(d0 == d1) continue;\r\n\r\n        for(int i = 0; i < sz; i++) {\r\n          S[i] = '0' + d1;\r\n\r\n          long long num = atoll(S.c_str());\r\n          if(S[0] != '0' && X <= num && num <= Y) {\r\n            ++result;\r\n          }\r\n\r\n          S[i] = '0' + d0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  cout << result << endl;\r\n  return 0;\r\n}\r\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "220 243",
        "output": "13"
      }
    ],
    "description_no_samples": "Astronauts aboard the space station are monitoring a communication signal. The signal strength is represented as an integer, starting at S (100 <= S <= 10^16) at the beginning of the observation and ending at T (S <= T <= 10^16) at the end. Whenever the signal strength displays a 'noteworthy' value (including at the start and end of the observation) the astronauts record it. A value is 'noteworthy' if when you look at all its digits except for leading zeros, all of these are the same except for one single digit that is different. For example, the values 77787 and 220 are noteworthy, while the values 6886 and 44444 are not.\n\nHelp the astronauts count how many times they will record a noteworthy signal during the observation period.\n\nFor half of the test cases, the constraint S <= T <= 10^6 will hold. Note that to store a number as large as 10^16, you will need a 64-bit integer data type such as a \"long long\" in C/C++.\n\nPROBLEM NAME: space_signal_variation\n\nINPUT FORMAT:\n\n* Line 1: The first line will contain two integers, S and T, separated by a space.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer containing how many times the astronauts will record a noteworthy signal during the observation.",
    "description_raw": "Problem 1: Odometer [Brian Dean, 2014]\n\nFarmer John's cows are on a road trip!  The odometer on their car displays\nan integer mileage value, starting at X (100 <= X <= 10^16) miles at the\nbeginning of their trip and ending at Y (X <= Y <= 10^16) miles at the end\nof their trip.  Whenever the odometer displays an 'interesting' number\n(including at the start and end of the trip) the cows will moo.  A number\nis 'interesting' if when you look at all its digits except for leading\nzeros, all of these are the same except for one single digit that is\ndifferent.  For example, the numbers 33323 and 110 are interesting, while\nthe numbers 9779 and 55555 are not.\n\nHelp FJ count how many times the cows will moo during the trip. \n\nFor half of the test cases, the constraint X <= Y <= 10^6 will hold.  Note\nthat to store a number as large as 10^16, you will need a 64-bit integer\ndata type such as a \"long long\" in C/C++.\n\nPROBLEM NAME: odometer",
    "input_format": "* Line 1: The first line will contain two integers, X and Y, separated\n        by a space.",
    "output_format": "* Line 1: A single integer containing how many times the cows will moo\n        during the trip.",
    "num_samples": 1,
    "mapping": [
      "X -> S (starting signal strength)",
      "Y -> T (ending signal strength)",
      "interesting number -> noteworthy value",
      "cows moo -> astronauts record",
      "mileage -> signal strength"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text.replace('110 133', '220 243')\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "1132_1_bronze_acowdemia_ii": {
    "name": "Acowdemia II",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1132",
    "test_data_link": "http://www.usaco.org/current/data/prob2_bronze_open21.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_bronze_open21.html",
    "contest_link": "http://www.usaco.org/index.php?page=open21results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "1132",
    "problem_id": "1132_1_bronze_acowdemia_ii",
    "description": "Captain Jack is organizing a treasure hunt for his crew, and he's interested in determining the leadership hierarchy among the $N$ crew members ($1 \\leq N \\leq 100$). No two crew members have the same rank, but deducing their ranks can be challenging. To unravel the hierarchy, Captain Jack will examine their treasure maps.\n\nEach treasure map contains a list of crew members, ordered by the amount of treasure each member is responsible for finding. The list is in decreasing order of treasure responsibility. If multiple crew members have the same responsibility, they are ordered alphabetically by name. Due to their additional responsibilities, more senior crew members never take on more treasure responsibility than their juniors.\n\nFor example, in a crew consisting of junior sailor Bob, senior mate Alice, and very senior captain Charlie, there may be a map (Bob-Alice-Charlie) if all found different amounts of treasure (i.e., Bob found more than Alice, and Alice more than Charlie). However, a map could also be in the order (Bob-Charlie-Alice) if Alice and Charlie found equal treasure, and Bob found more.\n\nGiven $K$ treasure maps from Captain Jack's crew ($1 \\leq K \\leq 100$), help him determine for all pairs of crew members who is more senior if it's possible to tell.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two integers, $K$ and $N$.\n\nThe second line contains $N$ space-separated strings, giving the names of the crew members. Each name consists of lowercase letters and is at most 10 characters long.\n\nEach of the next $K$ lines contains $N$ space-separated strings, indicating the crew list for one treasure map.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe output should consist of $N$ lines, with $N$ characters per line. On line $i$, for any $j \\neq i$, character $j$ should be $1$ if the $i$th member is definitely more senior than the $j$th member, $0$ if the $i$th member is definitely more junior than the $j$th member, and $?$ if it's impossible to tell from the given treasure maps.\n\nCharacter $i$ on line $i$ should be $T$ because that's Captain Jack's favorite letter.",
    "num_tests": 10,
    "solution": "\n(Analysis by Benjamin Qi)\nLet's start with $K=1$. Given an author list with names $n_1,n_2,\\ldots,n_N$,  how\ndo we tell which members are more senior than others? \nIf\n$n_i<n_{i+1}<\\cdots<n_j$,  then we receive no information about the relative\nseniorities of members $n_i,\\ldots,n_j$;  perhaps all of these members put in\nthe same amount of effort. In particular, $n_1<n_2<\\cdots <n_N$ is consistent\nwith any seniority ordering.\nHowever, if there exists $i$ such that $n_i>n_{i+1}$, then member $n_i$\ndefinitely put in more effort than member $n_{i+1}$, so all of members\n$n_1,\\ldots,n_i$ must be more junior than members $n_{i+1}\\ldots n_N$. In other\nwords, if $i<j$ and $n_i,n_{i+1},\\ldots,n_j$ are not in alphabetical\norder, then we know that $n_i$ is definitely more junior than $n_j$. \nFor $K>1$, we simply accumulate the results over all publications.\nDanny Mittal's code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n \npublic class AcowdemiaII {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        Map<String, Integer> members = new HashMap<>();\n        tokenizer = new StringTokenizer(in.readLine());\n        for (int a = 0; a < n; a++) {\n            members.put(tokenizer.nextToken(), a);\n        }\n        char[][] answer = new char[n][n];\n        for (int a = 0; a < n; a++) {\n            Arrays.fill(answer[a], '?');\n            answer[a][a] = 'B';\n        }\n        for (int j = 0; j < k; j++) {\n            tokenizer = new StringTokenizer(in.readLine());\n            String[] publication = new String[n];\n            for (int x = 0; x < n; x++) {\n                publication[x] = tokenizer.nextToken();\n            }\n            for (int x = 0; x < n; x++) {\n                boolean alphabetical = true;\n                for (int y = x + 1; y < n; y++) {\n                    if (publication[y - 1].compareTo(publication[y]) > 0) {\n                        alphabetical = false;\n                    }\n                    if (!alphabetical) {\n                        int a = members.get(publication[x]);\n                        int b = members.get(publication[y]);\n                        answer[a][b] = '0';\n                        answer[b][a] = '1';\n                    }\n                }\n            }\n        }\n        StringBuilder out = new StringBuilder();\n        for (int a = 0; a < n; a++) {\n            out.append(answer[a]).append('\\n');\n        }\n        System.out.print(out);\n    }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "1 3\ncharlie bob alice\nbob alice charlie\n",
        "output": "T11\n0T?\n0?T\n"
      }
    ],
    "description_no_samples": "Captain Jack is organizing a treasure hunt for his crew, and he's interested in determining the leadership hierarchy among the $N$ crew members ($1 \\leq N \\leq 100$). No two crew members have the same rank, but deducing their ranks can be challenging. To unravel the hierarchy, Captain Jack will examine their treasure maps.\n\nEach treasure map contains a list of crew members, ordered by the amount of treasure each member is responsible for finding. The list is in decreasing order of treasure responsibility. If multiple crew members have the same responsibility, they are ordered alphabetically by name. Due to their additional responsibilities, more senior crew members never take on more treasure responsibility than their juniors.\n\nFor example, in a crew consisting of junior sailor Bob, senior mate Alice, and very senior captain Charlie, there may be a map (Bob-Alice-Charlie) if all found different amounts of treasure (i.e., Bob found more than Alice, and Alice more than Charlie). However, a map could also be in the order (Bob-Charlie-Alice) if Alice and Charlie found equal treasure, and Bob found more.\n\nGiven $K$ treasure maps from Captain Jack's crew ($1 \\leq K \\leq 100$), help him determine for all pairs of crew members who is more senior if it's possible to tell.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two integers, $K$ and $N$.\n\nThe second line contains $N$ space-separated strings, giving the names of the crew members. Each name consists of lowercase letters and is at most 10 characters long.\n\nEach of the next $K$ lines contains $N$ space-separated strings, indicating the crew list for one treasure map.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe output should consist of $N$ lines, with $N$ characters per line. On line $i$, for any $j \\neq i$, character $j$ should be $1$ if the $i$th member is definitely more senior than the $j$th member, $0$ if the $i$th member is definitely more junior than the $j$th member, and $?$ if it's impossible to tell from the given treasure maps.\n\nCharacter $i$ on line $i$ should be $T$ because that's Captain Jack's favorite letter.",
    "num_samples": 2,
    "mapping": [
      "Bessie -> Captain Jack",
      "lab members -> crew members",
      "seniority -> rank",
      "publications -> treasure maps",
      "author list -> crew list",
      "effort -> treasure responsibility",
      "senior researcher -> senior crew member",
      "junior researcher -> junior crew member",
      "alphabetically -> by name",
      "dean -> charlie",
      "elsie -> bob",
      "mildred -> alice",
      "B -> T"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text.replace('dean', 'charlie').replace('elsie', 'bob').replace('mildred', 'alice')\n\ndef transform_output(text: str) -> str:\n    return text.replace('B', 'T')"
  },
  "358_1_bronze_record_keeping": {
    "name": "Record Keeping",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=358",
    "test_data_link": "http://www.usaco.org/current/data/records.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_records.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec13results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=dec13problems",
    "problem_level": "bronze",
    "cp_id": "358",
    "problem_id": "358_1_bronze_record_keeping",
    "description": "Problem 1: Galaxy Exploration Patterns [Brian Dean, 2013]\n\nCaptain Zog is leading a fleet of spaceships exploring different sectors of a galaxy. Each hour, a squadron of 3 spaceships enters a new sector, and Captain Zog records their identifiers. For instance, over a 5-hour period, he might record the following list, where each row corresponds to a squadron entering a new sector:\n\nZEPHYR ORION NOVA\nPHOENIX ZEPHYR ATLAS\nZEPHYR ORION NOVA\nNOVA ATLAS PHOENIX\nORION ZEPHYR NOVA\n\nCaptain Zog notices that the same squadron of spaceships may appear several times in his records; in the example above, the squadron of ZEPHYR, ORION, and NOVA appears three times (even though Captain Zog didn't necessarily write their identifiers in the same order every time they entered a sector).\n\nPlease help Captain Zog count the number of occurrences of the squadron entering a sector the most.\n\nPROBLEM NAME: exploration_records\n\nINPUT FORMAT:\n\n* Line 1: The number of hours, N, for which Captain Zog keeps records\n        (1 <= N <= 1000).\n\n* Lines 2..1+N: Each line contains a list of three space-separated spaceship\n        identifiers. Each identifier is between 1 and 10 characters and uses only\n        the letters A-Z.\n\nOUTPUT FORMAT:\n\n* Line 1: The number of occurrences of the squadron entering a sector the\n        most often.",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Record Keeping by Fatih Gelgi\n\nThe trivial idea is to try all possibilities: check how many times each\r\ngroup appears in the list. We know that the order of cows can be different in\r\nsame groups. Trying all cow permutations in a group complicates coding.\r\nInstead, a better idea is to sort the cows alphabetically in a group and store\r\nthem in a string. Then we can search each string in the list easily. For\r\ninstance, the sample will input will be as follows after sorting each group:\n\r\nBESSIE ELSIE MATILDA\r\nBESSIE FRAN INGRID\r\nBESSIE ELSIE MATILDA\r\nFRAN INGRID MATILDA\r\nBESSIE ELSIE MATILDA\r\n\nNow, we can clearly see the string \"BESSIE ELSIE MATILDA\" appears in the\r\nlist three times. Note that we put space between cows instead of having\r\n\"BESSIEELSIEMATILDA\". Otherwise, the solution will fail in the following input\r\n- \"BESSI EELSIE MATILDA\" is not same as \"BESSIE ELSIE MATILDA\":\n\r\nBESSI EELSIE MATILDA\r\nBESSIE FRAN INGRID\r\nBESSIE ELSIE MATILDA\r\nFRAN INGRID MATILDA\r\nBESSIE ELSIE MATILDA\r\n\nThe running time will be O(N^2) since we search each string in the entire\r\nlist. N is small hence the solution is fast enough for the problem. Sample code\r\nis as follows:\n\r\n// O(N^2)\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint n;\r\nstring groups[1001];\r\n\r\nint main()\r\n{\r\n\tifstream fin(\"records.in\");\r\n\tfin >> n;\r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tstring str[3];\r\n\t\tfin >> str[0] >> str[1] >> str[2];\r\n\t\tsort(str,str+3);\t\t\t\t// sort each group\r\n\t\tgroups[i]=str[0]+\" \"+str[1]+\" \"+str[2];\t\t// and convert it to a string\r\n\t}\r\n\tfin.close();\r\n\r\n\tint best=0;\r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tint cnt=0;\r\n\t\t// search for the groups that are same as group i \r\n\t\tfor (int j=0; j<n; j++)\r\n\t\t\tif (groups[i]==groups[j]) cnt++;\r\n\t\tif (best<cnt) best=cnt;\t// update the best count\r\n\t}\r\n\r\n\tofstream fout(\"records.out\");\r\n\tfout << best << \"\\n\";\r\n\tfout.close();\r\n}\r\n\nAlthough it is not necessary for this problem, a faster solution may worth\r\nmentioning for similar problems in bronze division. In the first solution, we\r\nhave a list of strings that correspond to the groups with sorted cows. Let's\r\nsort the entire list this time. Then the sample input will become as follows:\n\r\nBESSIE ELSIE MATILDA\r\nBESSIE ELSIE MATILDA\r\nBESSIE ELSIE MATILDA\r\nBESSIE FRAN INGRID\r\nFRAN INGRID MATILDA\r\n\nNow, it is much easier and faster to find same groups since they will be\r\nconsecutive. This solution requires sorting the entire list which is O(N log N)\r\nand only one pass over the list is necessary which is O(N). Here's the code for\r\nthe faster solution:\n\r\n// O(N log N)\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint n;\r\nstring groups[1001];\r\n\r\nint main()\r\n{\r\n\tifstream fin(\"records.in\");\r\n\tfin >> n;\r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tstring str[3];\r\n\t\tfin >> str[0] >> str[1] >> str[2];\r\n\t\tsort(str,str+3);\t\t\t\t// sort each group\r\n\t\tgroups[i]=str[0]+\" \"+str[1]+\" \"+str[2];\t\t// and convert it to a string\r\n\t}\r\n\tfin.close();\r\n\r\n\tsort(groups,groups+n);\t\t\t\t// sort the entire list\r\n\r\n\tint best=0;\r\n\tfor (int i=0,j=1; i<n; i++,j++)\r\n\t\t// continue counting until the next string is different\r\n\t\tif (groups[i]!=groups[i+1])\r\n\t\t{\r\n\t\t\tif (best<j) best=j;\t\t// update the best count\r\n\t\t\tj=0;\r\n\t\t}\r\n\r\n\tofstream fout(\"records.out\");\r\n\tfout << best << \"\\n\";\r\n\tfout.close();\r\n}\r\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5\nZEPHYR ORION NOVA\nPHOENIX ZEPHYR ATLAS\nZEPHYR ORION NOVA\nNOVA ATLAS PHOENIX\nORION ZEPHYR NOVA\n",
        "output": "3\n"
      }
    ],
    "description_no_samples": "Problem 1: Galaxy Exploration Patterns [Brian Dean, 2013]\n\nCaptain Zog is leading a fleet of spaceships exploring different sectors of a galaxy. Each hour, a squadron of 3 spaceships enters a new sector, and Captain Zog records their identifiers. For instance, over a 5-hour period, he might record the following list, where each row corresponds to a squadron entering a new sector:\n\nZEPHYR ORION NOVA\nPHOENIX ZEPHYR ATLAS\nZEPHYR ORION NOVA\nNOVA ATLAS PHOENIX\nORION ZEPHYR NOVA\n\nCaptain Zog notices that the same squadron of spaceships may appear several times in his records; in the example above, the squadron of ZEPHYR, ORION, and NOVA appears three times (even though Captain Zog didn't necessarily write their identifiers in the same order every time they entered a sector).\n\nPlease help Captain Zog count the number of occurrences of the squadron entering a sector the most.\n\nPROBLEM NAME: exploration_records\n\nINPUT FORMAT:\n\n* Line 1: The number of hours, N, for which Captain Zog keeps records\n        (1 <= N <= 1000).\n\n* Lines 2..1+N: Each line contains a list of three space-separated spaceship\n        identifiers. Each identifier is between 1 and 10 characters and uses only\n        the letters A-Z.\n\nOUTPUT FORMAT:\n\n* Line 1: The number of occurrences of the squadron entering a sector the\n        most often.",
    "description_raw": "Problem 1: Record Keeping [Brian Dean, 2013]\n\nFarmer John has been keeping detailed records of his cows as they enter the\nbarn for milking.  Each hour, a group of 3 cows enters the barn, and Farmer\nJohn writes down their names.  For example over a 5-hour period, he might\nwrite down the following list, where each row corresponds to a group\nentering the barn:\n\nBESSIE ELSIE MATILDA\nFRAN BESSIE INGRID\nBESSIE ELSIE MATILDA\nMATILDA INGRID FRAN\nELSIE BESSIE MATILDA\n\nFarmer John notes that the same group of cows may appear several times on\nhis list; in the example above, the group of BESSIE, ELSIE, and MATILDA\nappears three times (even though Farmer John didn't necessarily write their\nnames in the same order every time they entered the barn).  \n\nPlease help Farmer John count the number of occurrences of the group\nentering the barn the most.\n\nPROBLEM NAME: records",
    "input_format": "* Line 1: The number of hours, N, for which Farmer John keeps records\n        (1 <= N <= 1000).\n\n* Lines 2..1+N: Each line contains a list of three space-separated cow\n        names.  Each name is between 1 and 10 characters and uses only\n        the letters A-Z.",
    "output_format": "* Line 1: The number of occurrences of the group entering the barn the\n        most often.",
    "num_samples": 1,
    "mapping": [
      "Farmer John -> Captain Zog",
      "cows -> spaceships",
      "barn -> sector",
      "group -> squadron",
      "names -> identifiers"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "341_1_bronze_goldilocks_and_the_n_cows": {
    "name": "Goldilocks and the N Cows",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=341",
    "test_data_link": "http://www.usaco.org/current/data/milktemp.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_milktemp.html",
    "contest_link": "http://www.usaco.org/index.php?page=nov13results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov13problems",
    "problem_level": "bronze",
    "cp_id": "341",
    "problem_id": "341_1_bronze_goldilocks_and_the_n_cows",
    "description": "In a futuristic factory, robots are used to manufacture products. Each robot is sensitive to the temperature of the environment and operates optimally only within a specific range. There are N robots (1 <= N <= 20,000) in the factory. Each robot i specifies a preferred range of temperatures C(i)..D(i) (0 <= C(i) <= D(i) <= 1,000,000,000) that it finds optimal. \n\nIf the temperature in the factory is set to T < C(i), the robot operates suboptimally, producing L units of output. If the temperature T is within the range (C(i) <= T <= D(i)), the robot produces optimally, yielding M units of output. If T > D(i), the robot overheats and produces N units of output. Naturally, M is greater than both L and N.\n\nGiven L, M, and N, along with the preferred temperature ranges for each robot, determine the maximum total output the factory can achieve by setting the temperature optimally. The values of L, M, and N are integers within the range 0..1000, and the temperature can be set to any integer value.\n\nPartial credit opportunities: Out of the 10 test cases for this problem, cases 1..4 will have D(i) <= 100 for every robot, and in cases 1..6, N is at most 1000.\n\nPROBLEM NAME: robottemp\n\nINPUT FORMAT:\n\n* Line 1: Four space-separated integers: N L M N.\n\n* Lines 2..1+N: Line 1+i contains two space-separated integers: C(i) and D(i).\n\nOUTPUT FORMAT:\n\n* Line 1: The maximum total output the factory can achieve by an optimal temperature setting in the factory.",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Goldilocks and the N Cows, by Brian Dean\n\n\n The process of solving this problem is described in the video above; the final\ncode is shown below. \n One small subtlety not discussed in the video above: if there is a tie\nbetween two elements -- one from the A array and the other from the B\narray -- it is important to process the one from the A array first (as\nwe do in our code, since we check if A[i] <= B[j]).  This ensures\nthat we get the highest possible milk output at each temperature we\nconsider, by first processing all the cows that become comfortable\n(entries in the A array), after which we process cows that become too\nhot (entries in the B array).  \n The total running time of this solution is\nO(N log N).  The initial sorts run in O(N log N) time, then the ensuing\nscan through A and B takes only O(N) time. \n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#define MAX_N 20000\nusing namespace std;\n\nint N, X, Y, Z;\nint A[MAX_N+1], B[MAX_N+1];\n\nint main(void)\n{\n  ifstream fin(\"milktemp.in\");\n  fin >> N >> X >> Y >> Z;\n  for (int i=0; i<N; i++) \n    fin >> A[i] >> B[i];\n  fin.close();\n\n  sort(A, A+N);\n  sort(B, B+N);\n  A[N] = 1000000001;\n  B[N] = 1000000001;\n\n  // scan through A and B simultaneously\n  int i=0, j=0;\n  int current_milk = N*X;\n  int answer = N*X;\n  while (i<N || j<N) {\n    // look at A[i] and B[j].\n    if (A[i] <= B[j]) {\n      // next event comes from A array\n      current_milk += Y-X;\n      i++;\n    } else {\n      // next event comes from B array\n      current_milk += Z-Y;\n      j++;\n    }\n    if (current_milk > answer) \n      answer = current_milk;\n  }\n\n  ofstream fout(\"milktemp.out\");\n  fout << answer << \"\\n\";\n  fout.close();\n\n  return 0;\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4 7 9 6\n5 8\n3 4\n13 20\n7 10\n",
        "output": "31\n"
      }
    ],
    "description_no_samples": "In a futuristic factory, robots are used to manufacture products. Each robot is sensitive to the temperature of the environment and operates optimally only within a specific range. There are N robots (1 <= N <= 20,000) in the factory. Each robot i specifies a preferred range of temperatures C(i)..D(i) (0 <= C(i) <= D(i) <= 1,000,000,000) that it finds optimal. \n\nIf the temperature in the factory is set to T < C(i), the robot operates suboptimally, producing L units of output. If the temperature T is within the range (C(i) <= T <= D(i)), the robot produces optimally, yielding M units of output. If T > D(i), the robot overheats and produces N units of output. Naturally, M is greater than both L and N.\n\nGiven L, M, and N, along with the preferred temperature ranges for each robot, determine the maximum total output the factory can achieve by setting the temperature optimally. The values of L, M, and N are integers within the range 0..1000, and the temperature can be set to any integer value.\n\nPartial credit opportunities: Out of the 10 test cases for this problem, cases 1..4 will have D(i) <= 100 for every robot, and in cases 1..6, N is at most 1000.\n\nPROBLEM NAME: robottemp\n\nINPUT FORMAT:\n\n* Line 1: Four space-separated integers: N L M N.\n\n* Lines 2..1+N: Line 1+i contains two space-separated integers: C(i) and D(i).\n\nOUTPUT FORMAT:\n\n* Line 1: The maximum total output the factory can achieve by an optimal temperature setting in the factory.",
    "description_raw": "Problem 2: Goldilocks and the N Cows [Brian Dean, 2013]\n\nYou may have heard the classical story about Goldilocks and the 3 bears. \nLittle known, however, is that Goldilocks ultimately took up farming as a\nprofession.  On her farm, she has a barn containing N cows (1 <= N <=\n20,000). Unfortunately, her cows are rather sensitive to temperature. \n\nEach cow i specifies a range of temperatures A(i)..B(i) that are \"just\nright\" (0 <= A(i) <= B(i) <= 1,000,000,000).  If Goldilocks sets the\nthermostat in the barn to a temperature T < A(i), the cow will be too cold,\nand will produce X units of milk. If she sets the thermostat to a\ntemperature T within this range (A(i) <= T <= B(i)), then the cow will feel\ncomfortable and produce Y units of milk.  If she sets the thermostat to a\ntemperature T > B(i), the cow will feel too hot, and will produce Z units\nof milk.  As one would expect, the value of Y is always larger than both X\nand Z.\n\nGiven X, Y, and Z, as well as the preferred range of temperatures for each\ncow, please compute the maximum amount of milk Goldilocks can obtain if she\nsets the barn thermostat optimally.  The values of X, Y, and Z are integers\nin the range 0..1000, and the thermostat can be set to any integer value. \n\nPartial credit opportunities: Out of the 10 test cases for this problem,\ncases 1..4 will have B(i) <= 100 for every cow, and in cases 1..6, N is at\nmost 1000.\n\nPROBLEM NAME: milktemp",
    "input_format": "* Line 1: Four space-separated integers: N X Y Z.\n\n* Lines 2..1+N: Line 1+i contains two space-separated integers: A(i)\n        and B(i).",
    "output_format": "* Line 1: The maximum amount of milk Goldilocks can obtain by an\n        optimal temperature setting in her barn.",
    "num_samples": 1,
    "mapping": [
      "Goldilocks -> Factory",
      "cows -> robots",
      "temperature range A(i)..B(i) -> temperature range C(i)..D(i)",
      "X units of milk -> L units of output",
      "Y units of milk -> M units of output",
      "Z units of milk -> N units of output",
      "thermostat -> temperature",
      "produce milk -> produce output"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1275_1_bronze_leaders": {
    "name": "Leaders",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1275",
    "test_data_link": "http://www.usaco.org/current/data/prob1_bronze_jan23.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_bronze_jan23.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan23results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "bronze",
    "cp_id": "1275",
    "problem_id": "1275_1_bronze_leaders",
    "description": "In a distant galaxy, there are $N$ alien scoutships ($2 \\leq N \\leq 10^5$). Each scoutship belongs to a squadron that is either Alpha or Beta. These scoutships are positioned in a sequence, numbered $1 \\ldots N$ in order.\n\nThroughout their mission, each scoutship records a list of scoutships. Specifically, scoutship $i$'s list includes the range of scoutships starting with itself (scoutship $i$) up to and including scoutship $R_i$ ($i \\leq R_i \\leq N$).\n\nIt has been discovered that each squadron has exactly one distinct commander. The commanders are not known, but each commander must have a list that includes all the scoutships of their squadron, or the other squadron's commander (or both).\n\nHelp identify the number of pairs of scoutships that could be commanders. It is guaranteed that there is at least one possible pair.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe second line contains a string of length $N$, with the $i$th character denoting the squadron of the $i$th scoutship (A meaning Alpha and B meaning Beta). It is guaranteed that there is at least one Alpha and one Beta.\n\nThe third line contains $R_1 \\dots R_N$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the number of possible pairs of commanders.",
    "num_tests": 17,
    "solution": "\n(Analysis by David Hu)\nNote that each cow visits only cows at or after it. This implies that it is \nimpossible for any pair of two cows to visit each other. Thus, either the \nleader of the guernseys must have visited all the guernseys or the leader of\nholsteins must have visited all the holsteins (or both). This means that the\nleader of the guernseys must be the earliest guernsey or the leader of the\nholsteins must be the earliest holstein (or both).\nOnce we fix the leader of the guernseys to be the earliest guernsey and verify\nthat the earliest guernsey has indeed visited all the other guernseys, we can\nbrute force  over all holsteins and check whether they can also be a leader\ntogether with the earliest guernsey. Likewise, we also consider a similar case\nwhere the leader of the holsteins is the earliest holstein.\nMake sure to pay special attention to the case where the earliest guernsey and\nearliest holstein are both leaders.\nMy C++ code:\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 3e5 + 13;\n\nint N;\nstring s;\nint arr[MAXN];\nint eG, eH; //earliest guernsey, earliest holstein\nint lG, lH; //latest guernsey, latest holstein\nint ans;\n\nint main()\n{\n    cin >> N >> s;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        arr[i]--;\n    }\n    for (int i = 0; i < N; i++)\n    {\n        if (s[i] == 'G')\n        {\n            eG = i;\n            break;\n        }\n    }\n    for (int i = N - 1; i >= 0; i--)\n    {\n        if (s[i] == 'G')\n        {\n            lG = i;\n            break;\n        }\n    }\n    for (int i = 0; i < N; i++)\n    {\n        if (s[i] == 'H')\n        {\n            eH = i;\n            break;\n        }\n    }\n    for (int i = N - 1; i >= 0; i--)\n    {\n        if (s[i] == 'H')\n        {\n            lH = i;\n            break;\n        }\n    }\n    if (arr[eG] >= lG)\n    {\n        //earliest guernsey visited everybody and is the leader.\n        //holstein leader has to visit earliest guernsey or visit all holsteins.\n        //handle case where holstein leader has visited earliest guernsey.\n        for (int i = 0; i < eG; i++)\n        {\n            if (i == eH) //ignore the case where the holstein leader is earliest holstein.\n            {\n                continue;\n            }\n            if (s[i] == 'H' && arr[i] >= eG)\n            {\n                ans++;\n            }\n        }\n    }\n    if (arr[eH] >= lH)\n    {\n        //earliest holstein visited everybody.\n        for (int i = 0; i < eH; i++)\n        {\n            if (i == eG)\n            {\n                continue;\n            }\n            if (s[i] == 'G' && arr[i] >= eH)\n            {\n                ans++;\n            }\n        }\n    }\n    //check whether earliest guernsey and earliest holstein can together be leaders.\n    if ((arr[eG] >= lG || (eG <= eH && arr[eG] >= eH)) && (arr[eH] >= lH || (eH <= eG && arr[eH] >= eG)))\n    {\n        ans++;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n\nMy Python code:\n\nN = int(input())\ns = input()\narr = list(map(int, input().split()))\narr = [x - 1 for x in arr]\n\neG, eH, lG, lH = -1, -1, -1, -1\n\nfor i in range(N - 1, -1, -1):\n    if (s[i] == 'G'):\n        eG = i\n    if (s[i] == 'H'):\n        eH = i\n\nfor i in range(N):\n    if (s[i] == 'G'):\n        lG = i\n    if (s[i] == 'H'):\n        lH = i\n\nans = 0\n\nif (arr[eG] >= lG):\n    for i in range(eG):\n        if (i == eH):\n            continue\n        if (s[i] == 'H' and arr[i] >= eG):\n            ans += 1\n\nif (arr[eH] >= lH):\n    for i in range(eH):\n        if (i == eG):\n            continue\n        if (s[i] == 'G' and arr[i] >= eH):\n            ans += 1\n\nif ((arr[eG] >= lG or (eG <= eH and arr[eG] >= eH)) and (arr[eH] >= lH or (eH <= eG and arr[eH] >= eG))):\n    ans += 1\n\nprint(ans)\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4\nABBA\n2 4 3 4",
        "output": "1"
      }
    ],
    "description_no_samples": "In a distant galaxy, there are $N$ alien scoutships ($2 \\leq N \\leq 10^5$). Each scoutship belongs to a squadron that is either Alpha or Beta. These scoutships are positioned in a sequence, numbered $1 \\ldots N$ in order.\n\nThroughout their mission, each scoutship records a list of scoutships. Specifically, scoutship $i$'s list includes the range of scoutships starting with itself (scoutship $i$) up to and including scoutship $R_i$ ($i \\leq R_i \\leq N$).\n\nIt has been discovered that each squadron has exactly one distinct commander. The commanders are not known, but each commander must have a list that includes all the scoutships of their squadron, or the other squadron's commander (or both).\n\nHelp identify the number of pairs of scoutships that could be commanders. It is guaranteed that there is at least one possible pair.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\n\nThe second line contains a string of length $N$, with the $i$th character denoting the squadron of the $i$th scoutship (A meaning Alpha and B meaning Beta). It is guaranteed that there is at least one Alpha and one Beta.\n\nThe third line contains $R_1 \\dots R_N$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the number of possible pairs of commanders.",
    "num_samples": 2,
    "mapping": [
      "cows -> scoutships",
      "breed -> squadron",
      "Guernsey -> Alpha",
      "Holstein -> Beta",
      "leader -> commander",
      "E_i -> R_i",
      "Farmer John -> mission captain"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text.replace('G', 'A').replace('H', 'B')\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "394_1_bronze_mirror_field": {
    "name": "Mirror Field",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=394",
    "test_data_link": "http://www.usaco.org/current/data/mirror.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_mirror.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb14results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=feb14problems",
    "problem_level": "bronze",
    "cp_id": "394",
    "problem_id": "394_1_bronze_mirror_field",
    "description": "Problem 1: Laser Maze in the Enchanted Forest [Elena Turner]\n\nDeep within the Enchanted Forest, a group of cunning squirrels have set up a laser maze using mystical crystals. These crystals are arranged in a grid of size N by M squares (1 <= N, M <= 1,000). In each square, a crystal is placed that can deflect a laser beam. The crystals come in two configurations, represented by the '/' character (a crystal deflecting from the bottom-left corner to the top-right corner) and the '\\' character (a crystal deflecting from the top-left corner to the bottom-right corner).\n\nOne night, a curious fox decides to explore the maze by shining a laser into the grid from outside its boundary. The laser can be directed either horizontally or vertically, entering along a row or column of the grid. As the laser encounters crystals, it reflects off them, changing its direction from horizontal to vertical or vice versa. The fox wants to determine the maximum number of crystals that its laser can interact with during a single traversal through the maze. Given the layout of the crystal grid, help the fox calculate this maximum number.\n\nPROBLEM NAME: laser_maze\n\nINPUT FORMAT:\n\n* Line 1: The integers N and M, separated by a space.\n\n* Lines 2..1+N: Each line will contain M '/' or '\\' characters, describing a row of the crystal grid.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer indicating the maximum number of times the laser could be reflected by the crystals. Please output -1 if it could be reflected indefinitely.",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Mirror by Brian Dean\n\nThe solution to this problem involves simply simulating the beam of\nlight from every possible starting point, counting the number of\nbounces until it leaves the grid.  There are two possible concerns\nabout this approach, however: is it possible for the beam to continue\nbouncing forever?  And, will this be fast enough to run within the\nrequired time limit?  \nFortunately, a simple observation helps resovle both of these\nquestions.  Each mirror side has two \"ports\" (say, A and B).  If light\ncomes in on A it leaves on B, and if light comes in on B it leaves on\nA.  With a bit of thought, we can therefore see that if light enters\nthe grid at a certain location, there is a unique path it must take\nuntil it finally exits -- and if we shine light back in the exit, it\nwill take this same path in reverse.  Each mirror side is therefore\nencountered along exactly two paths, so at worst our method examines\nevery square in the grid only a constant number of times, making the\napproach run very quickly.  We also cannot encounter any cycles, since\notherwise the first mirror side we encounter along a cycle would need\nto have 3 \"ports\" (two along the cycle, and one along the direction we\ncame from to enter the cycle).  If you are familiar with the concept\nof \"graphs\" in computer science, this gives a very convenient way to\nthink about the field of mirrors -- as a graph where every node has\none or two incident edges. \nHere is one simple solution, using lookup tables to deal with \nthe mechanics of deciding how to change direction at each bounce: \n\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n// direction: 0  1   2   3 \nint dr[] =   {1, 0, -1,  0};\nint dc[] =   {0, 1,  0, -1};\n\n// new direction after hitting / mirror\nint bounce1[] = {3, 2, 1, 0}; \n\n// new direction after hitting \\ mirror \nint bounce2[] = {1, 0, 3, 2}; \n\nint N, M;\nstring A[1010];\n\nint trace(int r, int c, int dir) {\n  int result = 0;\n  while(0 <= r && r < N && 0 <= c && c < M) {\n    if(A[r][c] == '/') \n      dir = bounce1[dir];\n    else \n      dir = bounce2[dir];\n    r += dr[dir];\n    c += dc[dir];\n    result++;\n  }\n  return result;\n}\n\nint main() {\n  freopen(\"mirror.in\", \"r\", stdin);\n  freopen(\"mirror.out\", \"w\", stdout);\n\n  cin >> N >> M;\n\n  for(int i = 0; i < N; i++) \n    cin >> A[i];\n\n  int best = 0;\n  for(int i = 0; i < N; i++) {\n    best = max(best, trace(i, 0, 1));\n    best = max(best, trace(i, M - 1, 3));\n  }\n  for(int i = 0; i < M; i++) {\n    best = max(best, trace(0, i, 0));\n    best = max(best, trace(N - 1, i, 2));\n  }\n  cout << best << endl;\n  \n  return 0;\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 3\n/\\\\\n\\\\\\\n/\\/\n",
        "output": "3\n"
      }
    ],
    "description_no_samples": "Problem 1: Laser Maze in the Enchanted Forest [Elena Turner]\n\nDeep within the Enchanted Forest, a group of cunning squirrels have set up a laser maze using mystical crystals. These crystals are arranged in a grid of size N by M squares (1 <= N, M <= 1,000). In each square, a crystal is placed that can deflect a laser beam. The crystals come in two configurations, represented by the '/' character (a crystal deflecting from the bottom-left corner to the top-right corner) and the '\\' character (a crystal deflecting from the top-left corner to the bottom-right corner).\n\nOne night, a curious fox decides to explore the maze by shining a laser into the grid from outside its boundary. The laser can be directed either horizontally or vertically, entering along a row or column of the grid. As the laser encounters crystals, it reflects off them, changing its direction from horizontal to vertical or vice versa. The fox wants to determine the maximum number of crystals that its laser can interact with during a single traversal through the maze. Given the layout of the crystal grid, help the fox calculate this maximum number.\n\nPROBLEM NAME: laser_maze\n\nINPUT FORMAT:\n\n* Line 1: The integers N and M, separated by a space.\n\n* Lines 2..1+N: Each line will contain M '/' or '\\' characters, describing a row of the crystal grid.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer indicating the maximum number of times the laser could be reflected by the crystals. Please output -1 if it could be reflected indefinitely.",
    "description_raw": "Problem 1: Mirror Field [Mark Gordon]\n\nFarmer John has left some old mirrors sitting outside his house, and his\ncows, feeling mischievous as always, have stolen them!  \n\nThe cows have set up the mirrors in a rectangular field measuring N by M\nsquares (1 <= N, M <= 1,000).  In each square, they have placed a double\nsided mirror between two of its opposite corners.  These two possible\nconfigurations are represented by the '/' character (a mirror connecting\nthe lower-left corner to the upper-right corner) and the '\\' character (a\nmirror connecting the upper-left corner to the lower-right corner).\n\nOne evening, Bessie the cow brings a laser pointer out to the mirror field.\nStanding outside the field, she shines the beam of light either\nhorizontally or vertically along either a row or column of the field,\ncausing it to bounce of some number of mirrors.  Since the mirrors are all\ndiagonally oriented, a horizontal beam of light that reflects off a mirror\nwill end up traveling vertically, and vice versa.  Bessie wonders what is\nthe maximum number of mirrors on which her beam of light can be reflected\nat the same time.  Given the layout of the mirror field, please help Bessie\ncompute this number.\n\nPROBLEM NAME: mirror",
    "input_format": "* Line 1: The integers N and M, separated by a space.\n\n* Lines 2..1+N: Each line will contain M '/' or '\\' characters,\n        describing a row of the mirror field.",
    "output_format": "* Line 1: A single integer indicating the maximum number of times a\n        horizontal or vertical beam originating outside the mirror\n        field could be reflected.  Please output -1 if it could be\n        reflected indefinitely.",
    "num_samples": 1,
    "mapping": [
      "Farmer John -> The curious fox",
      "cows -> squirrels",
      "mirrors -> crystals",
      "mirror field -> crystal grid",
      "beam of light -> laser",
      "Bessie the cow -> the curious fox",
      "horizontally or vertically -> along a row or column",
      "maximum number of mirrors -> maximum number of crystals"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    # Since the logic and format are unchanged except for names, input transformation is not needed.\n    return text\n\ndef transform_output(text: str) -> str:\n    # The logic and output format are unchanged.\n    return text\n"
  },
  "278_1_bronze_bovine_ballet": {
    "name": "Bovine Ballet",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=278",
    "test_data_link": "http://www.usaco.org/current/data/ballet.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_ballet.html",
    "contest_link": "http://www.usaco.org/index.php?page=open13results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=open13problems",
    "problem_level": "bronze",
    "cp_id": "278",
    "problem_id": "278_1_bronze_bovine_ballet",
    "description": "Problem 1: Robotic Arm Dance\n\nIn a bid to showcase the precision and grace of technology, a high-tech robotic arm named R.O.S.E (Robotic Operative System for Elegance) is participating in a dance showcase. Her final performance is soon, and the engineers want to build a rectangular platform large enough so that R.O.S.E can perform her entire routine without any mishaps.\n\nThe dance routine will occur on a rectangular platform consisting of a grid of 1 x 1 square cells. R.O.S.E's four limbs are described concisely as follows:\n\nFR: Front right limb\nFL: Front left limb\nRR: Rear right limb\nRL: Rear left limb\n\nHer four limbs start out in 4 adjacent cells forming a square as follows, with R.O.S.E facing north.\n\nFL FR\nRL RR\n\nR.O.S.E's dance follows a series of N instructions (1 <= N <= 1000), where each instruction tells her to either move one limb by one cell or to pivot 90 degrees clockwise.\n\nInstructions to move a limb consist of 3 characters, the first two identifying the limb to move, and the final character specifying the direction of movement (F = forward, B = back, R = right, L = left). For example, \"FRF\" means R.O.S.E should move her front right limb forward one cell, and \"RLR\" means she should move her rear left limb right one cell. Of course, the direction of movement is relative to the direction R.O.S.E is facing.\n\nInstruction to pivot are also 3 characters, the first two specifying the single limb that R.O.S.E keeps planted, around which she rotates 90 degrees clockwise. The last character is \"P\" (for pivot). For example, the instruction \"FRP\" means R.O.S.E should pivot 90 degrees clockwise about her stationary front right limb. This means that if her limbs are currently situated as follows (with R.O.S.E facing north)\n\n.. .. ..\n.. .. FR\n.. FL ..\n.. RL RR\n\nthen after the instruction \"FRP\" her limbs will be located as follows, with R.O.S.E now facing east:\n\nRL FL ..\nRR .. FR\n.. .. ..\n.. .. ..\n\nGiven the N instructions in R.O.S.E's dance, please compute the minimum area of a rectangular platform necessary to contain her limbs during the entire dance.\n\nIf R.O.S.E awkwardly ever moves one limb onto the same cell as another limb, she will malfunction and fail to complete the dance; in this case, please output -1. Note that this is the only case where R.O.S.E will malfunction; she has become quite advanced after all her programming, and can easily move her limbs into rather unusual configurations (for example, with her back limbs farther forward than her front limbs).\n\nPROBLEM NAME: robotic_arm_dance\n\nINPUT FORMAT:\n\n* Line 1: The integer N.\n\n* Lines 2..1+N: Each line contains one of the 3-character instructions in R.O.S.E's dance.\n\nOUTPUT FORMAT:\n\n* Line 1: The minimum area of a rectangular platform necessary to contain R.O.S.E's limbs during the entire dance, or -1 if R.O.S.E malfunctions.",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nAnalysis: Bovine Ballet by Fatih Gelgi\n\nIn this problem, a trivial solution is to keep the feet positions and apply\r\ninstructions one by one. After each instruction, the corner coordinates of the\r\nrectangular stage are updated. Note that we cannot mark the feet position on a\r\nmatrix since the matrix may be excessively large and doesn't fit in the memory\r\n(ex. an input that has 500 FRFs and FRP,RRP alternates 250 times).\nat the beginning, we need to assign initial positions to the feet. Let's\r\nsay:\n\r\n    y x\r\nFL (0,0)\r\nFR (0,1)\r\nRL (1,0)\r\nRR (1,1)\r\n\nWithout rotation, moves are straightforward:\n\nforward: y=y-1\r\n\tright: x=x+1\r\n\tback: y=y+1\r\n\tleft: x=x-1\r\n\nWhen we include rotation, the moves will change with respect to the current\r\ndirection. We have 16 different cases in total -- 4 moves per direction. One\r\nidea is to write all cases one by one. However, we will work on a more elegant\r\nidea. Let's numerate the moves first - {0:forward, 1:right, 2:back, 3:left}.\r\nNotice that they in clockwise order. Let's numerate the directions again in\r\nclockwise order as the second step - {0:north, 1:east, 2:south, 3:west}. Now,\r\nconsider the following instructions:\n\r\n0) Initially:\r\n.. .. .. .. \r\n.. .. .. .. (facing north)\r\n.. .. FL FR \r\n.. .. RL RR \r\n\r\n1) FRF:\r\n.. .. .. .. \r\n.. .. .. FR (facing north)\r\n.. .. FL .. \r\n.. .. RL RR \r\n\r\n2) FRP:\r\n.. RL FL .. \r\n.. RR .. FR (facing east)\r\n.. .. .. .. \r\n.. .. .. .. \r\n\r\n3) RRF:\r\n.. RL FL .. \r\n.. .. RR FR (facing east)\r\n.. .. .. .. \r\n.. .. .. .. \r\n\r\n4) RLP:\r\n.. RL .. .. \r\nRR FL .. .. (facing south)\r\nFR .. .. .. \r\n.. .. .. .. \r\n\r\n5) FRF:\r\n.. RL .. .. \r\nRR FL .. .. (facing south)\r\n.. .. .. .. \r\nFR .. .. .. \r\n\nYou can observe that the moves shift by rotations. In other words, forward\r\nbecomes right, right becomes back, back becomes left, left becomes forward in\r\none rotation. For instance, Bessie moves forward (MOVE=0) in steps 1,3 and 5.\r\nIn the first one, the direction is north (DIR=0). In steps 3 and 5, the\r\ndirections are east (DIR=1) and south (DIR=2). Forward move (MOVE=0) means to\r\nmove right (MOVE=1) and back (MOVE=2) when facing east (DIR=1) and south\r\n(DIR=2) respectively. As a summary, we can calculate the absolute direction of\r\nthe current move by MOVE = (MOVE + DIR) % 4.\nNow, the issue is to do the rotation. We need to calculate the new positions\r\nfor the feet. Consider the following rotation:\n\r\n1) FRF:\r\n   -2 -1  0  1\r\n-2 .. .. .. .. \r\n-1 .. .. .. FR\r\n 0 .. .. FL .. \r\n 1 .. .. RL RR \r\n\r\n2) FRP:\r\n   -2 -1  0  1\r\n-2 .. RL FL .. \r\n-1 .. RR .. FR (facing east)\r\n 0 .. .. .. .. \r\n 1 .. .. .. .. \r\n\nNew coordinate of a foot (y1,x1) is (y0+x1-x0,x0+y0-y1) where (y0,x0) is the\r\nposition of the pivot foot. In the example above, the rotation is as follows:\n\r\n\tinitial position\tafter rotation\r\n\t------------\t\t------------\r\nFL\t(0,0)\t\t\t(-1+0-1,1-1-0)=(-2,0)\r\nFR\t(-1,1)\t\t\t(-1,1)\r\nRL\t(1,0)\t\t\t(-1+0-1,1-1-1)=(-2,-1)\r\nRR\t(1,1)\t\t\t(-1+1-1,1-1-1)=(-1,-1)\r\n\nThe solution requires O(N) time. The sample code is provided below:\n\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nconst int d[4][2]={{-1,0},{0,1},{1,0},{0,-1}}; \t// (dy,dx)\r\n{0:forward,1:right,2:back,3:left}\r\nstruct Point { int y,x; }\r\n\tfoot[4]={{0,0},{0,1},{1,0},{1,1}};\t// initial feet positions\r\nint dir;\t\t\t\t\t// {0:north,1:west,2:south,3:east}\r\nint miny,minx,maxy,maxx;\t\t\t// min - max coordinates of the area\r\n\r\nint move(string s)\r\n{\r\n\t// determine the foot\r\n\tint f=0;\r\n\tif (s[0]=='F' && s[1]=='R') f=1;\r\n\telse if (s[0]=='R')\r\n\t\tif (s[1]=='L') f=2;\r\n\t\telse f=3;\r\n\r\n\t// clockwise rotation\r\n\tif (s[2]=='P')\r\n\t{\r\n\t\tfor (int i=0; i<4; i++)\r\n\t\t{\r\n\t\t\tint ny=foot[f].y+foot[i].x-foot[f].x;\r\n\t\t\tint nx=foot[f].x+foot[f].y-foot[i].y;\r\n\t\t\tfoot[i].y=ny,foot[i].x=nx;\r\n\t\t}\r\n\t\tdir=(dir+1)%4;\t\t// rotate direction clockwise\r\n\t}\r\n\t// move\r\n\telse\r\n\t{\r\n\t\t// get the relative direction\r\n\t\tint m=0;\r\n\t\tif (s[2]=='R') m=1;\r\n\t\tif (s[2]=='B') m=2;\r\n\t\tif (s[2]=='L') m=3;\r\n\t\tm=(m+dir)%4;\t\t// calculate the absolute direction\r\n\r\n\t\tfoot[f].y+=d[m][0];\r\n\t\tfoot[f].x+=d[m][1];\r\n\r\n\t\t// check if Bessie trips\r\n\t\tfor (int i=0; i<4; i++)\r\n\t\t\tif (f!=i && foot[f].y==foot[i].y && foot[f].x==foot[i].x)\r\n\t\t\t\treturn 0;\r\n\t}\r\n\r\n\t// update minimum size rectangle\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tif (miny>foot[i].y) miny=foot[i].y;\r\n\t\tif (maxy<foot[i].y) maxy=foot[i].y;\r\n\t\tif (minx>foot[i].x) minx=foot[i].x;\r\n\t\tif (maxx<foot[i].x) maxx=foot[i].x;\r\n\t}\r\n\treturn 1;\r\n}\r\n\r\nint main()\r\n{\r\n\tifstream fin(\"ballet.in\");\r\n\tofstream fout(\"ballet.out\");\r\n\r\n\tint n,valid=1;\r\n\tfin >> n;\r\n\tstring inst;\r\n\tfor (int i=0; i<n; i++)\r\n\t{\r\n\t\tfin >> inst;\r\n\t\tif (!(valid=move(inst))) break;\r\n\t}\r\n\r\n\tif (valid)\r\n\t\tfout << (maxy-miny+1)*(maxx-minx+1) << endl;\r\n\telse\r\n\t\tfout << -1 << endl;\r\n\r\n\tfin.close();\r\n\tfout.close();\r\n}\r\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3\nFRF\nFRP\nRLB\n",
        "output": "16\n"
      }
    ],
    "description_no_samples": "Problem 1: Robotic Arm Dance\n\nIn a bid to showcase the precision and grace of technology, a high-tech robotic arm named R.O.S.E (Robotic Operative System for Elegance) is participating in a dance showcase. Her final performance is soon, and the engineers want to build a rectangular platform large enough so that R.O.S.E can perform her entire routine without any mishaps.\n\nThe dance routine will occur on a rectangular platform consisting of a grid of 1 x 1 square cells. R.O.S.E's four limbs are described concisely as follows:\n\nFR: Front right limb\nFL: Front left limb\nRR: Rear right limb\nRL: Rear left limb\n\nHer four limbs start out in 4 adjacent cells forming a square as follows, with R.O.S.E facing north.\n\nFL FR\nRL RR\n\nR.O.S.E's dance follows a series of N instructions (1 <= N <= 1000), where each instruction tells her to either move one limb by one cell or to pivot 90 degrees clockwise.\n\nInstructions to move a limb consist of 3 characters, the first two identifying the limb to move, and the final character specifying the direction of movement (F = forward, B = back, R = right, L = left). For example, \"FRF\" means R.O.S.E should move her front right limb forward one cell, and \"RLR\" means she should move her rear left limb right one cell. Of course, the direction of movement is relative to the direction R.O.S.E is facing.\n\nInstruction to pivot are also 3 characters, the first two specifying the single limb that R.O.S.E keeps planted, around which she rotates 90 degrees clockwise. The last character is \"P\" (for pivot). For example, the instruction \"FRP\" means R.O.S.E should pivot 90 degrees clockwise about her stationary front right limb. This means that if her limbs are currently situated as follows (with R.O.S.E facing north)\n\n.. .. ..\n.. .. FR\n.. FL ..\n.. RL RR\n\nthen after the instruction \"FRP\" her limbs will be located as follows, with R.O.S.E now facing east:\n\nRL FL ..\nRR .. FR\n.. .. ..\n.. .. ..\n\nGiven the N instructions in R.O.S.E's dance, please compute the minimum area of a rectangular platform necessary to contain her limbs during the entire dance.\n\nIf R.O.S.E awkwardly ever moves one limb onto the same cell as another limb, she will malfunction and fail to complete the dance; in this case, please output -1. Note that this is the only case where R.O.S.E will malfunction; she has become quite advanced after all her programming, and can easily move her limbs into rather unusual configurations (for example, with her back limbs farther forward than her front limbs).\n\nPROBLEM NAME: robotic_arm_dance\n\nINPUT FORMAT:\n\n* Line 1: The integer N.\n\n* Lines 2..1+N: Each line contains one of the 3-character instructions in R.O.S.E's dance.\n\nOUTPUT FORMAT:\n\n* Line 1: The minimum area of a rectangular platform necessary to contain R.O.S.E's limbs during the entire dance, or -1 if R.O.S.E malfunctions.",
    "description_raw": "Problem 1: Bovine Ballet [Brian Dean, 2013]\n\nIn an attempt to challenge the stereotypical perception of cows as awkward\ncreatures, Farmer John's prize cow Bessie has signed up for an introductory\nballet class.  Her final performance is next week, and FJ wants to help her\nby building a rectangular stage large enough so that she can perform her\nentire dance without falling off the edges.\n\nBessie's dance will take place on a rectangular stage consisting of a grid\nof 1 x 1 square cells.  Bessie's four feet are described concisely as follows:\n\nFR: Front right foot\nFL: Front left foot\nRR: Rear right foot\nRL: Rear left foot\n\nHer four feet start out in 4 adjacent cells forming a square as follows,\nwith Bessie facing north.\n\nFL FR\nRL RR\n\nBessie's dance follows a series of N instructions (1 <= N <= 1000), where\neach instruction tells her to either move one foot by one cell or to pivot\n90 degrees clockwise.  \n\nInstructions to move a foot consist of 3 characters, the first two\nidentifying the foot to move, and the final character specifying the\ndirection of movement (F = forward, B = back, R = right, L = left).  For\nexample, \"FRF\" means Bessie should move her front right foot forward one\ncell, and \"RLR\" means she should move her rear left foot right one cell. \nOf course, the direction of movement is relative to the direction Bessie is\nfacing.\n\nInstruction to pivot are also 3 characters, the first two specifying the\nsingle foot that Bessie keeps planted, around which she rotates 90 degrees\nclockwise.  The last character is \"P\" (for pivot).  For example, the\ninstruction \"FRP\" means Bessie should pivot 90 degrees clockwise about her\nstationary front right foot.  This means that if her feet are currently\nsituated as follows (with Bessie facing north)\n\n.. .. .. \n.. .. FR \n.. FL .. \n.. RL RR \n\nthen the after the instruction \"FRP\" her feet will be located as follows,\nwith Bessie now facing east:\n\nRL FL .. \nRR .. FR \n.. .. ..  \n.. .. .. \n\nGiven the N instructions in Bessie's dance, please compute the minimum area\nof a rectangular stage necessary contain her feet during the entire dance.\n\nIf Bessie clumsily ever moves one foot onto the same cell as another foot,\nshe will trip and fail to complete the dance; in this case, please output\n-1.  Note that this is the only case where Bessie will trip; she has become\nquite flexible after all her practice, and can easily move her feet into\nrather strange configurations (for example, with her back feet farther\nforward than her front feet).\n\nPROBLEM NAME: ballet",
    "input_format": "* Line 1: The integer N.\n\n* Lines 2..1+N: Each line contains one of the 3-character instructions\n        in Bessie's dance.",
    "output_format": "* Line 1: The minimum area of a rectangular stage necessary to contain\n        Bessie's feet during the entire dance, or -1 if Bessie trips.",
    "num_samples": 1,
    "mapping": [
      "Bessie -> R.O.S.E",
      "feet -> limbs",
      "stage -> platform",
      "Farmer John -> engineers",
      "dance -> routine",
      "trip -> malfunction"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1111_1_silver_year_of_the_cow": {
    "name": "Year of the Cow",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1111",
    "test_data_link": "http://www.usaco.org/current/data/prob2_silver_feb21.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_silver_feb21.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb21results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "silver",
    "cp_id": "1111",
    "problem_id": "1111_1_silver_year_of_the_cow",
    "description": "In the mystical land of Eldoria, a young sorcerer named Arin embarks on a quest to collect magical stones that hold immense power. These stones are scattered throughout the timeline of Eldoria, and Arin can only gather them during specific celestial events known as the Grand Convergence.\n\nThe Grand Convergence occurs every 12 years, with the current year being one of such events. Arin possesses an enchanted amulet that allows him to travel through time to any past or future Grand Convergence. However, each time travel makes Arin weary, and thus he prefers to make at most K time jumps during his quest.\n\nArin's mission is to collect N different magical stones that are located at various points in history, each a distinct number of years in the past from the current Grand Convergence year. Help Arin determine the minimum number of years he will take to collect all the stones and return to the present Grand Convergence year, with at most K time jumps.\n\nArin starts his journey at the current Grand Convergence and can travel back in time immediately. None of the stones are located in a year of Grand Convergence.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of input contains N and K. The next N lines contain N distinct integers in the range 1 ... 10^9, indicating how many years ago each of Arin's stones are located.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nPrint the minimum number of years it will take Arin to collect all the stones and return to the present year.",
    "num_tests": 10,
    "solution": "\n(Analysis by Spencer Compton)\nWe start by thinking about the structure of Bessie's journey through time. Since\nthere are only time portals on years that are multiples of 12, and none of\nBessie's relatives are born in such a year, to visit some relative Bessie must\nalso visit the preceding year of the Ox and wait 12 years. For example, if\nBessie has a relative from 15 years ago, Bessie must visit the year of the Ox 24\nyears ago and must wait until at least the year of the Ox 12 years ago. In other\nwords, we can think of each year $x$ as belonging to a 12-year cycle\n$\\lfloor \\frac{x+11}{12} \\rfloor$, so $0$ belongs to cycle $0$, \n$[1, \\dots, 12]$ to cycle $1$, $[13, \\dots, 24]$ to cycle $2$, and so on.\nMeaning, if Bessie has a relative in cycle $x$ then Bessie must spend all 12\nyears in that cycle.\nWe must use a jump to go back to the earliest cycle, then with the remaining\n$K-1$ jumps Bessie can skip over contiguous ranges of unnecessary cycles. It is\nthen optimal to skip over the $K-1$ largest contiguous ranges of unused cycles.\nOne way we can accomplish this is by identifying all the cycles Bessie has\nrelatives in, sorting them, identifying the gaps between adjacent cycles in the\nsorted list, and sorting those gaps to find the $K-1$ largest. In total, this\ntakes  $O(n \\log (n) ) $ time.\nBrian Dean's code:\n\n#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \nset<int> blocks;\nvector<int> gaps;\n \nint main(void)\n{\n  int N, K, years_ago, answer, last = 0;\n  cin >> N >> K;\n  for (int i=0; i<N; i++) { cin >> years_ago; blocks.insert ((years_ago+11)/12); }\n  answer = *blocks.rbegin();\n  while (!blocks.empty()) {\n    gaps.push_back(*blocks.begin() - last - 1);\n    last = *blocks.begin();\n    blocks.erase(*blocks.begin());\n  }\n  sort (gaps.rbegin(), gaps.rend());\n  for (int i=0; i<K-1 && i<gaps.size(); i++) answer -= gaps[i];\n  cout << answer * 12 << \"\\n\";\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5 3\n101\n85\n100\n46\n95\n",
        "output": "36\n"
      }
    ],
    "description_no_samples": "In the mystical land of Eldoria, a young sorcerer named Arin embarks on a quest to collect magical stones that hold immense power. These stones are scattered throughout the timeline of Eldoria, and Arin can only gather them during specific celestial events known as the Grand Convergence.\n\nThe Grand Convergence occurs every 12 years, with the current year being one of such events. Arin possesses an enchanted amulet that allows him to travel through time to any past or future Grand Convergence. However, each time travel makes Arin weary, and thus he prefers to make at most K time jumps during his quest.\n\nArin's mission is to collect N different magical stones that are located at various points in history, each a distinct number of years in the past from the current Grand Convergence year. Help Arin determine the minimum number of years he will take to collect all the stones and return to the present Grand Convergence year, with at most K time jumps.\n\nArin starts his journey at the current Grand Convergence and can travel back in time immediately. None of the stones are located in a year of Grand Convergence.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line of input contains N and K. The next N lines contain N distinct integers in the range 1 ... 10^9, indicating how many years ago each of Arin's stones are located.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nPrint the minimum number of years it will take Arin to collect all the stones and return to the present year.",
    "num_samples": 1,
    "mapping": [
      "Bessie -> Arin",
      "cows -> sorcerer",
      "Year of the Ox -> Grand Convergence",
      "ancestors -> stones",
      "time portal -> enchanted amulet",
      "Ox year -> year of Grand Convergence"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "596_1_silver_build_gates": {
    "name": "USACO 2016 January Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=596",
    "test_data_link": "http://www.usaco.org/current/data/gates_silver_jan16.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_gates_silver_jan16.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan16results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "596",
    "problem_id": "596_1_silver_build_gates",
    "description": "A Mars exploration droid is tasked to set up a communication network on Mars. It starts at position (0,0) on a grid map of Mars surface and follows a series of commands to move one unit north, south, east, or west. Each time the droid moves, it lays a communication cable along the path. For instance, if it first moves north, it places a cable from (0,0) to (0,1). The droid may cross its own path, laying multiple cables over the same segment, or revisit points multiple times, which might create separate regions on the grid that are isolated from each other by the cables. The mission control center needs the entire area to remain connected for seamless communication. Therefore, they plan to install wireless signal boosters at certain cable segments, which will allow signals to pass through the cables. Determine the minimum number of signal boosters needed to ensure all parts of the grid are interconnected. INPUT FORMAT (file mars.in): The first line of input contains $N$ ($1 \\leq N \\leq 1000$), the number of steps the droid takes. The following line contains a string of length $N$ describing the droid's path. Each character is either N (north), E (east), S (south), or W (west). OUTPUT FORMAT (file mars.out): Output a single integer representing the minimum number of signal boosters required to ensure complete connectivity across all grid regions. Note that the response could be zero if the grid is already fully connected. SAMPLE INPUT: 14 NNNESWWWSSEEEE SAMPLE OUTPUT: 2",
    "description_no_samples": "A Mars exploration droid is tasked to set up a communication network on Mars. It starts at position (0,0) on a grid map of Mars surface and follows a series of commands to move one unit north, south, east, or west. Each time the droid moves, it lays a communication cable along the path. For instance, if it first moves north, it places a cable from (0,0) to (0,1). The droid may cross its own path, laying multiple cables over the same segment, or revisit points multiple times, which might create separate regions on the grid that are isolated from each other by the cables. The mission control center needs the entire area to remain connected for seamless communication. Therefore, they plan to install wireless signal boosters at certain cable segments, which will allow signals to pass through the cables. Determine the minimum number of signal boosters needed to ensure all parts of the grid are interconnected. INPUT FORMAT (file mars.in): The first line of input contains $N$ ($1 \\leq N \\leq 1000$), the number of steps the droid takes. The following line contains a string of length $N$ describing the droid's path. Each character is either N (north), E (east), S (south), or W (west). OUTPUT FORMAT (file mars.out): Output a single integer representing the minimum number of signal boosters required to ensure complete connectivity across all grid regions. Note that the response could be zero if the grid is already fully connected. SAMPLE INPUT: 14 NNNESWWWSSEEEE SAMPLE OUTPUT: 2",
    "samples": [
      {
        "input": "14\nNNNESWWWSSEEEE",
        "output": "2"
      }
    ],
    "mapping": [
      "Farmer John -> Mars exploration droid",
      "fence -> communication cable",
      "gate -> signal booster",
      "farm -> grid map of Mars",
      "region -> grid area",
      "path -> command sequence",
      "step -> move",
      "build -> lay",
      "partitioned -> isolated",
      "connectivity -> communication"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1208_1_silver_email_filing": {
    "name": "Email Filing",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1208",
    "test_data_link": "http://www.usaco.org/current/data/prob3_silver_feb22.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob3_silver_feb22.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb22results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "silver",
    "cp_id": "1208",
    "problem_id": "1208_1_silver_email_filing",
    "description": "Chef Alex works in a grocery store and is responsible for shelving items. The store has M different shelves, numbered 1 to M (1 \u2264 M \u2264 10^4). There are N items that need to be shelved, numbered 1 to N (1 \u2264 N \u2264 10^5), and each item i must be placed on shelf s_i (1 \u2264 s_i \u2264 M). \n\nAlex can only see K (1 \u2264 K \u2264 min(N, M)) shelves and K items at a time on his small screen. Initially, the screen displays shelves 1 to K on the left and items 1 to K on the right. To access other shelves and items, Alex needs to scroll through the lists. For example, scrolling down one position in the list of shelves displays shelves 2 to K+1. If an item is placed on its designated shelf, it disappears from the list, causing the remaining items to shift up. For instance, if items 1, 2, 3, 4, 5 are displayed and item 3 is shelved, the list will show items 1, 2, 4, 5, 6.\n\nAlex's scrolling device is malfunctioning and can only scroll downwards. The only way to mimic upward scrolling is when Alex shelves one of the last K items, making the top item move up by one position. If fewer than K items are left, they will all be displayed.\n\nHelp Alex determine if he can shelve all items.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains T (1 \u2264 T \u2264 10), the number of subcases. Each subcase starts with a line containing M, N, and K, followed by a line with s_1 to s_N.\n\nThe sum of M across all subcases does not exceed 10^4, and the sum of N across all subcases does not exceed 10^5.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput T lines, each containing YES or NO, indicating if Alex can shelve all items in each subcase.",
    "num_tests": 12,
    "solution": "\n(Analysis by Nick Wu)\nBecause we cannot scroll up on the folders, we have some constraints on how far\ndown we must scroll in the emails before we can scroll down on the list of\nfolders. Specifically, we must always scroll down to at least email $E$ if the\ntopmost folder currently being looked at will need to have email $E$ filed to\nit.\nTherefore, as long as we do some bookkeeping, we can simulate this process\ncarefully. We'll maintain a collection of emails that have not yet been filed\nand are currently being scrolled through, as well as the collection of emails\nthat have been skipped so far. We'll also keep track of the earliest point of\ntime when an email can be filed.\nWe'll loop through the folders in order, keeping track of the topmost folder.\nWe'll also loop through the emails in order until we get to the last email that\nneeds to be filed for the given topmost folder. If having that email on screen\nwould cause the window to overflow, we have to mark the topmost email as\nskipped. Afterwards, if we can file the email, we should do so immediately.\nOtherwise, it sits in the window. \nIn the event we have looped through all the emails, we also have to simulate the\nbehavior of scrolling up through the emails that we previously skipped.\nMy C++ code:\n\n#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid rsolve() {\n  int nfolder, nemail, windowsz;\n  cin >> nfolder >> nemail >> windowsz;\n  vector<int> emailtofolder(nemail);\n  vector<vector<int>> foldertoemail(nfolder);\n  vector<vector<int>> filetiming(nfolder);\n  vector<bool> filed(nemail);\n  vector<bool> skipped(nemail);\n  vector<bool> inwindow(nemail);\n  for(int i = 0; i < nemail; i++) {\n    cin >> emailtofolder[i];\n    filetiming[max(0, --emailtofolder[i] - windowsz + 1)].push_back(i);\n    foldertoemail[emailtofolder[i]].push_back(i);\n  }\n  int currentemail = 0;\n  int lhsemail = 0;\n  int numinwindow = 0;\n  int rhsemail = nemail-1;\n  auto fileemail = [&](int id) -> void {\n    if(inwindow[id]) {\n      inwindow[id] = false;\n      numinwindow--;\n    }\n    assert(!filed[id]);\n    filed[id] = true;\n  };\n  int bottom = 0;\n  for(int i = 0; i < nfolder; i++) {\n    // file anything that can be newly filed\n    if(i > bottom && i + windowsz <= nfolder) bottom++;\n    for(int out: filetiming[i]) if(inwindow[out]) fileemail(out);\n    while(foldertoemail[i].size() && currentemail <= foldertoemail[i].back()) {\n      // the window is full so in order to consider this email, we must scroll past the current one\n      if(numinwindow == windowsz) {\n        while(!inwindow[lhsemail]) lhsemail++;\n        skipped[lhsemail] = true;\n        inwindow[lhsemail] = false;\n        numinwindow--;\n      }\n      if(emailtofolder[currentemail] >= i && emailtofolder[currentemail] <= i + windowsz - 1) {\n        // can file\n        filed[currentemail++] = true;\n        continue;\n      }\n      inwindow[currentemail++] = true; numinwindow++;\n    }\n    // scroll through emails that would be implicitly loaded\n    while(currentemail < nemail && numinwindow < windowsz) {\n      if(emailtofolder[currentemail] >= i && emailtofolder[currentemail] <= i + windowsz - 1) {\n        // can file\n        filed[currentemail++] = true;\n        continue;\n      }\n      inwindow[currentemail++] = true; numinwindow++;\n    }\n    // scroll up emails since we've hit the end\n    if(currentemail == nemail) {\n      while(numinwindow < windowsz) {\n        if(rhsemail < 0) break;\n        if(!skipped[rhsemail]) {\n          rhsemail--;\n          continue;\n        }\n        if(emailtofolder[rhsemail] < bottom) {\n          cout << \"NO\\n\";\n          return;\n        }\n        if(emailtofolder[rhsemail] <= bottom + windowsz - 1) {\n          filed[rhsemail--] = true;\n          continue;\n        }\n        inwindow[rhsemail--] = true; numinwindow++;\n      }\n    }\n  }\n  for(auto out: filed) {\n    if(!out) {\n      cout << \"NO\\n\";\n      return;\n    }\n  }\n  cout << \"YES\\n\";\n}\n \nvoid solve() {\n  int t;\n  cin >> t;\n  while(t--) rsolve();\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  solve();\n}\n\nDanny Mittal's Java code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n \npublic class EmailFiling {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        for (int t = Integer.parseInt(in.readLine()); t > 0; t--) {\n            StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n            int m = Integer.parseInt(tokenizer.nextToken());\n            int n = Integer.parseInt(tokenizer.nextToken());\n            int k = Integer.parseInt(tokenizer.nextToken());\n            tokenizer = new StringTokenizer(in.readLine());\n            int[] folder = new int[n];\n            int[] rem = new int[m];\n            for (int j = 0; j < n; j++) {\n                folder[j] = Integer.parseInt(tokenizer.nextToken()) - 1;\n                rem[folder[j]]++;\n            }\n            int firstFolder = 0;\n            int firstEmail = 0;\n            int lastEmail = k - 1;\n            boolean[] filed = new boolean[n];\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparingInt(j -> folder[j]));\n            for (int j = 0; j < k; j++) {\n                pq.add(j);\n            }\n            while (lastEmail < n - 1 && firstFolder < m) {\n                if (rem[firstFolder] == 0) {\n                    firstFolder++;\n                } else if (!pq.isEmpty() && folder[pq.peek()] < firstFolder + k) {\n                    int j = pq.remove();\n                    if (j >= firstEmail) {\n                        filed[j] = true;\n                        rem[folder[j]]--;\n                        lastEmail++;\n                        pq.add(lastEmail);\n                    }\n                } else {\n                    while (firstEmail < n && filed[firstEmail]) {\n                        firstEmail++;\n                    }\n                    firstEmail++;\n                    lastEmail++;\n                    pq.add(lastEmail);\n                }\n            }\n            String answer = \"YES\";\n            while (firstFolder < m) {\n                if (rem[firstFolder] == 0) {\n                    firstFolder++;\n                } else {\n                    if (pq.isEmpty()) {\n                        answer = \"NO\";\n                        break;\n                    }\n                    int j = pq.remove();\n                    if (j >= firstEmail && !filed[j]) {\n                        if (folder[j] >= firstFolder + k) {\n                            answer = \"NO\";\n                            break;\n                        }\n                        filed[j] = true;\n                        rem[folder[j]]--;\n                        while (firstEmail > 0) {\n                            firstEmail--;\n                            if (!filed[firstEmail]) {\n                                pq.add(firstEmail);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            out.append(answer).append('\\n');\n        }\n        System.out.print(out);\n    }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "6\n5 5 1\n1 2 3 4 5\n5 5 1\n1 2 3 5 4\n5 5 1\n1 2 4 5 3\n5 5 2\n1 2 4 5 3\n3 10 2\n1 3 2 1 3 2 1 3 2 1\n3 10 1\n1 3 2 1 3 2 1 3 2 1\n",
        "output": "YES\nYES\nNO\nYES\nYES\nNO\n"
      }
    ],
    "description_no_samples": "Chef Alex works in a grocery store and is responsible for shelving items. The store has M different shelves, numbered 1 to M (1 \u2264 M \u2264 10^4). There are N items that need to be shelved, numbered 1 to N (1 \u2264 N \u2264 10^5), and each item i must be placed on shelf s_i (1 \u2264 s_i \u2264 M). \n\nAlex can only see K (1 \u2264 K \u2264 min(N, M)) shelves and K items at a time on his small screen. Initially, the screen displays shelves 1 to K on the left and items 1 to K on the right. To access other shelves and items, Alex needs to scroll through the lists. For example, scrolling down one position in the list of shelves displays shelves 2 to K+1. If an item is placed on its designated shelf, it disappears from the list, causing the remaining items to shift up. For instance, if items 1, 2, 3, 4, 5 are displayed and item 3 is shelved, the list will show items 1, 2, 4, 5, 6.\n\nAlex's scrolling device is malfunctioning and can only scroll downwards. The only way to mimic upward scrolling is when Alex shelves one of the last K items, making the top item move up by one position. If fewer than K items are left, they will all be displayed.\n\nHelp Alex determine if he can shelve all items.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains T (1 \u2264 T \u2264 10), the number of subcases. Each subcase starts with a line containing M, N, and K, followed by a line with s_1 to s_N.\n\nThe sum of M across all subcases does not exceed 10^4, and the sum of N across all subcases does not exceed 10^5.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput T lines, each containing YES or NO, indicating if Alex can shelve all items in each subcase.",
    "num_samples": 1,
    "mapping": [
      "folders -> shelves",
      "emails -> items",
      "Farmer John (FJ) -> Chef Alex",
      "email filing -> shelving items",
      "f_i (folder for email i) -> s_i (shelf for item i)"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "619_1_silver_load_balancing": {
    "name": "USACO 2016 February Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=619",
    "test_data_link": "http://www.usaco.org/current/data/balancing_silver_feb16.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_balancing_silver_feb16.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb16results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "619",
    "problem_id": "619_1_silver_load_balancing",
    "description": "In the bustling city park, there are $N$ artist stalls set up at distinct locations $(x_1, y_1) \\ldots (x_n, y_n)$ on a two-dimensional grid ($1 \\leq N \\leq 1000$, and the $x_i$'s and $y_i$'s are positive odd integers with a maximum size of 1,000,000). The park manager wants to divide the park into four zones by placing a vertical fence with the equation $x=a$ (where $a$ will be an even integer, ensuring no fence cuts through a stall) and a horizontal fence with the equation $y=b$ (where $b$ is also an even integer). The intersection of these fences at $(a,b)$ will partition the park into four zones. The manager aims to balance the distribution of stalls across these zones, minimizing the maximum number of stalls in any single zone. Let $M$ be this maximum number, and help the manager find the smallest possible value of $M$. INPUT FORMAT (file park_zoning.in): The first line of the input contains a single integer, $N$. The following $N$ lines each contain the coordinates of a stall, specifying its $x$ and $y$ coordinates. OUTPUT FORMAT (file park_zoning.out): Output the smallest possible value of $M$ that the manager can achieve by optimally positioning the fences. SAMPLE INPUT: 7 7 3 5 5 7 13 3 1 11 7 5 3 9 1 SAMPLE OUTPUT: 2",
    "description_no_samples": "In the bustling city park, there are $N$ artist stalls set up at distinct locations $(x_1, y_1) \\ldots (x_n, y_n)$ on a two-dimensional grid ($1 \\leq N \\leq 1000$, and the $x_i$'s and $y_i$'s are positive odd integers with a maximum size of 1,000,000). The park manager wants to divide the park into four zones by placing a vertical fence with the equation $x=a$ (where $a$ will be an even integer, ensuring no fence cuts through a stall) and a horizontal fence with the equation $y=b$ (where $b$ is also an even integer). The intersection of these fences at $(a,b)$ will partition the park into four zones. The manager aims to balance the distribution of stalls across these zones, minimizing the maximum number of stalls in any single zone. Let $M$ be this maximum number, and help the manager find the smallest possible value of $M$. INPUT FORMAT (file park_zoning.in): The first line of the input contains a single integer, $N$. The following $N$ lines each contain the coordinates of a stall, specifying its $x$ and $y$ coordinates. OUTPUT FORMAT (file park_zoning.out): Output the smallest possible value of $M$ that the manager can achieve by optimally positioning the fences. SAMPLE INPUT: 7 7 3 5 5 7 13 3 1 11 7 5 3 9 1 SAMPLE OUTPUT: 2",
    "samples": [
      {
        "input": "7\n7 3\n5 5\n7 13\n3 1\n11 7\n5 3\n9 1\n",
        "output": "2\n"
      }
    ],
    "mapping": [
      "cows -> artist stalls",
      "Farmer John -> park manager",
      "farm -> park",
      "north-south fence -> vertical fence",
      "east-west fence -> horizontal fence",
      "field -> park",
      "balanced -> distribution",
      "region -> zone"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "512_1_silver_cow_routing": {
    "name": "USACO 2015 January Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=512",
    "test_data_link": "http://www.usaco.org/current/data/cowroute_silver.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_cowroute_silver.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan15results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "512",
    "problem_id": "512_1_silver_cow_routing",
    "description": "Problem 2: Desert Oasis Expedition\n\nSeeking solace from the bustling city life, Alex the explorer plans to\nvisit a serene oasis in the vast desert. Unfortunately, he\nfinds that only one company, Desert Safari Tours, offers\nexpeditions to the oasis, and that these expeditions have a somewhat complex structure.\n\nDesert Safari Tours owns N caravans (1 <= N <= 1000), each of which travels on a specific \"path\" consisting of two or more oasis points. For example, one caravan might travel on a path that starts at oasis 1, then continues to oasis 5, then moves to oasis 2, and then finally reaches oasis 8. No oasis point appears multiple times in a path. If Alex chooses to join a path, he can start at any oasis along the path and then end at\nany oasis later along the path. He does not need to start at the\nfirst oasis or end at the last oasis. Each path has a certain\ncost, which Alex must pay if he uses any part of the path,\nirrespective of the number of oasis points he visits along the path. If\nAlex uses a path multiple times during his travel (that is, if he\nleaves the path and later comes back to use it from another oasis\npoint), he must pay for it each time it is used.\n\nAlex would like to find the cheapest way to travel from his home\nstation (oasis A) to the serene oasis (oasis B). Please help him\ndetermine the minimum cost he must pay, and also the smallest\nnumber of individual caravan journeys he must take to achieve this minimum\ncost.\n\nINPUT: (file expedition.in)\n\nThe first line of input contains A, B, and N, separated by spaces.\n\nThe next 2N lines describe the available paths, in two lines per\npath. The first line contains the cost of using the path (an integer\nin the range 1..1,000,000,000), and the number of oasis points along the\npath (an integer in the range 1..100). The second line contains a\nlist of the oasis points in order along the path. Each oasis point is identified\nby an integer in the range 1..1000. Note that the cost of an\nitinerary can easily add up to more than can fit into a 32-bit\ninteger, so you should probably use 64-bit integers (e.g., \"long long\"\nintegers in C/C++).\n\nSAMPLE INPUT:\n\n3 4 3\n3 5\n1 2 3 4 5\n2 3\n3 5 4\n1 2\n1 5\n\nOUTPUT: (file expedition.out)\n\nOutput the minimum cost of an itinerary that Alex can use to travel\nfrom oasis A to oasis B, as well as the minimum number of individual\ncaravan journeys required to achieve this minimum cost. If there is no\nsolution, output \"-1 -1\" (quotes for clarity) on a single line.\n\nSAMPLE OUTPUT:\n\n2 2\n",
    "description_no_samples": "Problem 2: Desert Oasis Expedition\n\nSeeking solace from the bustling city life, Alex the explorer plans to\nvisit a serene oasis in the vast desert. Unfortunately, he\nfinds that only one company, Desert Safari Tours, offers\nexpeditions to the oasis, and that these expeditions have a somewhat complex structure.\n\nDesert Safari Tours owns N caravans (1 <= N <= 1000), each of which travels on a specific \"path\" consisting of two or more oasis points. For example, one caravan might travel on a path that starts at oasis 1, then continues to oasis 5, then moves to oasis 2, and then finally reaches oasis 8. No oasis point appears multiple times in a path. If Alex chooses to join a path, he can start at any oasis along the path and then end at\nany oasis later along the path. He does not need to start at the\nfirst oasis or end at the last oasis. Each path has a certain\ncost, which Alex must pay if he uses any part of the path,\nirrespective of the number of oasis points he visits along the path. If\nAlex uses a path multiple times during his travel (that is, if he\nleaves the path and later comes back to use it from another oasis\npoint), he must pay for it each time it is used.\n\nAlex would like to find the cheapest way to travel from his home\nstation (oasis A) to the serene oasis (oasis B). Please help him\ndetermine the minimum cost he must pay, and also the smallest\nnumber of individual caravan journeys he must take to achieve this minimum\ncost.\n\nINPUT: (file expedition.in)\n\nThe first line of input contains A, B, and N, separated by spaces.\n\nThe next 2N lines describe the available paths, in two lines per\npath. The first line contains the cost of using the path (an integer\nin the range 1..1,000,000,000), and the number of oasis points along the\npath (an integer in the range 1..100). The second line contains a\nlist of the oasis points in order along the path. Each oasis point is identified\nby an integer in the range 1..1000. Note that the cost of an\nitinerary can easily add up to more than can fit into a 32-bit\ninteger, so you should probably use 64-bit integers (e.g., \"long long\"\nintegers in C/C++).\n\nSAMPLE INPUT:\n\n3 4 3\n3 5\n1 2 3 4 5\n2 3\n3 5 4\n1 2\n1 5\n\nOUTPUT: (file expedition.out)\n\nOutput the minimum cost of an itinerary that Alex can use to travel\nfrom oasis A to oasis B, as well as the minimum number of individual\ncaravan journeys required to achieve this minimum cost. If there is no\nsolution, output \"-1 -1\" (quotes for clarity) on a single line.\n\nSAMPLE OUTPUT:\n\n2 2\n",
    "samples": [
      {
        "input": "3 4 3\n3 5\n1 2 3 4 5\n2 3\n3 5 4\n1 2\n1 5\n",
        "output": "2 2\n"
      }
    ],
    "mapping": [
      "Bessie the cow -> Alex the explorer",
      "Air Bovinia -> Desert Safari Tours",
      "planes -> caravans",
      "route -> path",
      "city -> oasis point",
      "flight -> caravan journey",
      "farm -> home station",
      "tropical destination -> serene oasis"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "967_1_silver_meetings": {
    "name": "Meetings",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=967",
    "test_data_link": "http://www.usaco.org/current/data/meetings_silver_dec19.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_meetings_silver_dec19.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec19results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "silver",
    "cp_id": "967",
    "problem_id": "967_1_silver_meetings",
    "description": "In a futuristic dance floor, a line is marked between points 0 and L (1 \u2264 L \u2264 10^9). There are N robots (1 \u2264 N \u2264 5\u22c510^4) placed at distinct spots along this line, where the points are represented as positions. Each robot i begins at a location y_i and is moving either left or right at a speed of one unit per second, indicated by an integer m_i which is either 1 (moving right) or -1 (moving left). Each robot also has a dance score s_i ranging from [1, 10^3]. Robots continue to move at a constant speed until one of these events occurs: If robot i reaches either end of the dance floor (point 0 or L), it stops dancing. A 'dance connection' happens when two robots i and j meet at the same point that is not an endpoint of the dance floor. In this case, robot i takes the movement direction of robot j and vice versa. Note that robots may connect at non-integer points. Let T be the earliest moment when the sum of the dance scores of the robots that have stopped dancing (by reaching an endpoint) is at least half of the total dance scores of all robots. Please determine the total number of dance connections between pairs of robots from time 0 to T (including at time T).\n\nSCORING:\nTest cases 2-4 satisfy N \u2264 100 and s_i = 1 for all i. Test cases 5-7 satisfy N \u2264 100.\n\nINPUT FORMAT:\nThe first line contains two space-separated integers N and L.\n\nThe next N lines each contain three space-separated integers s_i, y_i, and m_i. All locations y_i are distinct and satisfy 0 < y_i < L.\n\nOUTPUT FORMAT:\nPrint a single line containing the answer.",
    "num_tests": 13,
    "solution": "\n(Analysis by Benjamin Qi)\nNote: This problem is quite tricky for silver!\nFirst, sort all the cows by $x$-coordinate. For partial credit, we can simulate\neach collision that the cows make in $O(N),$ for a worst-case runtime of\n$O(N^3).$\nTo make solving the problem in $O(N\\log N)$ more manageable, let's split it into\ntwo independent parts.\nPart 1: Determining $T.$\nConsider the multiset of all times when the cows reach the barns. If the cows \ndid not actually switch velocities, \nCows with $d_i=-1$ contribute $x_i$ to the multiset.Cows with $d_i=1$ contribute $L-x_i$ to the multiset.\nNevertheless, this multiset remains the same regardless of whether cows switch\nvelocities or not.\nLet $z$ be the number of cows with $d_i=-1.$ Then exactly $z$ cows reach the\nleft barn,  so these must be precisely the $z$ leftmost cows. Thus, we can just\ntake all of the $x_i$ for the cows with initial $d_i=-1$ and set these equal to\nthe finishing times of the $z$ leftmost cows. Similarly, we can just take all of\nthe $L-x_i$ for cows with initial $d_i=1$ and set these equal to the finishing\ntimes of the $N-z$ rightmost cows. After this, we can sort all the finishing\ntimes again and maintain the current total weight in order to determine $T.$\nPart 2: Determining the number of meetings.\nNow we can ignore the weight condition and assume that cows do not switch\nvelocities after meeting; essentially, they will pass through each other. This\nwill not affect the answer. Then two cows with $x_i<x_j$ will meet if\n$d_i=1, d_j=-1, x_i+2T\\ge x_j.$ The number of such pairs can be computed by\niterating from left to right and maintaining a queue that consists of those cows\nwith $d_i=1$ that you are currently considering as meeting candidates.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi; \ntypedef vector<pair<int,int>> vpi; \n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \n#define pb push_back\n#define rsz resize\n#define sz(x) int(x.size())\n#define all(x) begin(x), end(x)\n#define f first\n#define s second\n\nvoid setIO(string name) {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfreopen((name+\".in\").c_str(),\"r\",stdin);\n\tfreopen((name+\".out\").c_str(),\"w\",stdout);\n}\n\nint N,L;\nvi w,x,d;\n \nvoid init() {\n\tsetIO(\"meetings\");\n\tcin >> N >> L;\n\tw.rsz(N), x.rsz(N), d.rsz(N);\n\tF0R(i,N) cin >> w[i] >> x[i] >> d[i];\n\tvi inds(N); iota(all(inds),0);\n\tsort(all(inds),[](int a, int b) { return x[a] < x[b]; });\n\tvi W,X,D;\n\ttrav(t,inds) {\n\t\tW.pb(w[t]);\n\t\tX.pb(x[t]);\n\t\tD.pb(d[t]);\n\t}\n\tswap(w,W), swap(x,X), swap(d,D);\n}\n \nint getTime() {\n\tvi lef, rig;\n\tF0R(i,N) {\n\t\tif (d[i] == -1) lef.pb(x[i]);\n\t\telse rig.pb(x[i]);\n\t}\n\tvpi v;\n\tF0R(i,sz(lef)) v.pb({lef[i],w[i]});\n\tF0R(i,sz(rig)) v.pb({L-rig[i],w[sz(lef)+i]});\n\tsort(all(v));\n\tint tot = 0; trav(t,v) tot += t.s;\n\ttrav(t,v) {\n\t\ttot -= 2*t.s;\n\t\tif (tot <= 0) return t.f;\n\t}\n}\n \nint main() {\n\tinit();\n\tint t = getTime(); \n\tqueue<int> rig;\n\tint ans = 0;\n\tF0R(i,N) {\n\t\tif (d[i] == -1) {\n\t\t\twhile (sz(rig) && rig.front()+2*t < x[i]) rig.pop();\n\t\t\tans += sz(rig);\n\t\t} else rig.push(x[i]);\n\t}\n\tcout << ans << \"\\n\";\n}\n\nFor some more problems in the same spirit see \n Independence #20 \nAnts on a Circle (AtCoder)\n  Ants\non a Circle (CodeForces) \n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 5\n1 1 1\n2 2 -1\n3 3 -1",
        "output": "2"
      }
    ],
    "description_no_samples": "In a futuristic dance floor, a line is marked between points 0 and L (1 \u2264 L \u2264 10^9). There are N robots (1 \u2264 N \u2264 5\u22c510^4) placed at distinct spots along this line, where the points are represented as positions. Each robot i begins at a location y_i and is moving either left or right at a speed of one unit per second, indicated by an integer m_i which is either 1 (moving right) or -1 (moving left). Each robot also has a dance score s_i ranging from [1, 10^3]. Robots continue to move at a constant speed until one of these events occurs: If robot i reaches either end of the dance floor (point 0 or L), it stops dancing. A 'dance connection' happens when two robots i and j meet at the same point that is not an endpoint of the dance floor. In this case, robot i takes the movement direction of robot j and vice versa. Note that robots may connect at non-integer points. Let T be the earliest moment when the sum of the dance scores of the robots that have stopped dancing (by reaching an endpoint) is at least half of the total dance scores of all robots. Please determine the total number of dance connections between pairs of robots from time 0 to T (including at time T).\n\nSCORING:\nTest cases 2-4 satisfy N \u2264 100 and s_i = 1 for all i. Test cases 5-7 satisfy N \u2264 100.\n\nINPUT FORMAT:\nThe first line contains two space-separated integers N and L.\n\nThe next N lines each contain three space-separated integers s_i, y_i, and m_i. All locations y_i are distinct and satisfy 0 < y_i < L.\n\nOUTPUT FORMAT:\nPrint a single line containing the answer.",
    "num_samples": 1,
    "mapping": [
      "barns -> endpoints of the dance floor",
      "cows -> robots",
      "position -> location",
      "weight -> dance score",
      "velocity -> movement direction",
      "meeting -> dance connection",
      "x_i (position of cow i) -> y_i (location of robot i)",
      "w_i (weight of cow i) -> s_i (dance score of robot i)",
      "d_i (direction of cow i) -> m_i (movement direction of robot i)"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    # Input format has not changed, identity transformation\n    return text\n\ndef transform_output(text: str) -> str:\n    # Output format has not changed, identity transformation\n    return text\n"
  },
  "1351_1_silver_cycle_correspondence": {
    "name": "USACO 2023 December Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1351",
    "test_data_link": "http://www.usaco.org/current/data/prob2_silver_dec23.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_silver_dec23.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec23results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "1351",
    "problem_id": "1351_1_silver_cycle_correspondence",
    "description": "In the distant future, two alien species, the Xylox and the Zynex, are trying to synchronize their communication channels. The Xylox have $N$ communication nodes ($3 \\le N \\le 5 \\cdot 10^5$), and they have configured $K$ ($3 \\le K \\le N$) distinct pairs of nodes to form a communication loop. The Xylox assign each node a unique identifier from the range $[1, N]$, and these nodes, identified by $x_1, \\dots, x_K$, are connected in a loop, meaning that node $x_i$ is directly linked to node $x_{i+1}$ for all $1 \\le i < K$, and node $x_K$ is linked back to node $x_1$. All identifiers $x_i$ are distinct. Similarly, the Zynex species assign each of their communication nodes a unique identifier from the range $[1, N]$, and the nodes with identifiers $z_1, \\dots, z_K$ also form a communication loop. All identifiers $z_i$ are distinct. It is possible that some (none or all) nodes have been assigned the same identifier by both species. Determine the maximum number of nodes that can have the same identifier by both Xylox and Zynex. INPUT FORMAT (input arrives from the terminal / stdin): The first line contains $N$ and $K$. The next line contains $x_1, \\dots, x_K$. The next line contains $z_1, \\dots, z_K$. OUTPUT FORMAT (print output to the terminal / stdout): The maximum number of nodes that can have the same identifier. SAMPLE INPUT: 6 3 1 2 3 2 3 1 SAMPLE OUTPUT: 6 Here, every node could have been assigned the same identifier by both species. SAMPLE INPUT: 6 3 1 2 3 4 5 6 SAMPLE OUTPUT: 0 Here, no node could have been assigned the same identifier by both species. SAMPLE INPUT: 6 4 1 2 3 4 4 3 2 5 SAMPLE OUTPUT: 4 Identifiers $2,3,4,6$ can be aligned for the same nodes.",
    "description_no_samples": "In the distant future, two alien species, the Xylox and the Zynex, are trying to synchronize their communication channels. The Xylox have $N$ communication nodes ($3 \\le N \\le 5 \\cdot 10^5$), and they have configured $K$ ($3 \\le K \\le N$) distinct pairs of nodes to form a communication loop. The Xylox assign each node a unique identifier from the range $[1, N]$, and these nodes, identified by $x_1, \\dots, x_K$, are connected in a loop, meaning that node $x_i$ is directly linked to node $x_{i+1}$ for all $1 \\le i < K$, and node $x_K$ is linked back to node $x_1$. All identifiers $x_i$ are distinct. Similarly, the Zynex species assign each of their communication nodes a unique identifier from the range $[1, N]$, and the nodes with identifiers $z_1, \\dots, z_K$ also form a communication loop. All identifiers $z_i$ are distinct. It is possible that some (none or all) nodes have been assigned the same identifier by both species. Determine the maximum number of nodes that can have the same identifier by both Xylox and Zynex. INPUT FORMAT (input arrives from the terminal / stdin): The first line contains $N$ and $K$. The next line contains $x_1, \\dots, x_K$. The next line contains $z_1, \\dots, z_K$. OUTPUT FORMAT (print output to the terminal / stdout): The maximum number of nodes that can have the same identifier. SAMPLE INPUT: 6 3 1 2 3 2 3 1 SAMPLE OUTPUT: 6 Here, every node could have been assigned the same identifier by both species. SAMPLE INPUT: 6 3 1 2 3 4 5 6 SAMPLE OUTPUT: 0 Here, no node could have been assigned the same identifier by both species. SAMPLE INPUT: 6 4 1 2 3 4 4 3 2 5 SAMPLE OUTPUT: 4 Identifiers $2,3,4,6$ can be aligned for the same nodes.",
    "samples": [
      {
        "input": "6 3\n1 2 3\n2 3 1",
        "output": "6"
      }
    ],
    "mapping": [
      "barns -> communication nodes",
      "Annabelle -> Xylox",
      "Bessie -> Zynex",
      "a_i -> x_i",
      "b_i -> z_i",
      "fixed points -> nodes with same identifier"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "125_1_silver_flowerpot": {
    "name": "Flowerpot",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=125",
    "test_data_link": "http://www.usaco.org/current/data/fpot.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_fpot.html",
    "contest_link": "http://www.usaco.org/index.php?page=mar12results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=mar12problems",
    "problem_level": "silver",
    "cp_id": "125",
    "problem_id": "125_1_silver_flowerpot",
    "description": "Problem 2: Asteroid Shield [Brian Dean, 2012]\n\nCaptain John is in charge of protecting his space station from incoming asteroids. You are given the trajectories of N asteroids (1 <= N <= 100,000) in space, where y represents vertical height of the asteroid, and x represents its location over a 1D spatial line:  \n\nEach asteroid moves towards the x-axis at a rate of 1 unit per second. You want to deploy Captain John's protective shield of width W somewhere along the x-axis so that the time difference between the first asteroid to hit the shield and the last asteroid to hit the shield is at least some amount D (to ensure the shield can protect the station for sufficient time). An asteroid that lands just on the edge of the shield counts as hitting the shield.\n\nGiven the value of D and the trajectories of the N asteroids, please compute the minimum possible width of the shield.\n\nPROBLEM NAME: ashield\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers, N and D.  (1 <= D <= 1,000,000)\n\n* Lines 2..1+N: Line i+1 contains the space-separated (x,y) coordinates of asteroid i, each value in the range 0...1,000,000.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer, giving the minimum possible width of the shield. Output -1 if it is not possible to build a shield wide enough to intercept asteroids for at least D units of time.",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes: We first sort all the points on x, then\nsweep a pair of vertical \"sweep lines\" from left to right through the\nscene.  The y values of points between the sweep lines are stored in a\ndata structure that can quickly find the min and max, such as an STL \nmultiset (which we have used below) or a pair of priority queues.\nWhenever the difference between the max and min y coordinates is at\nleast D, we check if this represents the best flowerpot width so far,\nand then advance the left sweep line; otherwise, we advance the right\nsweep line.  The total running time is O(N log N). \n\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <vector>\n#define INF 2000000000\n\nusing namespace std;\n\ntypedef pair<int,int> Point;\nmultiset<int> Window;\nint N, D;\n\nint get_min(void) { return *(Window.begin()); } \nint get_max(void) { return *(Window.rbegin()); }\n\nint main(void)\n{\n  int i, j, x, y, ans=INF;\n  vector<Point> P;\n  \n  freopen (\"fpot.in\", \"r\", stdin);\n  freopen (\"fpot.out\", \"w\", stdout);\n  \n  scanf (\"%d %d\", &N, &D);\n  for (i=0; i<N; i++) {\n    scanf (\"%d %d\", &x, &y);\n    P.push_back(make_pair(x,y));\n  }\n  sort(&P[0], &P[N]);\n\n  i=j=0;\n  Window.insert(P[0].second);\n  while(1) {\n    if (get_max() - get_min() >= D) {\n      if (P[j].first-P[i].first < ans) ans = P[j].first-P[i].first;\n      multiset<nt>::iterator iter(Window.find(P[i++].second));\n      Window.erase(iter);\n    } else { \n      if (j==N-1) break;\n      Window.insert(P[++j].second);\n    }\n  }\n\n  printf (\"%d\\n\", ans==INF ? -1 : ans);\n  \n  return 0;\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4 5\n6 3\n2 4\n4 10\n12 15\n",
        "output": "2\n"
      }
    ],
    "description_no_samples": "Problem 2: Asteroid Shield [Brian Dean, 2012]\n\nCaptain John is in charge of protecting his space station from incoming asteroids. You are given the trajectories of N asteroids (1 <= N <= 100,000) in space, where y represents vertical height of the asteroid, and x represents its location over a 1D spatial line:  \n\nEach asteroid moves towards the x-axis at a rate of 1 unit per second. You want to deploy Captain John's protective shield of width W somewhere along the x-axis so that the time difference between the first asteroid to hit the shield and the last asteroid to hit the shield is at least some amount D (to ensure the shield can protect the station for sufficient time). An asteroid that lands just on the edge of the shield counts as hitting the shield.\n\nGiven the value of D and the trajectories of the N asteroids, please compute the minimum possible width of the shield.\n\nPROBLEM NAME: ashield\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers, N and D.  (1 <= D <= 1,000,000)\n\n* Lines 2..1+N: Line i+1 contains the space-separated (x,y) coordinates of asteroid i, each value in the range 0...1,000,000.\n\nOUTPUT FORMAT:\n\n* Line 1: A single integer, giving the minimum possible width of the shield. Output -1 if it is not possible to build a shield wide enough to intercept asteroids for at least D units of time.",
    "description_raw": "Problem 2: Flowerpot [Brian Dean, 2012]\n\nFarmer John has been having trouble making his plants grow, and needs your\nhelp to water them properly.  You are given the locations of N raindrops  \n(1 <= N <= 100,000) in the 2D plane, where y represents vertical height of\nthe drop, and x represents its location over a 1D number line:  \n\n\n\nEach drop falls downward (towards the x axis) at a rate of 1 unit per\nsecond.  You would like to place Farmer John's flowerpot of width W\nsomewhere along the x axis so that the difference in time between the\nfirst raindrop to hit the flowerpot and the last raindrop to hit the\nflowerpot is at least some amount D (so that the flowers in the pot receive\nplenty of water).  A drop of water that lands just on the edge of the\nflowerpot counts as hitting the flowerpot.\n\nGiven the value of D and the locations of the N raindrops, please compute\nthe minimum possible value of W.\n\nPROBLEM NAME: fpot",
    "input_format": "* Line 1: Two space-separated integers, N and D.  (1 <= D <=\n        1,000,000)\n\n* Lines 2..1+N: Line i+1 contains the space-separated (x,y)\n        coordinates of raindrop i, each value in the range\n        0...1,000,000.",
    "output_format": "* Line 1: A single integer, giving the minimum possible width of the\n        flowerpot.  Output -1 if it is not possible to build a\n        flowerpot wide enough to capture rain for at least D units of\n        time.",
    "num_samples": 1,
    "mapping": [
      "Farmer John -> Captain John",
      "plants -> space station",
      "raindrops -> asteroids",
      "flowerpot -> shield"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1400_1_silver_moorbles": {
    "name": "USACO 2024 February Contest, Silver",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1400",
    "test_data_link": "http://www.usaco.org/current/data/prob3_silver_feb24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob3_silver_feb24.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb24results",
    "inner_contest_link": null,
    "problem_level": "silver",
    "cp_id": "1400",
    "problem_id": "1400_1_silver_moorbles",
    "description": "You are tasked with guarding a treasure chest from a series of treasure hunters. The challenge is as follows: You start with a certain number of treasure coins. Each turn, one of the treasure hunters will attempt to steal some coins. On each turn, a hunter will announce a number of coins they intend to take, and you must decide whether the announced number is Prime or Composite. If you guess correctly, you keep your coins. If you guess incorrectly, the hunter takes the coins from your stash. If you have fewer coins than the announced number, the hunter takes all your remaining coins. The game ends when you lose all your coins. After some rounds, you have $C$ $(1 \\leq C \\leq 10^9)$ coins left. You are aiming to survive as many turns as possible. Over time, you've gathered intelligence on the hunters and know that on each turn, there are only $K$ $(1 \\leq K \\leq 4)$ different amounts of coins they might announce. The hunters plan to attempt $M$ $(1 \\leq M \\leq 3 \\cdot 10^5)$ rounds before they give up. Can you determine a lexicographically smallest sequence of guesses such that you won't lose all your coins, regardless of the hunters' actions? INPUT FORMAT (input arrives from the terminal / stdin): The first line contains a single integer $T$ ($1 \\leq T \\leq 10$) representing the number of test cases. Each test case is described as follows: First, one line containing three integers $C$, $M$, and $K$, representing the number of coins you have, the number of turns, and the number of potential guesses the hunters can make respectively. Then, $M$ lines where line $i$ contains $K$ distinct space-separated integers $d_{i,1} \\; d_{i,2} \\ldots d_{i,K}$ ($1 \\leq d_{i, j} \\leq 10^3$) representing the possible amounts of coins the hunters might announce on turn $i$. It is guaranteed that the sum of $M$ over all test cases is at most $3 \\cdot 10^5$. OUTPUT FORMAT (print output to the terminal / stdout): For each test case, output the lexicographically smallest sequence of guesses for you to guarantee not losing all your coins, or $-1$ if it is impossible. The guess sequence should be on a single line and consist of $M$ space-separated tokens each equal to either \"Prime\" or \"Composite\". Note: \"Prime\" is lexicographically smaller than \"Composite\". SAMPLE INPUT: 2 10 3 2 2 5 1 3 1 3 10 3 3 2 7 5 8 3 4 2 5 6 SAMPLE OUTPUT: Prime Prime Composite -1 In the first case, the only lexicographically smaller sequence of guesses is \"Prime Prime Prime\", but the hunters can make you lose in that case by first announcing $5$, which reduces your coins from $10$ to $5$, then announcing $3$, which reduces your coins from $5$ to $2$, then announcing $3$, which wipes out all of your coins. If you instead play the correct guess sequence \"Prime Prime Composite\", then if the hunters announce the same way, at the end when they announce $3$, you will gain those $3$ coins, increasing your stash to $5$. It can further be shown that the hunters cannot announce differently to take all of your coins given that you guess \"Prime Prime Composite\". In the second case, it can be shown that for any guess sequence you could choose, the hunters can announce in a way to take all of your coins. SAMPLE INPUT: 1 20 8 2 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 SAMPLE OUTPUT: Prime Prime Prime Composite Prime Composite Prime Composite",
    "description_no_samples": "You are tasked with guarding a treasure chest from a series of treasure hunters. The challenge is as follows: You start with a certain number of treasure coins. Each turn, one of the treasure hunters will attempt to steal some coins. On each turn, a hunter will announce a number of coins they intend to take, and you must decide whether the announced number is Prime or Composite. If you guess correctly, you keep your coins. If you guess incorrectly, the hunter takes the coins from your stash. If you have fewer coins than the announced number, the hunter takes all your remaining coins. The game ends when you lose all your coins. After some rounds, you have $C$ $(1 \\leq C \\leq 10^9)$ coins left. You are aiming to survive as many turns as possible. Over time, you've gathered intelligence on the hunters and know that on each turn, there are only $K$ $(1 \\leq K \\leq 4)$ different amounts of coins they might announce. The hunters plan to attempt $M$ $(1 \\leq M \\leq 3 \\cdot 10^5)$ rounds before they give up. Can you determine a lexicographically smallest sequence of guesses such that you won't lose all your coins, regardless of the hunters' actions? INPUT FORMAT (input arrives from the terminal / stdin): The first line contains a single integer $T$ ($1 \\leq T \\leq 10$) representing the number of test cases. Each test case is described as follows: First, one line containing three integers $C$, $M$, and $K$, representing the number of coins you have, the number of turns, and the number of potential guesses the hunters can make respectively. Then, $M$ lines where line $i$ contains $K$ distinct space-separated integers $d_{i,1} \\; d_{i,2} \\ldots d_{i,K}$ ($1 \\leq d_{i, j} \\leq 10^3$) representing the possible amounts of coins the hunters might announce on turn $i$. It is guaranteed that the sum of $M$ over all test cases is at most $3 \\cdot 10^5$. OUTPUT FORMAT (print output to the terminal / stdout): For each test case, output the lexicographically smallest sequence of guesses for you to guarantee not losing all your coins, or $-1$ if it is impossible. The guess sequence should be on a single line and consist of $M$ space-separated tokens each equal to either \"Prime\" or \"Composite\". Note: \"Prime\" is lexicographically smaller than \"Composite\". SAMPLE INPUT: 2 10 3 2 2 5 1 3 1 3 10 3 3 2 7 5 8 3 4 2 5 6 SAMPLE OUTPUT: Prime Prime Composite -1 In the first case, the only lexicographically smaller sequence of guesses is \"Prime Prime Prime\", but the hunters can make you lose in that case by first announcing $5$, which reduces your coins from $10$ to $5$, then announcing $3$, which reduces your coins from $5$ to $2$, then announcing $3$, which wipes out all of your coins. If you instead play the correct guess sequence \"Prime Prime Composite\", then if the hunters announce the same way, at the end when they announce $3$, you will gain those $3$ coins, increasing your stash to $5$. It can further be shown that the hunters cannot announce differently to take all of your coins given that you guess \"Prime Prime Composite\". In the second case, it can be shown that for any guess sequence you could choose, the hunters can announce in a way to take all of your coins. SAMPLE INPUT: 1 20 8 2 3 5 3 5 3 5 3 5 3 5 3 5 3 5 3 5 SAMPLE OUTPUT: Prime Prime Prime Composite Prime Composite Prime Composite",
    "samples": [
      {
        "input": "2\n10 3 2\n2 5\n1 3\n1 3\n10 3 3\n2 7 5\n8 3 4\n2 5 6",
        "output": "Prime Prime Composite\n-1"
      }
    ],
    "mapping": [
      "Bessie -> Treasure hunter",
      "Elsie -> You (the guardian)",
      "Marbles -> Treasure coins",
      "Even -> Prime",
      "Odd -> Composite"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "210_1_silver_milk_routing": {
    "name": "Milk Routing",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=210",
    "test_data_link": "http://www.usaco.org/current/data/mroute.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_mroute.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec12results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=dec12problems",
    "problem_level": "silver",
    "cp_id": "210",
    "problem_id": "210_1_silver_milk_routing",
    "description": "Problem 3: Data Packet Transmission\n\nIn the sprawling digital city of Byteville, the network operators are tasked with maintaining a legacy network of M data cables (1 <= M <= 500) for transmitting data packets from the main server to the data center. The operators plan to upgrade the network over the next year, but they need to maintain exactly one path of cables that can still carry data from the server to the data center.\n\nThe cable network is described by N connection nodes (1 <= N <= 500), each of which can serve as the endpoint of a set of cables. Node 1 is the main server, and node N is the data center. Each of the M bi-directional cables connects a pair of nodes and has a specific delay (the time it takes for a data packet to travel from one end of the cable to the other) and bandwidth (the amount of data per unit time that can be transmitted through the cable in steady state). Multiple cables can connect the same pair of nodes.\n\nFor a path of cables connecting the server to the data center, the delay of the path is the sum of the delays of the cables along the path, and the bandwidth of the path is the minimum of the bandwidths of the cables along the path (since this is the \"bottleneck\" constraining the overall rate at which data can be transmitted through the path). If the operators want to send a total of X units of data through a path of cables with delay D and bandwidth B, the time this takes is therefore D + X/B.\n\nGiven the structure of Byteville's cable network, please help the operators select a single path from the server to the data center that will allow them to transmit X units of data in a minimum amount of total time.\n\nPROBLEM NAME: dtransmission\n\nINPUT FORMAT:\n\n* Line 1: Three space-separated integers: N M X (1 <= X <= 1,000,000).\n\n* Lines 2..1+M: Each line describes a cable using 4 integers: I J D B. \n        I and J (1 <= I,J <= N) are the nodes at both ends of the cable.  D and B (1 <= D,B <= 1,000,000) give the delay and bandwidth of the cable.\n\nOUTPUT FORMAT:\n\n* Line 1: The minimum amount of time it will take to send data along a single path, rounded down to the nearest integer.",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes (Jonathan Paulson): It's not obvious how to\nmake the tradeoff between latency and capacity. But the graph is\nreally small: only 500 edges. Even a quadratic algorithm will be fast\nenough. \nConsider the optimal path. It has some minimum capacity C. The key\nobservation is that if you throw out edges with capacity less than C,\nthen the optimal path is just a shortest path. If only we knew C, we\ncould just run Dijkstra.\nBut there are only M possible values for C (the minimum capacity of\nthe optimal path is the capacity of its bottleneck edge, which is\n*some* edge). So we can just try all M values for C, run Dijkstra on\neach subgraph (of edges with capacity at least C), and take the best\nof these M paths (of course, if we choose a value if C so that the\ndestination is not reachable, it can't have been right). Since\nDijkstra is O(M log M), this idea is O(M^2 log M), which is fast\nenough. Here is Travis Hance's solution in C++:  \n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define NMAX 500\n#define MMAX 500\n#define infinite 1000000000000000000LL\n\nstruct edge {\n    int dest;\n    long long latency, cap;\n    edge(int dest, long long latency, long long cap) :\n        dest(dest), latency(latency), cap(cap) { }\n};\nvector<edge> edges[NMAX];\nlong long caps[MMAX];\n\nstruct entry {\n    int v;\n    long long dist;\n    entry(int v, long long dist) : v(v), dist(dist) { }\n    bool operator<(entry const& o) const {\n        return dist > o.dist;\n    }\n};\n\nbool visited[NMAX];\nlong long minL(int n, int source, int dest, int minCap) {\n    for (int i = 0; i < n; i++) {\n        visited[i] = false;\n    }\n    priority_queue<entry> q;\n    q.push(entry(source, 0));\n    while(q.size() > 0) {\n        entry cur = q.top();\n        q.pop();\n        if (visited[cur.v]) {\n            continue;\n        }\n        if (cur.v == dest) {\n            return cur.dist;\n        }\n        visited[cur.v] = true;\n        for (int i = 0; i < edges[cur.v].size(); i++) {\n            edge e = edges[cur.v][i];\n            if (e.cap >= minCap) {\n                q.push(entry(e.dest, cur.dist + e.latency));\n            }\n        }\n    }\n    return infinite;\n}\n\nint main() {\n    freopen(\"mroute.in\",\"r\",stdin);\n    freopen(\"mroute.out\",\"w\",stdout);\n\n    int n, m;\n    long long X;\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    scanf(\"%lld\", &X);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        long long l, c;\n        scanf(\"%d\", &a);\n        scanf(\"%d\", &b);\n        scanf(\"%lld\", &l);\n        scanf(\"%lld\", &c);\n        a--;\n        b--;\n        edges[a].push_back(edge(b, l, c));\n        edges[b].push_back(edge(a, l, c));\n        caps[i] = c;\n    }\n\n    long long mintime = infinite;\n    for (int i = 0; i < m; i++) {\n        long long c = caps[i];\n        long long l = minL(n, 0, n-1, c);\n        if (l != infinite) {\n            mintime = min(mintime, l + X/c);\n        }\n    }\n    printf(\"%lld\\n\", mintime);\n}\n\n\nAnd here is Jonathan Paulson's solution in Java:\n\n\nimport java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport static java.lang.Math.*;\n\npublic class mroute {\n    static int n;\n    static int A;\n    static int B;\n    static int[] X = new int[n];\n    public static void main(String[] args) throws Exception {\n        Scanner in = new Scanner(new File(\"mroute.in\"));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new\nFileWriter(\"mroute.out\")));\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int AMT = in.nextInt();\n        List<List<int[]>> E = new ArrayList<List<int[]>>();\n        for(int i=0; i<n; i++) E.add(new ArrayList<int[]>());\n        int[] Cs = new int[m];\n        Set<Integer> U = new HashSet<Integer>();\n        for(int i=0; i<m; i++) {\n            int x = in.nextInt()-1;\n            int y = in.nextInt()-1;\n            int L = in.nextInt();\n            int C = in.nextInt();\n            if(x==y) {\n                out.println(1000*1000*1000);\n                out.flush();\n                return;\n            }\n            if(U.contains(x*500+y)) {\n                out.println(1000*1000*100);\n                out.flush();\n                return;\n            }\n            U.add(x*500+y);\n            Cs[i] = C;\n            E.get(x).add(new int[]{y,L,C});\n            E.get(y).add(new int[]{x,L,C});\n        }\n        Arrays.sort(Cs);\n\n        int ans = 1000*1000*1000;\n        for(int c=0; c<m; c++) {\n            Queue<int[]> PQ = new PriorityQueue<int[]>(10, new\nComparator<int[]>() {\n                public int compare(int[] A, int[] B) {\n                    return A[1]-B[1];\n                }\n            });\n            PQ.offer(new int[]{0, 0});\n            boolean[] S = new boolean[n];\n            int dist = 1000*1000*1000;\n            while(!PQ.isEmpty()) {\n                int[] X = PQ.poll();\n                int v = X[0];\n                int d = X[1];\n                if(S[v]) continue;\n                S[v] = true;\n                if(v == n-1) {\n                    dist = d;\n                    break;\n                }\n                for(int[] e:E.get(v)) {\n                    if(e[2] < Cs[c]) continue;\n                    PQ.offer(new int[]{e[0], d+e[1]});\n                }\n            }\n            ans = min(ans, dist + AMT/Cs[c]);\n        }\n        out.println(ans);\n        out.flush();\n    }\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 3 15\n1 2 10 3\n3 2 10 2\n1 3 14 1",
        "output": "27"
      }
    ],
    "description_no_samples": "Problem 3: Data Packet Transmission\n\nIn the sprawling digital city of Byteville, the network operators are tasked with maintaining a legacy network of M data cables (1 <= M <= 500) for transmitting data packets from the main server to the data center. The operators plan to upgrade the network over the next year, but they need to maintain exactly one path of cables that can still carry data from the server to the data center.\n\nThe cable network is described by N connection nodes (1 <= N <= 500), each of which can serve as the endpoint of a set of cables. Node 1 is the main server, and node N is the data center. Each of the M bi-directional cables connects a pair of nodes and has a specific delay (the time it takes for a data packet to travel from one end of the cable to the other) and bandwidth (the amount of data per unit time that can be transmitted through the cable in steady state). Multiple cables can connect the same pair of nodes.\n\nFor a path of cables connecting the server to the data center, the delay of the path is the sum of the delays of the cables along the path, and the bandwidth of the path is the minimum of the bandwidths of the cables along the path (since this is the \"bottleneck\" constraining the overall rate at which data can be transmitted through the path). If the operators want to send a total of X units of data through a path of cables with delay D and bandwidth B, the time this takes is therefore D + X/B.\n\nGiven the structure of Byteville's cable network, please help the operators select a single path from the server to the data center that will allow them to transmit X units of data in a minimum amount of total time.\n\nPROBLEM NAME: dtransmission\n\nINPUT FORMAT:\n\n* Line 1: Three space-separated integers: N M X (1 <= X <= 1,000,000).\n\n* Lines 2..1+M: Each line describes a cable using 4 integers: I J D B. \n        I and J (1 <= I,J <= N) are the nodes at both ends of the cable.  D and B (1 <= D,B <= 1,000,000) give the delay and bandwidth of the cable.\n\nOUTPUT FORMAT:\n\n* Line 1: The minimum amount of time it will take to send data along a single path, rounded down to the nearest integer.",
    "description_raw": "Problem 3: Milk Routing [Brian Dean, 2012]\n\nFarmer John's farm has an outdated network of M pipes (1 <= M <= 500) for\npumping milk from the barn to his milk storage tank.  He wants to remove\nand update most of these over the next year, but he wants to leave exactly\none path worth of pipes intact, so that he can still pump milk from the\nbarn to the storage tank.\n\nThe pipe network is described by N junction points (1 <= N <= 500), each of\nwhich can serve as the endpoint of a set of pipes.  Junction point 1 is the\nbarn, and junction point N is the storage tank.  Each of the M\nbi-directional pipes runs between a pair of junction points, and has an\nassociated latency (the amount of time it takes milk to reach one end of\nthe pipe from the other) and capacity (the amount of milk per unit time\nthat can be pumped through the pipe in steady state).  Multiple pipes\ncan connect between the same pair of junction points.\n\nFor a path of pipes connecting from the barn to the tank, the latency\nof the path is the sum of the latencies of the pipes along the path,\nand the capacity of the path is the minimum of the capacities of the\npipes along the path (since this is the \"bottleneck\" constraining the\noverall rate at which milk can be pumped through the path).  If FJ\nwants to send a total of X units of milk through a path of pipes with\nlatency L and capacity C, the time this takes is therefore L + X/C.\n\nGiven the structure of FJ's pipe network, please help him select a single\npath from the barn to the storage tank that will allow him to pump X units\nof milk in a minimum amount of total time.\n\nPROBLEM NAME: mroute",
    "input_format": "* Line 1: Three space-separated integers: N M X (1 <= X <= 1,000,000).\n\n* Lines 2..1+M: Each line describes a pipe using 4 integers: I J L C. \n        I and J (1 <= I,J <= N) are the junction points at both ends\n        of the pipe.  L and C (1 <= L,C <= 1,000,000) give the latency\n        and capacity of the pipe.",
    "output_format": "* Line 1: The minimum amount of time it will take FJ to send milk\n        along a single path, rounded down to the nearest integer.",
    "num_samples": 1,
    "mapping": [
      "Farmer John's farm -> Byteville",
      "barn -> main server",
      "milk storage tank -> data center",
      "pipe -> cable",
      "junction point -> connection node",
      "latency -> delay",
      "capacity -> bandwidth",
      "milk -> data",
      "FJ -> network operators"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "791_1_gold_stamp_painting": {
    "name": "Stamp Painting",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=791",
    "test_data_link": "http://www.usaco.org/current/data/spainting_gold_jan18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_spainting_gold_jan18.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "gold",
    "cp_id": "791",
    "problem_id": "791_1_gold_stamp_painting",
    "description": "You have been given a long corridor of length $N$ units ($1 \\leq N \\leq 10^6$) that needs to be tiled. You have $M$ different types of tiles ($1 \\leq M \\leq 10^6$), each of which is exactly $K$ units long ($1 \\leq K \\leq 10^6$). You want to know how many distinct ways you can tile this corridor by placing the tiles in some arrangement. \n\nEach tile must cover exactly $K$ consecutive units of the corridor. Tiles cannot extend beyond the ends of the corridor, nor can they cover partial units. A tile type may be used multiple times, once, or not at all. However, by the end of the task, every unit of the corridor must be covered by a tile.\n\nDetermine the number of different ways to tile the corridor, modulo $10^9 + 7$. Two arrangements that look the same but were achieved by different sequences of tile placements are counted as the same.\n\nFor at least 75% of the input cases, $N,K \\leq 10^3$.\n\nINPUT FORMAT:\nThe first and only line of input has three integers, $N$, $M$, and $K$. It is guaranteed that $K \\leq N$.\n\nOUTPUT FORMAT:\nA single integer: the number of possible tiling arrangements, modulo $10^9 + 7$.",
    "num_tests": 12,
    "solution": "\n(Analysis by  Dhruv Rohatgi )\nThe first step is to find some criterion for which paintings can be created,\nwhere a painting is defined by $N$ numbers, each between $1$ and $M$ inclusive.\nTo this end, note that the last stamp Bessie uses will color $K$ consecutive\nunits with the same color, and so in the final painting, there must be $K$\nconsecutive units with the same color. \nConversely, consider an arbitrary painting which satisfies this condition. It is\nnot difficult to see that this painting must be attainable by some sequence of\nstampings: suppose the units in range $[i,i+K)$ have the same color. Start at\nthe left end and work rightwards, stamping $[1,K+1)$ with the desired color for\nunit $1$, then stamping $[2, K+2)$ with the desired color for unit $2$, all the\nway until we reach $[i, K+i)$. Then similarly start from the right end and work\nleftwards. Once $[i, K+i)$ has been reached a second time, we have produced the\ndesired painting.\nSo this problem is asking us to count the number of ways to pick $N$ numbers\nbetween $1$ and $M$ inclusive, so that some $K$ consecutive numbers are equal.\nAs is often the case, it is simpler to count the complement. We will count the\nnumber of ways to pick $N$ numbers between $1$ and $M$ so that no $K$\nconsecutive numbers are all equal. Since there are $M^N$ ways to pick the\nnumbers with no such restrictions, we will then subtract our complementary\nanswer from $M^N$, to obtain our final answer.\nWe can use dynamic programming to solve this reduced problem. Let $\\text{dp}(n)$\nbe the number of ways to pick $n$ numbers between $1$ and $M$ so that no $K$\nconsecutive numbers are equal. If $n<K$, this is a base case and the answer is\n$M^n$. Otherwise, note that in any good coloring, the last $K$ numbers cannot be\nequal. So for each good coloring, there is some $c < K$ so that the last $c$\nnumbers are equal, but the $c+1$-st number is different. Fix some $c$. Then\nthere are $\\text{dp}(n-c)$ ways to pick numbers for the first $n-c$ units, and\n$M-1$ ways to pick one number for the last $c$ units. This yields the recurrence\nrelation $$\\text{dp}(n) = (M-1) \\cdot \\sum_{c=1}^{K-1} \\text{dp}(n-c).$$\nWe immediately have a $O(NK)$ solution, which gets 75% of the points on this\nproblem. To get full credit, one must make the following final observation. Let\n$s(n) = \\sum_{i=1}^n \\text{dp}(n)$. Then the above recurrence implies the\nfollowing closed-form recurrence: $$s(n) - s(n-1) = (M-1)(s(n-1) - s(n-K))$$ or\n$$s(n) = Ms(n-1) - (M-1)s(n-K).$$\nSo rather than computing $\\text{dp}(n)$ directly, we compute $s(n)$, and observe\nthat $\\text{dp}(N) = s(N) - s(N-1)$. This yields an $O(N)$ algorithm.\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MOD 1000000007\n \nint s[10000001];\n \nint main()\n{\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\t\n\ts[0] = 0;\n\tfor(int i=1;i<K;i++)\n\t\ts[i] = (M*((long long)s[i-1]) + M)%MOD;\n\tfor(int i=K;i<=N;i++)\n\t\ts[i] = (M*((long long)s[i-1]) + MOD - ((M-1)*((long long)s[i-K]))%MOD)%MOD;\n \n\tint ans = 1;\n\tfor(int i=1;i<=N;i++)\n\t\tans = (M*((long long)ans))%MOD;\n\t\n\tcout << (((long long)ans) + MOD - ((long long)s[N]) + s[N-1])%MOD << '\\n';\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 2 2",
        "output": "6"
      }
    ],
    "description_no_samples": "You have been given a long corridor of length $N$ units ($1 \\leq N \\leq 10^6$) that needs to be tiled. You have $M$ different types of tiles ($1 \\leq M \\leq 10^6$), each of which is exactly $K$ units long ($1 \\leq K \\leq 10^6$). You want to know how many distinct ways you can tile this corridor by placing the tiles in some arrangement. \n\nEach tile must cover exactly $K$ consecutive units of the corridor. Tiles cannot extend beyond the ends of the corridor, nor can they cover partial units. A tile type may be used multiple times, once, or not at all. However, by the end of the task, every unit of the corridor must be covered by a tile.\n\nDetermine the number of different ways to tile the corridor, modulo $10^9 + 7$. Two arrangements that look the same but were achieved by different sequences of tile placements are counted as the same.\n\nFor at least 75% of the input cases, $N,K \\leq 10^3$.\n\nINPUT FORMAT:\nThe first and only line of input has three integers, $N$, $M$, and $K$. It is guaranteed that $K \\leq N$.\n\nOUTPUT FORMAT:\nA single integer: the number of possible tiling arrangements, modulo $10^9 + 7$.",
    "num_samples": 1,
    "mapping": [
      "canvas -> corridor",
      "paintings -> tiling arrangements",
      "stamps -> tiles",
      "painted -> tiled",
      "Bessie -> You",
      "N -> N",
      "M -> M",
      "K -> K"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "127_1_gold_large_banner": {
    "name": "Large Banner",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=127",
    "test_data_link": "http://www.usaco.org/current/data/banner.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_banner.html",
    "contest_link": "http://www.usaco.org/index.php?page=mar12results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=mar12problems",
    "problem_level": "gold",
    "cp_id": "127",
    "problem_id": "127_1_gold_large_banner",
    "description": "Problem 1: Astronomical Observatory Placement [Nathan Pinsker, 2010]\n\nDr. Orbit is planning to set up a pair of astronomical observatories on Planet X, which is a vast flat terrain with integer dimensions M x N (1 <= M, N <= 100,000). Observatories can be installed at any point with integer coordinates on the grid (using a coordinate system where (0,0) is in the lower-left corner and (M,N) is in the upper-right corner). There are (M+1) * (N+1) possible points for placing observatories. Dr. Orbit needs to select two distinct coordinates as the locations for the observatories.\n\nThe observatories must have a direct line of sight, meaning no other point can lie on the straight line between them. Additionally, the distance between the observatories should be at least L and at most H (1 <= L <= H <= 150,000). Dr. Orbit is looking for the number of different ways to place the observatories, but since the observatories are symmetrical, swapping their positions counts as the same configuration. As the number of configurations can be very large, Dr. Orbit seeks the result modulo B (1 <= B <= 1,000,000,000).\n\nFor example, consider the grid with M = 2 and N = 2:\n\n. . .\n. . .\n. . .\n\nDr. Orbit wants the distance between observatories to be between 1 and 3 inclusive. Any choice of points satisfying this condition is valid, except for eight pairs where an intermediate point lies on the line:\n\n(0, 0) and (2, 0): (1, 0) is on the line segment between them\n(0, 1) and (2, 1): (1, 1) is on the line segment between them\n(0, 2) and (2, 2): (1, 2) is on the line segment between them\n(0, 0) and (2, 2): (1, 1) is on the line segment between them\n(0, 0) and (0, 2): (0, 1) is on the line segment between them\n(1, 0) and (1, 2): (1, 1) is on the line segment between them\n(2, 0) and (2, 2): (2, 1) is on the line segment between them\n(0, 2) and (2, 0): (1, 1) is on the line segment between them\n\nThus, there are (9 choose 2) - 8 = 28 valid placements.\n\nPROBLEM NAME: observatory\n\nINPUT FORMAT:\n\n* Line 1: Five space-separated integers: M, N, L, H and B.\n\nOUTPUT FORMAT:\n\n* Line 1: One integer representing the number of possible observatory placements (modulo B).",
    "num_tests": 20,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes (Nathan Pinsker): The first step to solving this problem is to\nnotice that we can quickly find all banners of a certain width and\nheight. If a banner with width w and height h is allowed, then all\nother banners with width w and height h are allowed, and we can find\nthe number of them using some simple arithmetic. It is also fairly\nstraightforward to check if such a banner is allowed -- it is only if\nL*L <= (w*w + h*h) <= H*H and gcd(w, h) = 1. \nSince the field can potentially be of size 100,000 x 100,000, even\nconsidering each possible size of the banner once will take too much\ntime. However, if we consider each possible width that the banner can\nhave, and if, given that width, we can quickly sum the allowed heights\nfor the banner, then we will have solved the problem. For each width\nw, the sum that we want to obtain is equal to (all numbers between\nceil(sqrt(L*L - w*w)) and floor(sqrt(H*H - w*w)) inclusive) - (all\nnumbers in the same range that share a divisor with w). The first\nquantity is easy to obtain, while the second requires a little more\nwork. To calculate the second quantity, we note that, although w could\nhave a large variety of prime divisors, it does not have very many of\nthem. This important insight allows us to quickly find the sum: we\nfind the prime factors of w, then we use the inclusion-exclusion\nprinciple to calculate the sum of all numbers between L and H that are\ndivisible by at least one of the numbers.\n Below is Travis Hance's code.\n\n\n#include <cstdio>\n\n#define nmax 100005\n\ntypedef long long ll;\n\nint prime_divs[nmax][6];\nint num_prime_divs[nmax];\n\nll m,n,l,h,p;\n\ninline ll sum(ll lo, ll hi, ll mul) {\n\thi = hi / mul;\n\tlo = (lo + mul - 1) / mul;\n\treturn ((hi - lo + 1) * (m + 1) - mul * ((hi*(hi+1) - (lo-1)*lo) / 2)) % p;\n}\n\nint main() {\n\tfreopen(\"banner.in\",\"r\",stdin);\n\tfreopen(\"banner.out\",\"w\",stdout);\n\n\tscanf(\"%lld\", &m);\n\tscanf(\"%lld\", &n);\n\tscanf(\"%lld\", &l);\n\tscanf(\"%lld\", &h);\n\tscanf(\"%lld\", &p);\n\t\n\tfor(int i = 1; i <= n; i++)\n\t\tnum_prime_divs[i] = 0;\n\tfor(int i = 2; i <= n; i++)\n\t\tif(num_prime_divs[i] == 0)\n\t\t\tfor(int j = i; j <= n; j += i)\n\t\t\t\tprime_divs[j][num_prime_divs[j]++] = i;\n\n\tll ans = 0;\n\n\tll lo = l, hi = h;\n\n\tint minnh = (n < h ? n : h);\n\tfor(ll w = 1; w <= minnh; w++) {\n\t\twhile(lo > 1 && l*l - w*w <= (lo-1)*(lo-1))\n\t\t\tlo--;\n\t\twhile(h*h - w*w < hi*hi)\n\t\t\thi--;\n\t\tif(lo <= hi && lo <= m) {\n\t\t\tll a = 0;\n\t\t\tint p2 = (1 << num_prime_divs[w]);\n\t\t\tfor(int i = 0; i < p2; i++) {\n\t\t\t\tint i1 = i;\n\t\t\t\tll prod = 1;\n\t\t\t\tint parity = 1;\n\t\t\t\tfor(int j = 0; j < num_prime_divs[w]; j++) {\n\t\t\t\t\tif(i1 & 1) {\n\t\t\t\t\t\tprod *= prime_divs[w][j];\n\t\t\t\t\t\tparity *= -1;\n\t\t\t\t\t}\n\t\t\t\t\ti1 >>= 1;\n\t\t\t\t}\n\t\t\t\ta += parity * sum(lo, hi < m ? hi : m, prod);\n\t\t\t}\n\t\t\tans = (ans + a*(n-w+1)) % p;\n\t\t\tif(ans < 0) ans += p;\n\t\t\t//printf(\"w = %lld, ans = %lld, lo = %lld, hi = %lld\\n\", w, ans, lo, hi);\n\t\t}\n\t}\n\n\tif(l <= 1 && 1 <= h)\n\t\tans = (2*ans + n*(m+1) + m*(n+1)) % p;\n\telse\n\t\tans = (2 * ans) % p;\n\tprintf(\"%d\\n\", (int)ans);\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "2 2 1 3 100",
        "output": "28"
      }
    ],
    "description_no_samples": "Problem 1: Astronomical Observatory Placement [Nathan Pinsker, 2010]\n\nDr. Orbit is planning to set up a pair of astronomical observatories on Planet X, which is a vast flat terrain with integer dimensions M x N (1 <= M, N <= 100,000). Observatories can be installed at any point with integer coordinates on the grid (using a coordinate system where (0,0) is in the lower-left corner and (M,N) is in the upper-right corner). There are (M+1) * (N+1) possible points for placing observatories. Dr. Orbit needs to select two distinct coordinates as the locations for the observatories.\n\nThe observatories must have a direct line of sight, meaning no other point can lie on the straight line between them. Additionally, the distance between the observatories should be at least L and at most H (1 <= L <= H <= 150,000). Dr. Orbit is looking for the number of different ways to place the observatories, but since the observatories are symmetrical, swapping their positions counts as the same configuration. As the number of configurations can be very large, Dr. Orbit seeks the result modulo B (1 <= B <= 1,000,000,000).\n\nFor example, consider the grid with M = 2 and N = 2:\n\n. . .\n. . .\n. . .\n\nDr. Orbit wants the distance between observatories to be between 1 and 3 inclusive. Any choice of points satisfying this condition is valid, except for eight pairs where an intermediate point lies on the line:\n\n(0, 0) and (2, 0): (1, 0) is on the line segment between them\n(0, 1) and (2, 1): (1, 1) is on the line segment between them\n(0, 2) and (2, 2): (1, 2) is on the line segment between them\n(0, 0) and (2, 2): (1, 1) is on the line segment between them\n(0, 0) and (0, 2): (0, 1) is on the line segment between them\n(1, 0) and (1, 2): (1, 1) is on the line segment between them\n(2, 0) and (2, 2): (2, 1) is on the line segment between them\n(0, 2) and (2, 0): (1, 1) is on the line segment between them\n\nThus, there are (9 choose 2) - 8 = 28 valid placements.\n\nPROBLEM NAME: observatory\n\nINPUT FORMAT:\n\n* Line 1: Five space-separated integers: M, N, L, H and B.\n\nOUTPUT FORMAT:\n\n* Line 1: One integer representing the number of possible observatory placements (modulo B).",
    "description_raw": "Problem 1: Large Banner [Nathan Pinsker, 2010]\n\nBessie is returning from a long trip abroad to the Isle of Guernsey, and\nFarmer John wants to mount a nice \"Welcome Home\" banner for her arrival. \nFarmer John's field has integer dimensions M x N (1 <= M, N <= 100,000),\nand he has installed a post at every possible point in the field with\ninteger coordinates (if we assign a coordinate system to the field so that\n(0,0) is in the lower-left corner and (M,N) is in the upper-right corner).\nOf these (M+1) * (N+1) points, Farmer John must pick two as the endpoints\nof the banner.\n \nFarmer John, being the perfectionist that he is, insists that the banner\nmust be completely straight.  This means that, for the two posts he\nchooses, there cannot be any other post on the line segment that the banner\nwill form between them.  Additionally, Farmer John wants the banner to have\nlength at least L and at most H (1 <= L <= H <= 150,000).  Farmer John\nneeds your help to figure out how many possible ways he can hang the\nbanner. The banner is reversible, so switching the two endpoints of the\nbanner counts as the same way to hang the banner. As this number may be\nvery large, Farmer John simply wants to know what it is modulo B (1 <= B <=\n1,000,000,000). \n\nConsider the example below, with M = 2 and N = 2:\n\n* * *\n* * *\n* * *\n\nFarmer John wants the length of the banner to be between 1 and 3 inclusive.\nAny choice of posts satisfies this length requirement, but note that eight\npairs cannot be picked:\n\n(0, 0) and (2, 0): (1, 0) is on the line segment between them\n(0, 1) and (2, 1): (1, 1) is on the line segment between them\n(0, 2) and (2, 2): (1, 2) is on the line segment between them\n(0, 0) and (2, 2): (1, 1) is on the line segment between them\n(0, 0) and (0, 2): (0, 1) is on the line segment between them\n(1, 0) and (1, 2): (1, 1) is on the line segment between them\n(2, 0) and (2, 2): (2, 1) is on the line segment between them\n(0, 2) and (2, 0): (1, 1) is on the line segment between them\n\nTherefore, there are a total of (9 choose 2) - 8 = 28 possible locations. \n\nPROBLEM NAME: banner",
    "input_format": "* Line 1: Five space-separated integers: M, N, L, H and B.",
    "output_format": "* Line 1: One integer denoting the number of possible banners (modulo B).",
    "num_samples": 1,
    "mapping": [
      "Farmer John -> Dr. Orbit",
      "field -> grid",
      "Welcome Home banner -> astronomical observatories",
      "banner -> direct line of sight",
      "post -> point",
      "line segment -> direct line",
      "endpoints -> locations",
      "hang the banner -> place observatories"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "694_1_gold_hoof,_paper,_scissors": {
    "name": "USACO 2017 January Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=694",
    "test_data_link": "http://www.usaco.org/current/data/hps_gold_jan17.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_hps_gold_jan17.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan17results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "694",
    "problem_id": "694_1_gold_hoof,_paper,_scissors",
    "description": "In a distant galaxy, interstellar battles are conducted using advanced space fleets. Each fleet can adopt one of three combat formations: \"Star\", \"Nebula\", or \"Comet\".\n\nThe rules of engagement are straightforward. Two fleets face off against each other. Each commander chooses one of the three formations. \"Star\" formation defeats \"Comet\" (as stars can burn comets), \"Comet\" defeats \"Nebula\" (as comets can disrupt nebulas), and \"Nebula\" defeats \"Star\" (as nebulas can envelop stars). If both fleets choose the same formation, the battle is a draw.\n\nAdmiral Zarn wishes to lead his fleet against Commander Xelon's fleet in $N$ battles ($1 \\leq N \\leq 100,000$). Admiral Zarn, a genius strategist, can anticipate each of Xelon's formation choices in advance. However, due to communication delays across the galaxy, Admiral Zarn's fleet can only switch formations at most $K$ times over the entire course of battles ($0 \\leq K \\leq 20$). For instance, if $K=2$, Zarn's fleet might use \"Star\" for several battles, then switch to \"Nebula\", and later return to \"Star\".\n\nGiven the sequence of formations that Commander Xelon will use, determine the maximum number of battles Admiral Zarn's fleet can win.\n\nINPUT FORMAT (file fleet.in):\nThe first line of the input file contains $N$ and $K$.\nThe remaining $N$ lines contain Xelon's formations, each either S, N, or C.\n\nOUTPUT FORMAT (file fleet.out):\nPrint the maximum number of battles Admiral Zarn's fleet can win, considering that he can only change formations at most $K$ times.\n\nSAMPLE INPUT:\n5 1\nN\nN\nS\nN\nC\n\nSAMPLE OUTPUT:\n4\n\nProblem credits: Mark Chen and Brian Dean",
    "description_no_samples": "In a distant galaxy, interstellar battles are conducted using advanced space fleets. Each fleet can adopt one of three combat formations: \"Star\", \"Nebula\", or \"Comet\".\n\nThe rules of engagement are straightforward. Two fleets face off against each other. Each commander chooses one of the three formations. \"Star\" formation defeats \"Comet\" (as stars can burn comets), \"Comet\" defeats \"Nebula\" (as comets can disrupt nebulas), and \"Nebula\" defeats \"Star\" (as nebulas can envelop stars). If both fleets choose the same formation, the battle is a draw.\n\nAdmiral Zarn wishes to lead his fleet against Commander Xelon's fleet in $N$ battles ($1 \\leq N \\leq 100,000$). Admiral Zarn, a genius strategist, can anticipate each of Xelon's formation choices in advance. However, due to communication delays across the galaxy, Admiral Zarn's fleet can only switch formations at most $K$ times over the entire course of battles ($0 \\leq K \\leq 20$). For instance, if $K=2$, Zarn's fleet might use \"Star\" for several battles, then switch to \"Nebula\", and later return to \"Star\".\n\nGiven the sequence of formations that Commander Xelon will use, determine the maximum number of battles Admiral Zarn's fleet can win.\n\nINPUT FORMAT (file fleet.in):\nThe first line of the input file contains $N$ and $K$.\nThe remaining $N$ lines contain Xelon's formations, each either S, N, or C.\n\nOUTPUT FORMAT (file fleet.out):\nPrint the maximum number of battles Admiral Zarn's fleet can win, considering that he can only change formations at most $K$ times.\n\nSAMPLE INPUT:\n5 1\nN\nN\nS\nN\nC\n\nSAMPLE OUTPUT:\n4\n\nProblem credits: Mark Chen and Brian Dean",
    "samples": [
      {
        "input": "5 1\nN\nN\nS\nN\nC\n",
        "output": "4\n"
      }
    ],
    "mapping": [
      "Hoof -> Star",
      "Paper -> Nebula",
      "Scissors -> Comet",
      "Farmer John -> Commander Xelon",
      "Bessie -> Admiral Zarn",
      "Games -> Battles",
      "Gestures -> Formations"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1497_1_gold_bessie's_function": {
    "name": "USACO 2025 February Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1497",
    "test_data_link": "http://www.usaco.org/current/data/prob1_gold_feb25.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_gold_feb25.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb25results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "1497",
    "problem_id": "1497_1_gold_bessie's_function",
    "description": "In the futuristic city of Technoville, a group of robots is assigned to specific maintenance tasks. Each robot has a task function $t(x)$ that assigns a robot an integer task ID in $[1, N]$ (where $1 \\le N \\le 2 \\cdot 10^5$). The function $t(x)$ is defined by $N$ integers $b_1, b_2, \\ldots, b_N$, where $t(x) = b_x$ ($1 \\le b_i \\le N$).\n\nThe city administration wants the task function to be stable such that it satisfies $t(t(x)) = t(x)$ for all robots $x \\in [1, N]$.\n\nTo achieve this, each robot's task assignment can be changed at a cost of $k_i$, where you can set $b_i$ to any integer in $[1, N]$ ($1 \\le k_i \\le 10^9$). Determine the minimum total cost required to make the task function stable.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\nThe second line contains $N$ space-separated integers $b_1, b_2, \\dots, b_N$.\nThe third line contains $N$ space-separated integers $k_1, k_2, \\dots, k_N$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the minimum total cost required to make the task function stable.\n\nSAMPLE INPUT:\n5\n3 5 5 2 4\n2 2 2 2 2\n\nSAMPLE OUTPUT:\n4\n\nWe can change $b_1 = 5$, $b_4 = 5$, $b_5 = 5$. Since all $k_i$ equal two, the total cost is equal to $4$, the number of changes. It can be shown that there is no solution with only fewer changes.\n\nSAMPLE INPUT:\n8\n2 1 4 4 6 6 5 5\n4 4 3 6 4 4 4 4\n\nSAMPLE OUTPUT:\n9\n\nWe change $b_3 = 6$ and $b_4 = 5$. The total cost is $3+6=9$.",
    "description_no_samples": "In the futuristic city of Technoville, a group of robots is assigned to specific maintenance tasks. Each robot has a task function $t(x)$ that assigns a robot an integer task ID in $[1, N]$ (where $1 \\le N \\le 2 \\cdot 10^5$). The function $t(x)$ is defined by $N$ integers $b_1, b_2, \\ldots, b_N$, where $t(x) = b_x$ ($1 \\le b_i \\le N$).\n\nThe city administration wants the task function to be stable such that it satisfies $t(t(x)) = t(x)$ for all robots $x \\in [1, N]$.\n\nTo achieve this, each robot's task assignment can be changed at a cost of $k_i$, where you can set $b_i$ to any integer in $[1, N]$ ($1 \\le k_i \\le 10^9$). Determine the minimum total cost required to make the task function stable.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$.\nThe second line contains $N$ space-separated integers $b_1, b_2, \\dots, b_N$.\nThe third line contains $N$ space-separated integers $k_1, k_2, \\dots, k_N$.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the minimum total cost required to make the task function stable.\n\nSAMPLE INPUT:\n5\n3 5 5 2 4\n2 2 2 2 2\n\nSAMPLE OUTPUT:\n4\n\nWe can change $b_1 = 5$, $b_4 = 5$, $b_5 = 5$. Since all $k_i$ equal two, the total cost is equal to $4$, the number of changes. It can be shown that there is no solution with only fewer changes.\n\nSAMPLE INPUT:\n8\n2 1 4 4 6 6 5 5\n4 4 3 6 4 4 4 4\n\nSAMPLE OUTPUT:\n9\n\nWe change $b_3 = 6$ and $b_4 = 5$. The total cost is $3+6=9$.",
    "samples": [
      {
        "input": "5\n3 5 5 2 4\n2 2 2 2 2\n",
        "output": "4\n"
      }
    ],
    "mapping": [
      "Bessie -> City administration",
      "f(x) -> t(x)",
      "a_i -> b_i",
      "c_i -> k_i",
      "function idempotent -> task function stable"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "1402_1_gold_milk_exchange": {
    "name": "USACO 2024 February Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1402",
    "test_data_link": "http://www.usaco.org/current/data/prob2_gold_feb24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_gold_feb24.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb24results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "1402",
    "problem_id": "1402_1_gold_milk_exchange",
    "description": "In a futuristic city, there are $N$ $(1 \\leq N \\leq 5 \\cdot 10^5)$ cyborgs arranged in a circular formation. Each cyborg has a power cell with an integer capacity of $p_i$ $(1 \\leq p_i \\leq 10^9)$ units. All power cells are initially fully charged. Every minute, cyborg $i$ will transfer all the energy in their power cell to cyborg $i+1$ for $1 \\le i < N$, with cyborg $N$ transferring its energy to cyborg $1$. All transfers occur simultaneously (i.e., if a cyborg has a full power cell but gives away $x$ units of energy and also receives $x$ units, their total energy remains the same). If a cyborg's total energy ever exceeds $p_i$, the excess energy will be wasted. After each of $1, 2, \\dots, N$ minutes, calculate how much total energy is left among all cyborgs. INPUT FORMAT (input arrives from the terminal / stdin): The first line contains $N$. The next line contains integers $p_1,p_2,...,p_N$. OUTPUT FORMAT (print output to the terminal / stdout): Output $N$ lines, where the $i$-th line is the total energy left among all cyborgs after $i$ minutes. SAMPLE INPUT: 6 2 2 2 1 2 1 SAMPLE OUTPUT: 8 7 6 6 6 6 Initially, the energy in each power cell is $[2, 2, 2, 1, 2, 1]$. After $1$ minute, the energy in each power cell is $[1, 2, 2, 1, 1, 1]$ so the total energy is $8$. After $2$ minutes, the energy in each power cell is $[1, 1, 2, 1, 1, 1]$ so the total energy is $7$. After $3$ minutes, the energy in each power cell is $[1, 1, 1, 1, 1, 1]$ so the total energy is $6$. After $4$ minutes, the energy in each power cell is  $[1, 1, 1, 1, 1, 1]$ so the total energy is $6$. After $5$ minutes, the energy in each power cell is $[1, 1, 1, 1, 1, 1]$ so the total energy is $6$. After $6$ minutes, the energy in each power cell is $[1, 1, 1, 1, 1, 1]$ so the total energy is $6$. SAMPLE INPUT: 8 3 8 6 4 8 3 8 1 SAMPLE OUTPUT: 25 20 17 14 12 10 8 8 After $1$ minute, the energy in each power cell is $[1, 3, 6, 4, 4, 3, 3, 1]$ so the total energy is $25$.",
    "description_no_samples": "In a futuristic city, there are $N$ $(1 \\leq N \\leq 5 \\cdot 10^5)$ cyborgs arranged in a circular formation. Each cyborg has a power cell with an integer capacity of $p_i$ $(1 \\leq p_i \\leq 10^9)$ units. All power cells are initially fully charged. Every minute, cyborg $i$ will transfer all the energy in their power cell to cyborg $i+1$ for $1 \\le i < N$, with cyborg $N$ transferring its energy to cyborg $1$. All transfers occur simultaneously (i.e., if a cyborg has a full power cell but gives away $x$ units of energy and also receives $x$ units, their total energy remains the same). If a cyborg's total energy ever exceeds $p_i$, the excess energy will be wasted. After each of $1, 2, \\dots, N$ minutes, calculate how much total energy is left among all cyborgs. INPUT FORMAT (input arrives from the terminal / stdin): The first line contains $N$. The next line contains integers $p_1,p_2,...,p_N$. OUTPUT FORMAT (print output to the terminal / stdout): Output $N$ lines, where the $i$-th line is the total energy left among all cyborgs after $i$ minutes. SAMPLE INPUT: 6 2 2 2 1 2 1 SAMPLE OUTPUT: 8 7 6 6 6 6 Initially, the energy in each power cell is $[2, 2, 2, 1, 2, 1]$. After $1$ minute, the energy in each power cell is $[1, 2, 2, 1, 1, 1]$ so the total energy is $8$. After $2$ minutes, the energy in each power cell is $[1, 1, 2, 1, 1, 1]$ so the total energy is $7$. After $3$ minutes, the energy in each power cell is $[1, 1, 1, 1, 1, 1]$ so the total energy is $6$. After $4$ minutes, the energy in each power cell is  $[1, 1, 1, 1, 1, 1]$ so the total energy is $6$. After $5$ minutes, the energy in each power cell is $[1, 1, 1, 1, 1, 1]$ so the total energy is $6$. After $6$ minutes, the energy in each power cell is $[1, 1, 1, 1, 1, 1]$ so the total energy is $6$. SAMPLE INPUT: 8 3 8 6 4 8 3 8 1 SAMPLE OUTPUT: 25 20 17 14 12 10 8 8 After $1$ minute, the energy in each power cell is $[1, 3, 6, 4, 4, 3, 3, 1]$ so the total energy is $25$.",
    "samples": [
      {
        "input": "6\n2 2 2 1 2 1\n",
        "output": "8\n7\n6\n6\n6\n6\n"
      }
    ],
    "mapping": [
      "cows -> cyborgs",
      "buckets -> power cells",
      "milk -> energy",
      "a_i -> p_i"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    # The input format and values remain unchanged.\n    return text\n\ndef transform_output(text: str) -> str:\n    # The output format and values remain unchanged.\n    return text"
  },
  "1378_1_gold_cowmpetency": {
    "name": "USACO 2024 January Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1378",
    "test_data_link": "http://www.usaco.org/current/data/prob2_gold_jan24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob2_gold_jan24.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan24results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "1378",
    "problem_id": "1378_1_gold_cowmpetency",
    "description": "In a distant galaxy, the Intergalactic Council is trying to decode a crucial alien transmission. The transmission is composed of $N$ ($2 \\leq N \\leq 10^9$) distinct signals, each assigned a strength score ranging from $1$ to $C$ ($1 \\leq C \\leq 10^4$). Due to interference, the council has forgotten the exact scores, but they remember $Q$ ($1 \\leq Q \\leq \\min(N - 1, 100)$) pairs of numbers $(a_i, b_i)$ where signal $b_i$ was the first signal with a strictly greater strength than signals $1$ through $a_i$ (so $1 \\leq a_i < b_i \\leq N$). The council now provides you these $Q$ pairs of $(a_i, b_i)$. Help the council determine how many sequences of signal strength scores are consistent with this information! It is guaranteed that there is at least one such sequence. Because this number may be very large, output its value modulo $10^9 + 7$.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, $Q$, and $C$.\nThe next $Q$ lines each contain a pair $(a_i, b_i)$. It is guaranteed that all $a_j$ are distinct.\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe number of sequences of signal strength scores consistent with the given information, modulo $10^9+7$.\nSAMPLE INPUT:\n6 2 3\n2 3\n4 5\nSAMPLE OUTPUT:\n6\nThe following six sequences are the only ones consistent with the given constraints:\n1 1 2 1 3 1\n1 1 2 1 3 2\n1 1 2 1 3 3\n1 1 2 2 3 1\n1 1 2 2 3 2\n1 1 2 2 3 3\nSAMPLE INPUT:\n10 1 20\n1 3\nSAMPLE OUTPUT:\n399988086\nMake sure to output the answer modulo $10^9+7$.",
    "description_no_samples": "In a distant galaxy, the Intergalactic Council is trying to decode a crucial alien transmission. The transmission is composed of $N$ ($2 \\leq N \\leq 10^9$) distinct signals, each assigned a strength score ranging from $1$ to $C$ ($1 \\leq C \\leq 10^4$). Due to interference, the council has forgotten the exact scores, but they remember $Q$ ($1 \\leq Q \\leq \\min(N - 1, 100)$) pairs of numbers $(a_i, b_i)$ where signal $b_i$ was the first signal with a strictly greater strength than signals $1$ through $a_i$ (so $1 \\leq a_i < b_i \\leq N$). The council now provides you these $Q$ pairs of $(a_i, b_i)$. Help the council determine how many sequences of signal strength scores are consistent with this information! It is guaranteed that there is at least one such sequence. Because this number may be very large, output its value modulo $10^9 + 7$.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, $Q$, and $C$.\nThe next $Q$ lines each contain a pair $(a_i, b_i)$. It is guaranteed that all $a_j$ are distinct.\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe number of sequences of signal strength scores consistent with the given information, modulo $10^9+7$.\nSAMPLE INPUT:\n6 2 3\n2 3\n4 5\nSAMPLE OUTPUT:\n6\nThe following six sequences are the only ones consistent with the given constraints:\n1 1 2 1 3 1\n1 1 2 1 3 2\n1 1 2 1 3 3\n1 1 2 2 3 1\n1 1 2 2 3 2\n1 1 2 2 3 3\nSAMPLE INPUT:\n10 1 20\n1 3\nSAMPLE OUTPUT:\n399988086\nMake sure to output the answer modulo $10^9+7$.",
    "samples": [
      {
        "input": "6 2 3\n2 3\n4 5\n",
        "output": "6\n"
      }
    ],
    "mapping": [
      "Farmer John -> Intergalactic Council",
      "cow -> signal",
      "cowmpetency score -> signal strength score",
      "cows -> signals",
      "N -> N",
      "Q -> Q",
      "C -> C",
      "a_i -> a_i",
      "h_i -> b_i"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1065_1_gold_replication": {
    "name": "Replication",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1065",
    "test_data_link": "http://www.usaco.org/current/data/prob1_gold_dec20.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_gold_dec20.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec20results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "gold",
    "cp_id": "1065",
    "problem_id": "1065_1_gold_replication",
    "description": "In the heart of the Enchanted Forest, magical mushrooms have started to spread. \n\nThe forest can be represented by an $N\\times N$ grid ($3\\le N\\le 1000$) where \neach grid cell is either covered by an impenetrable thicket or is clear, and all border squares are \ncovered by a thicket. Some clear cells are designated as possible initial locations for these magical mushrooms.\n\nA mushroom initially grows at one of the possible starting\npositions. In every hour that follows, all mushrooms spread in one\ncoordinated mass in the same direction, either north, south, east, or west. \nAfter every $T$ hours ($1 \\leq T \\leq 10^9$), every mushroom spreads further\n--- a mushroom at cell $(x,y)$ that spreads creates new mushrooms in cells\n$(x+1,y)$, $(x-1,y)$, $(x,y+1)$, and $(x,y-1)$; the original mushroom remains at\n$(x,y)$. Over time, multiple mushrooms might come to occupy the same cell.\n\nIf spreading or replicating would cause any of the mushrooms to spread into a thicket, then\nall mushrooms cease to grow immediately. Note that this implies that the mushrooms must\neventually cease to grow, due to the border of the forest being a thicket.\n\nHelp the forest guardians figure out the number of clear squares that could potentially at\nsome point in time hold a mushroom.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two space-separated integers $N$ and $T$. The next $N$ lines of input each contain $N$ characters. Each character is one\nof '.', 'M', or '#'. '.' and 'M' both represent clear cells, with 'M' denoting\na possible starting position for the mushroom. '#' denotes a thicket.\n\nAll characters in the first and last row and first and last column are '#'.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nAn integer counting the number of cells that could at some point in time hold a\nmushroom.",
    "num_tests": 20,
    "solution": "\n(Analysis by Spencer Compton)\nFirst, we make an observation about what our swarm of robots will look like as\nthey replicate. As the robots replicate, they would take the following shape:\n\n.....    .....    ..X..\n.....    ..X..    .XXX.\n..X.. -> .XXX. -> XXXXX\n.....    ..X..    .XXX.\n.....    .....    ..X..\n\nMore intuitively, we can view the shape of our swarm as some cell with a center\nrobot, and after $i$ replications all cells within distance $i$ of the center\nwill have robots in the swarm.\nIf a cell can have a robot, then we know there is either a way to have a center\nrobot at that cell, or there is a way to have a center robot with $i$\nreplications within distance $i$ of the cell. \nThis motivates us to figure out which cells can have a center robot, and the\nmaximum number of replications it can have. To accomplish this, we intend to\nmake a modified BFS from the source cells to figure out which cells can have a\ncenter robot. In order to accomplish this, however, we will need to know if at\nsome time, the swarm is too big to go to a certain cell (and thus moving there\nwould cause robots to go into rocks). \nTo help with this, we will calculate the distance from every cell to its nearest\nrock cell. We can do this with a BFS where all the rocks are sources. We call\nthe distance from each cell to a rock $rock\\_dist[r][c]$. Now, we use a modified\nBFS to determine which cells could contain a center robot.  As we expand our\nBFS, we only move to a cell if it would not cause any robots to crash into\nrocks.  If we are moving from a cell $r_1,c_1$ to a cell $r_2,c_2$ for hour $t$\n(0-indexed), then this  condition is met if\n$t-1 < D \\times rock\\_dist[r_1][c_1]$ and \n$t \\le D \\times rock\\_dist[r_2][c_2]$.\nArmed with what cells can be center robots, we observe that we can stay at said\ncell until the swarm has replicated a total of $rock\\_dist[r][c]-1$ times.\nThus, our final condition for whether a cell $r,c$ can ever have a robot is if\nthere is some cell $r',c'$ where a center robot can be at $r',c'$ and\n$|r-r'|+|c-c'| \\le rock\\_dist[r'][c']-1$. To calculate this, we again utilize a\nmodified BFS. One such way of accomplishing this is having a set $centers[i]$\nthat contains all cells $r,c$ that can have a center robot and\n$rock\\_dist[r][c]=i$. We can do our BFS in stages from $n/2$ (because this is\nthe maximum possible $rock\\_dist$) to $0$, and at the end of each stage $i$ add\nall cells in $centers[i]$ as sources. A cell will then be reached by our\nmodified BFS exactly if it satisfies our condition, meaning we can determine the\ncells that can have robots.\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint dr[4] = {-1,1,0,0};\nint dc[4] = {0,0,-1,1};\n\nint main(){\n\tint n;\n\tll d;\n\tcin >> n >> d;\n\tbool empty[n][n];\n\tvector<pair<int, int> > starts;\n\tvector<pair<int, int> > rocks;\n\tint dist_rock[n][n];\n\tint dist_source[n][n];\n\tbool ans[n][n];\n\tfor(int i = 0; i<n; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j<n; j++){\n\t\t\tif(s[j]=='#'){\n\t\t\t\tempty[i][j] = false;\n\t\t\t\trocks.push_back(make_pair(i,j));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tempty[i][j] = true;\n\t\t\t}\n\t\t\tif(s[j]=='S'){\n\t\t\t\tstarts.push_back(make_pair(i,j));\n\t\t\t}\n\t\t\tdist_rock[i][j] = -1;\n\t\t\tdist_source[i][j] = -1;\n\t\t\tans[i][j] = false;\n\t\t}\n\t}\n\t// First, we calculate distance of everything to a rock\n\tvector<pair<int, int> > bfs_list;\n\tfor(int i = 0; i<rocks.size(); i++){\n\t\tbfs_list.push_back(rocks[i]);\n\t\tdist_rock[rocks[i].first][rocks[i].second] = 0;\n\t}\n\tfor(int i = 0; i<bfs_list.size(); i++){\n\t\tpair<int, int> now = bfs_list[i];\n\t\tfor(int j = 0; j<4; j++){\n\t\t\tpair<int, int> to = make_pair(now.first+dr[j],now.second+dc[j]);\n\t\t\tif(!(to.first>=0 && to.first<n && to.second>=0 && to.second<n)){\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif(dist_rock[to.first][to.second]!=-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to_dist = dist_rock[now.first][now.second] + 1;\n\t\t\tdist_rock[to.first][to.second] = to_dist;\n\t\t\tbfs_list.push_back(to);\n\t\t}\n\t}\n\t// Then, we do a BFS from the sources\n\tbfs_list.clear();\n\tfor(int i = 0; i<starts.size(); i++){\n\t\tbfs_list.push_back(starts[i]);\n\t\tdist_source[starts[i].first][starts[i].second] = 0;\n\t}\n\t// centers[i] will store all empty cells i that our center \n\t// can reach, and who are distance i+1 from a rock\n\t// (meaning they can replicate i times)\n\tvector<pair<int, int> > centers[n*n];\n\tfor(int i = 0; i<bfs_list.size(); i++){\n\t\tpair<int, int> now = bfs_list[i];\n\t\tans[now.first][now.second] = true;\n\t\tint now_dist = dist_source[now.first][now.second];\n\t\tcenters[dist_rock[now.first][now.second]-1].push_back(now);\n\t\t// Do not continue if replicating would force robots to rocks\n\t\tif(now_dist>=d*dist_rock[now.first][now.second]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0; j<4; j++){\n\t\t\tpair<int, int> to = make_pair(now.first+dr[j],now.second+dc[j]);\n\n\t\t\tif(!(to.first>=0 && to.first<n && to.second>=0 && to.second<n)){\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif(dist_source[to.first][to.second]!=-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!empty[to.first][to.second]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint to_dist = now_dist + 1;\n\t\t\t// Do not move if it would force robots to rocks\n\t\t\tif(to_dist > d*dist_rock[to.first][to.second]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist_source[to.first][to.second] = to_dist;\n\t\t\tbfs_list.push_back(to);\n\t\t}\n\t}\n\t// Do a modified BFS such that we reach every cell where\n\t// there is some other cell in centers[z] and the distance\n\t// between the two is <=z\n\tvector<pair<int, int> > next_stage;\n\tfor(int i = n*n-1; i>=0; i--){\n\t\tswap(bfs_list,next_stage);\n\t\tnext_stage.clear();\n\t\tfor(int j = 0; j<bfs_list.size(); j++){\n\t\t\tpair<int, int> now = bfs_list[j];\n\t\t\tfor(int k = 0; k<4; k++){\n\t\t\t\tpair<int, int> to = make_pair(now.first+dr[k],now.second+dc[k]);\n\n\t\t\t\tif(!(to.first>=0 && to.first<n && to.second>=0 && to.second<n)){\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t\tif(ans[to.first][to.second]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(!empty[to.first][to.second]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans[to.first][to.second] = true;\n\t\t\t\tnext_stage.push_back(to);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j<centers[i].size(); j++){\n\t\t\tnext_stage.push_back(centers[i][j]);\n\t\t}\n\t}\n\tint tot = 0;\n\tfor(int i = 0; i<n; i++){\n\t\tfor(int j = 0; j<n; j++){\n\t\t\tif(ans[i][j]){\n\t\t\t\ttot++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << tot << endl;\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "10 1\n##########\n#........#\n#M.......#\n#........#\n##########\n#M....M..#\n##########\n##########\n##########\n##########\n",
        "output": "15\n"
      }
    ],
    "description_no_samples": "In the heart of the Enchanted Forest, magical mushrooms have started to spread. \n\nThe forest can be represented by an $N\\times N$ grid ($3\\le N\\le 1000$) where \neach grid cell is either covered by an impenetrable thicket or is clear, and all border squares are \ncovered by a thicket. Some clear cells are designated as possible initial locations for these magical mushrooms.\n\nA mushroom initially grows at one of the possible starting\npositions. In every hour that follows, all mushrooms spread in one\ncoordinated mass in the same direction, either north, south, east, or west. \nAfter every $T$ hours ($1 \\leq T \\leq 10^9$), every mushroom spreads further\n--- a mushroom at cell $(x,y)$ that spreads creates new mushrooms in cells\n$(x+1,y)$, $(x-1,y)$, $(x,y+1)$, and $(x,y-1)$; the original mushroom remains at\n$(x,y)$. Over time, multiple mushrooms might come to occupy the same cell.\n\nIf spreading or replicating would cause any of the mushrooms to spread into a thicket, then\nall mushrooms cease to grow immediately. Note that this implies that the mushrooms must\neventually cease to grow, due to the border of the forest being a thicket.\n\nHelp the forest guardians figure out the number of clear squares that could potentially at\nsome point in time hold a mushroom.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains two space-separated integers $N$ and $T$. The next $N$ lines of input each contain $N$ characters. Each character is one\nof '.', 'M', or '#'. '.' and 'M' both represent clear cells, with 'M' denoting\na possible starting position for the mushroom. '#' denotes a thicket.\n\nAll characters in the first and last row and first and last column are '#'.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nAn integer counting the number of cells that could at some point in time hold a\nmushroom.",
    "num_samples": 3,
    "mapping": [
      "robot -> mushroom",
      "rock -> thicket",
      "empty square -> clear square",
      "S -> M",
      "D -> T",
      "Farmer John -> forest guardians",
      "farm -> forest"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text.replace('S', 'M').replace('D', 'T')\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "120_1_gold_nearby_cows": {
    "name": "Nearby Cows",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=120",
    "test_data_link": "http://www.usaco.org/current/data/nearcows.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_nearcows.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb12results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=feb12problems",
    "problem_level": "gold",
    "cp_id": "120",
    "problem_id": "120_1_gold_nearby_cows",
    "description": "Problem: Expedition Base Camps\n\nExploration leader Alex is overseeing a series of expedition base camps in a mountainous region. Each camp is situated at a location where explorers can rest and gather resources. To ensure that each base camp has enough resources for the explorers, Alex needs to account for explorers moving between nearby camps.\n\nThe region consists of N camps (1 <= N <= 100,000), and some pairs of camps are connected by bi-directional paths (N-1 of them in total). Alex has organized the base camps such that between any two camps p and q, there is a unique path made up of trails connecting p and q. Camp p initially accommodates E(p) explorers, but explorers can relocate by crossing up to L paths (1 <= L <= 20).\n\nAlex needs to ensure that each camp p is stocked with enough resources to support the maximum number of explorers, R(p), that could potentially be stationed there. This means calculating the number of explorers that can reach camp p by following at most L paths. Given the structure of the camp network and the value of E(p) for each camp p, help Alex calculate R(p) for every camp.\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers, N and L.\n\n* Lines 2..N: Each line contains two space-separated integers, p and q (1 <= p,q <= N) indicating that camps p and q are directly connected by a path.\n\n* Lines N+1..2N: Line N+p contains the integer E(p). (0 <= E(p) <= 1000)\n\nOUTPUT FORMAT:\n\n* Lines 1..N: Line p should contain the value of R(p).",
    "num_tests": 10,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes: This problem can be solved fairly easily by\ndynamic programming in O(NK) time.  Let A(x,r) denote the number of\ncows within a radius of r of node x.  As a base case, A(x,0) = C(x).\nWe then compute A(x,1) for all nodes x, then A(x,2) for all nodes x,\nup to A(x,k) for all nodes x.  To compute A(x,r), we sum up A(y,r-1)\nover all neighbors y of x, and then subtract out A(x,r-2) times the\ndegree of x (the number of neighbors of x) to correct for\ndouble-counting.  The total running time for each fixed value of r is\njust O(N), since the sum of the degrees of all the nodes in a graph is\ntwice the number of edges, which for a tree is O(N). \n\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\n#define MAXN 100000\nvector<int> E[MAXN];\nint F[4][MAXN];\n\nint main() {\n  freopen(\"nearcows.in\", \"r\", stdin);\n  freopen(\"nearcows.out\", \"w\", stdout);\n  int N, K; scanf(\"%d%d\", &N, &K);\n  assert(1 <= N && N <= 100000 && 1 <= K && K <= 20);\n  for(int i = 1; i < N; i++) {\n    int u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n    assert(0 <= u && u < N && 0 <= v && v < N);\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", F[0] + i);\n    assert(0 <= F[0][i] && F[0][i] <= 1000);\n    F[1][i] += F[0][i];\n    for(int j = 0; j < E[i].size(); j++) {\n      F[1][E[i][j]] += F[0][i];\n    }\n  }\n  for(int i = 2; i <= K; i++) {\n    for(int j = 0; j < N; j++) {\n      F[i & 3][j] = -(E[j].size() - 1) * F[i - 2 & 3][j];\n      for(int k = 0; k < E[j].size(); k++) {\n        F[i & 3][j] += F[i - 1 & 3][E[j][k]];\n      }\n    }\n  }\n  for(int i = 0; i < N; i++) printf(\"%d\\n\", F[K & 3][i]);\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "6 2\n5 1\n3 6\n2 4\n2 1\n3 2\n1\n2\n3\n4\n5\n6",
        "output": "15\n21\n16\n10\n8\n11"
      }
    ],
    "description_no_samples": "Problem: Expedition Base Camps\n\nExploration leader Alex is overseeing a series of expedition base camps in a mountainous region. Each camp is situated at a location where explorers can rest and gather resources. To ensure that each base camp has enough resources for the explorers, Alex needs to account for explorers moving between nearby camps.\n\nThe region consists of N camps (1 <= N <= 100,000), and some pairs of camps are connected by bi-directional paths (N-1 of them in total). Alex has organized the base camps such that between any two camps p and q, there is a unique path made up of trails connecting p and q. Camp p initially accommodates E(p) explorers, but explorers can relocate by crossing up to L paths (1 <= L <= 20).\n\nAlex needs to ensure that each camp p is stocked with enough resources to support the maximum number of explorers, R(p), that could potentially be stationed there. This means calculating the number of explorers that can reach camp p by following at most L paths. Given the structure of the camp network and the value of E(p) for each camp p, help Alex calculate R(p) for every camp.\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers, N and L.\n\n* Lines 2..N: Each line contains two space-separated integers, p and q (1 <= p,q <= N) indicating that camps p and q are directly connected by a path.\n\n* Lines N+1..2N: Line N+p contains the integer E(p). (0 <= E(p) <= 1000)\n\nOUTPUT FORMAT:\n\n* Lines 1..N: Line p should contain the value of R(p).",
    "description_raw": "Problem 3: Nearby Cows [Neal Wu and Eric Price, 2011]\n\nFarmer John has noticed that his cows often move between nearby fields. \nTaking this into account, he wants to plant enough grass in each of his\nfields not only for the cows situated initially in that field, but also for\ncows visiting from nearby fields.\n\nSpecifically, FJ's farm consists of N fields (1 <= N <= 100,000), where\nsome pairs of fields are connected with bi-directional trails (N-1 of them\nin total).  FJ has designed the farm so that between any two fields i and\nj, there is a unique path made up of trails connecting between i and j. \nField i is home to C(i) cows, although cows sometimes move to a different\nfield by crossing up to K trails (1 <= K <= 20).  \n\nFJ wants to plant enough grass in each field i to feed the maximum number\nof cows, M(i), that could possibly end up in that field -- that is, the\nnumber of cows that can potentially reach field i by following at most K\ntrails.  Given the structure of FJ's farm and the value of C(i) for each\nfield i, please help FJ compute M(i) for every field i.\n\nPROBLEM NAME: nearcows",
    "input_format": "* Line 1: Two space-separated integers, N and K.\n\n* Lines 2..N: Each line contains two space-separated integers, i and j\n        (1 <= i,j <= N) indicating that fields i and j are directly\n        connected by a trail.\n\n* Lines N+1..2N: Line N+i contains the integer C(i). (0 <= C(i) <=\n        1000)",
    "output_format": "* Lines 1..N: Line i should contain the value of M(i).",
    "num_samples": 1,
    "mapping": [
      "fields -> camps",
      "cows -> explorers",
      "grass -> resources",
      "trails -> paths",
      "Farmer John -> Alex",
      "FJ -> Alex",
      "C(i) -> E(p)",
      "M(i) -> R(p)",
      "K -> L"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1475_1_gold_photo_op": {
    "name": "USACO 2025 January Contest, Gold",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1475",
    "test_data_link": "http://www.usaco.org/current/data/prob3_gold_jan25.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob3_gold_jan25.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan25results",
    "inner_contest_link": null,
    "problem_level": "gold",
    "cp_id": "1475",
    "problem_id": "1475_1_gold_photo_op",
    "description": "Commander Zeta is tasked with launching a spacecraft from the Starbase on the Z-axis to the Research Station on the Y-axis in space. The spacecraft starts at coordinates (Z, 0) and needs to reach (0, Y) where (1 \u2264 Z, Y \u2264 10^6). However, there are N (1 \u2264 N \u2264 3 * 10^5) satellites orbiting along the Z-axis, each with a communication link to a ground station on the Y-axis. Specifically, satellite i orbits at (z_i, 0) and communicates with a ground station at (0, y_i), where (1 \u2264 z_i, y_i \u2264 10^6). These satellites start their operations at time s_i (1 \u2264 s_i < T), and they continue indefinitely. Here, 1 \u2264 T \u2264 N+1. Commander Zeta must plot a trajectory for the spacecraft that avoids crossing any active communication links (a straight line from satellite to ground station). For each time t (0 to T-1), calculate the integer part of the shortest possible Euclidean distance, d_t, the spacecraft can travel to reach its destination while avoiding these links. INPUT FORMAT (input arrives from the terminal / stdin): The first line contains N and T, the number of satellites and the timeframe for possible launches. The second line contains Z and Y, the spacecraft's starting Z coordinate and target Y coordinate respectively. The next N lines contain s_i, z_i, and y_i. It is guaranteed that all z_i are distinct from each other and Z, and all y_i are distinct from each other and Y. All s_i will be given in increasing order, where s_i \u2264 s_{i+1}. OUTPUT FORMAT (print output to the terminal / stdout): Print T lines, where the t-th (0-indexed) line contains \u230ad_t\u230b.",
    "description_no_samples": "Commander Zeta is tasked with launching a spacecraft from the Starbase on the Z-axis to the Research Station on the Y-axis in space. The spacecraft starts at coordinates (Z, 0) and needs to reach (0, Y) where (1 \u2264 Z, Y \u2264 10^6). However, there are N (1 \u2264 N \u2264 3 * 10^5) satellites orbiting along the Z-axis, each with a communication link to a ground station on the Y-axis. Specifically, satellite i orbits at (z_i, 0) and communicates with a ground station at (0, y_i), where (1 \u2264 z_i, y_i \u2264 10^6). These satellites start their operations at time s_i (1 \u2264 s_i < T), and they continue indefinitely. Here, 1 \u2264 T \u2264 N+1. Commander Zeta must plot a trajectory for the spacecraft that avoids crossing any active communication links (a straight line from satellite to ground station). For each time t (0 to T-1), calculate the integer part of the shortest possible Euclidean distance, d_t, the spacecraft can travel to reach its destination while avoiding these links. INPUT FORMAT (input arrives from the terminal / stdin): The first line contains N and T, the number of satellites and the timeframe for possible launches. The second line contains Z and Y, the spacecraft's starting Z coordinate and target Y coordinate respectively. The next N lines contain s_i, z_i, and y_i. It is guaranteed that all z_i are distinct from each other and Z, and all y_i are distinct from each other and Y. All s_i will be given in increasing order, where s_i \u2264 s_{i+1}. OUTPUT FORMAT (print output to the terminal / stdout): Print T lines, where the t-th (0-indexed) line contains \u230ad_t\u230b.",
    "samples": [
      {
        "input": "4 5\n6 7\n1 7 5\n2 4 4\n3 1 6\n4 2 9",
        "output": "9\n9\n9\n10\n12"
      }
    ],
    "mapping": [
      "Bessie -> Spacecraft",
      "Cows -> Satellites",
      "Photographers -> Ground Stations",
      "X-axis -> Z-axis",
      "s_i -> Time of satellite activation",
      "x_i -> Satellite position",
      "y_i -> Ground station position",
      "X -> Z (start coordinate)",
      "Y -> Y (target coordinate)"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "102_1_gold_grass_planting": {
    "name": "Grass Planting",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=102",
    "test_data_link": "http://www.usaco.org/current/data/grassplant.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_grassplant.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec11results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=dec11problems",
    "problem_level": "gold",
    "cp_id": "102",
    "problem_id": "102_1_gold_grass_planting",
    "description": "Problem 3: Stone Pathway Beautification [Travis Hance, 2011]\n\nIn the kingdom of Aralon, there are N ancient temples (2 <= N <= 100,000) connected by N-1 bidirectional stone pathways, ensuring there is exactly one path between any two temples. The royal architect, who values aesthetics, often complains about how the pathways lack decorative stones. The King, who appreciates the architect's dedication, has decided to enhance the pathways with ornamental stones. He will do so following a procedure consisting of M steps (1 <= M <= 100,000).\n\nAt each step one of two things will happen:\n\n- The King will select two temples and adorn each pathway in-between with ornamental stones, or,\n\n- The architect will inquire about the number of decorative stones on a specific pathway, and the King must respond to this query.\n\nThe King is not very good at counting -- assist him in answering the architect's inquiries!\n\nPROBLEM NAME: stonepath\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers N and M\n\n* Lines 2..N: Two space-separated integers describing the endpoints of a stone pathway.\n\n* Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either A or I, which describes whether the King is adding stones or simply inquiring. This is followed by two space-separated integers X_i and Y_i (1 <= X_i, Y_i <= N) which describe the King's action or inquiry.\n\nOUTPUT FORMAT:\n\n* Lines 1..???: Each line has the answer to an inquiry, appearing in the same order as the inquiries appear in the input.",
    "num_tests": 13,
    "solution": "\n\n\nContest Results\n\n\n\n\nSolution Notes (Albert Gu): There are many ways to do this\nproblem, some of which are faster than others. One solution uses a\ntechnique called heavy-light decomposition.  Root the tree\narbitrarily. Consider an edge between vertices u and v (let u be the\nparent of v). Call this edge heavy if the size of the subtree rooted\nat v is at least half the size of the subtree rooted at u, and light\notherwise. Note that each parent has at most one heavy edge to a\nchild, so the heavy edges form a set of chains. We will keep track of\neach heavy chain separately. \nFinally, any path from a vertex to the root has at most log n light\nedges, because advancing up a light edge at least doubles the size of\nthe subtree. This path also has at most log n heavy chains, since a\nlight edge separates every two heavy chains. This means we can divide\nthis path into log n pieces, so adding grass along a path from a\nvertex to a root will take O(log n) time by adding it to each light\nedge and heavy chain on the path. Note that we will need to augment\neach heavy chain with a structure such as a range tree or BIT (binary\nindexed tree) because we might need to plant grass on only a prefix of\na heavy chain.\nTo update an arbitrary path, we note the following: Planting 1 grass\non each edge along the path from A to B is the same as planting 1\ngrass on each edge from A to the root, 1 grass on each edge from B to\nthe root, and -2 grass on each edge from LCA(A, B) to the root, where\nLCA denotes the least common ancestor.\n (As a note, the memory limits for this problem were extremely\ntight --- probably a bit too tight; conserving memory was one of the\nmain problems faced by most competitors). \n Here is Mark Gordon's code: \n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\n\n/* Heavy Light Implementation */\n#define MAXN 100000\n\nint N; // Number of nodes\n\n/* Node fields. */\nint VC[MAXN];  // Vertex chain index\nint VPOS[MAXN]; // Vertex chain position\n\n/* Chain fields. */\nint CP[MAXN]; // Chain parent (-1 if none)\nint CLN[MAXN]; // Number of vertexes in chain.\n\nvector<int> E[MAXN];\n\npair<int, int> hang(int u, int p) {\n  int nodes = 1;\n  pair<int, int> result(0, -1);\n  for(int i = 0; i < E[u].size(); i++) {\n    int v = E[u][i];\n    if(v == p) continue;\n    pair<int, int> res = hang(v, u);\n    nodes += res.first;\n    result = max(result, res);\n  }\n  E[u].clear();\n\n  if(result.second == -1) result.second = u;\n  E[result.second].push_back(u);\n  CP[result.second] = p;\n  \n  result.first = nodes;\n  return result;\n}\n\n/* Before calling E[i] represents the edges of vertex i.  After calling E[i] is\n * a list (from root to child) of vertexes in chain i. */\nvoid prep_heavylight() {\n  hang(0, -1);\n  for(int i = 0; i < N; i++) {\n    CLN[i] = E[i].size();\n    for(int j = 0; j < E[i].size(); j++) {\n      VC[E[i][j]] = i;\n      VPOS[E[i][j]] = j;\n    }\n  }\n}\n\n/* Represents the nodes in the range [lo, hi) of chain. */\nstruct ChainPart {\n  ChainPart(int chain, int lo, int hi) : chain(chain), lo(lo), hi(hi) {}\n  int chain;\n  int lo; // lo node on the chain.\n  int hi; // hi node on the chain. hi=CLN[chain] means chain connects to parent\n};\n\n/* Returns a list of all the sections of the chains on the path from u to v. */\nvector<ChainPart> chain_path(int u, int v) {\n  vector<pair<int, int> > cu, cv;\n  for(; u != -1; u = CP[VC[u]]) cu.push_back(make_pair(VC[u], VPOS[u]));\n  for(; v != -1; v = CP[VC[v]]) cv.push_back(make_pair(VC[v], VPOS[v]));\n  reverse(cu.begin(), cu.end());\n  reverse(cv.begin(), cv.end());\n  if(cv.size() < cu.size()) cu.swap(cv);\n\n  int i;\n  for(i = 0; i < cu.size() && cu[i] == cv[i]; i++);\n\n  vector<ChainPart> ret;\n  if(i == cu.size()) {\n    ret.push_back(\n        ChainPart(cu.back().first, cu.back().second, cu.back().second));\n  } else if(cu[i].first == cv[i].first) {\n    ret.push_back(ChainPart(cu[i].first,\n                            min(cu[i].second, cv[i].second),\n                            max(cu[i].second, cv[i].second)));\n    ++i;\n  }\n  for(int j = i; j < cu.size(); j++) {\n    ret.push_back(ChainPart(cu[j].first, cu[j].second, CLN[cu[j].first]));\n  }\n  for(int j = i; j < cv.size(); j++) {\n    ret.push_back(ChainPart(cv[j].first, cv[j].second, CLN[cv[j].first]));\n  }\n  return ret;\n}\n\n/* Get rid of empty chain parts. */\nvector<ChainPart> filter(const vector<ChainPart>& ch) {\n  vector<ChainPart> res;\n  for(int i = 0; i < ch.size(); i++) {\n    if(ch[i].lo != ch[i].hi) {\n      res.push_back(ch[i]);\n    }\n  }\n  return res;\n}\n\nvector<int> bit[MAXN];\n\nvoid bit_add(vector<int>& A, int x, int v) {\n  for(int i = x | A.size(); i < (A.size() << 1); i += i & -i) {\n    A[i ^ A.size()] += v;\n  }\n}\n\nint bit_get(vector<int>& A, int x) {\n  int ret = A[0];\n  for(int i = x; i; i &= i - 1) ret += A[i];\n  return ret;\n}\n\nint main() {\n  freopen(\"grassplant.in\", \"r\", stdin);\n  freopen(\"grassplant.out\", \"w\", stdout);\n\n  int M;\n  scanf(\"%d%d\", &N, &M);\n  for(int i = 1; i < N; i++) {\n    int u, v; scanf(\"%d%d\", &u, &v); u--; v--;\n    E[u].push_back(v);\n    E[v].push_back(u);\n  }\n  prep_heavylight();\n\n  for(int i = 0; i < N; i++) {\n    if(!CLN[i]) continue;\n    bit[i] = vector<int>(1 << (32 - __builtin_clz(CLN[i] - 1)), 0);\n  }\n\n  for(int i = 0; i < M; i++) {\n    char op[2]; int u, v; scanf(\"%1s%d%d\", op, &u, &v); u--; v--;\n    vector<ChainPart> ch = filter(chain_path(u, v));\n    if(op[0] == 'P') {\n      for(int i = 0; i < ch.size(); i++) {\n        bit_add(bit[ch[i].chain], ch[i].lo, 1);\n        if(ch[i].hi < CLN[ch[i].chain]) {\n          bit_add(bit[ch[i].chain], ch[i].hi, -1);\n        }\n      }\n    } else {\n      assert(ch.size() == 1 && ch[0].lo + 1 == ch[0].hi);\n      printf(\"%d\\n\", bit_get(bit[ch[0].chain], ch[0].lo));\n    }\n  }\n}\n\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4 6\n1 4\n2 4\n3 4\nA 2 3\nA 1 3\nI 3 4\nA 1 4\nI 2 4\nI 1 4\n",
        "output": "2\n1\n2\n"
      }
    ],
    "description_no_samples": "Problem 3: Stone Pathway Beautification [Travis Hance, 2011]\n\nIn the kingdom of Aralon, there are N ancient temples (2 <= N <= 100,000) connected by N-1 bidirectional stone pathways, ensuring there is exactly one path between any two temples. The royal architect, who values aesthetics, often complains about how the pathways lack decorative stones. The King, who appreciates the architect's dedication, has decided to enhance the pathways with ornamental stones. He will do so following a procedure consisting of M steps (1 <= M <= 100,000).\n\nAt each step one of two things will happen:\n\n- The King will select two temples and adorn each pathway in-between with ornamental stones, or,\n\n- The architect will inquire about the number of decorative stones on a specific pathway, and the King must respond to this query.\n\nThe King is not very good at counting -- assist him in answering the architect's inquiries!\n\nPROBLEM NAME: stonepath\n\nINPUT FORMAT:\n\n* Line 1: Two space-separated integers N and M\n\n* Lines 2..N: Two space-separated integers describing the endpoints of a stone pathway.\n\n* Lines N+1..N+M: Line i+1 describes step i. The first character of the line is either A or I, which describes whether the King is adding stones or simply inquiring. This is followed by two space-separated integers X_i and Y_i (1 <= X_i, Y_i <= N) which describe the King's action or inquiry.\n\nOUTPUT FORMAT:\n\n* Lines 1..???: Each line has the answer to an inquiry, appearing in the same order as the inquiries appear in the input.",
    "description_raw": "Problem 3: Grass Planting [Travis Hance, 2011]\n\nFarmer John has N barren pastures (2 <= N <= 100,000) connected by N-1 \nbidirectional roads, such that there is exactly one path between any two \npastures.  Bessie, a cow who loves her grazing time, often complains about \nhow there is no grass on the roads between pastures.  Farmer John loves \nBessie very much, and today he is finally going to plant grass on the\nroads.  He will do so using a procedure consisting of M steps (1 <= M <=\n100,000).\n\nAt each step one of two things will happen:\n\n- FJ will choose two pastures, and plant a patch of grass along each road in\nbetween the two pastures, or,\n\n- Bessie will ask about how many patches of grass on a particular road, and \nFarmer John must answer her question.\n\nFarmer John is a very poor counter -- help him answer Bessie's questions!\n\nPROBLEM NAME: grassplant",
    "input_format": "* Line 1: Two space-separated integers N and M\n\n* Lines 2..N: Two space-separated integers describing the endpoints of\n        a road.\n\n* Lines N+1..N+M: Line i+1 describes step i. The first character of\n        the line is either P or Q, which describes whether or not FJ\n        is planting grass or simply querying. This is followed by two\n        space-separated integers A_i and B_i (1 <= A_i, B_i <= N)\n        which describe FJ's action or query.",
    "output_format": "* Lines 1..???: Each line has the answer to a query, appearing in the\n        same order as the queries appear in the input.",
    "num_samples": 1,
    "mapping": [
      "pasture -> temple",
      "road -> stone pathway",
      "grass -> ornamental stone",
      "Farmer John -> King",
      "Bessie -> royal architect",
      "P -> A (action)",
      "Q -> I (inquiry)",
      "A_i, B_i -> X_i, Y_i"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text.replace('P', 'A').replace('Q', 'I')\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "842_1_platinum_disruption": {
    "name": "Disruption",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=842",
    "test_data_link": "http://www.usaco.org/current/data/disrupt_platinum_open18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_disrupt_platinum_open18.html",
    "contest_link": "http://www.usaco.org/index.php?page=open18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "842",
    "problem_id": "842_1_platinum_disruption",
    "description": "In the distant future, humanity has established a network of communication satellites across N planets ($2 \\leq N \\leq 50,000$), with each pair of planets connected by $N-1$ bi-directional communication links of unit bandwidth. These links ensure that communication can take place between any two planets. However, the space federation is concerned about what might happen if one of the communication links fails, which would split the network into two groups of planets. Communication could still occur within each group but not between the groups. To mitigate this risk, the federation has established a set of $M$ additional communication links ($1 \\leq M \\leq 50,000$), each with a positive bandwidth capacity of at most $10^9$. The additional links are typically not used unless an original link fails. If failure occurs, the network will be partitioned, and the federation will select one additional link to restore communication between the two groups, ensuring that messages can be sent between any two planets once again. For each of the original communication links, help the federation determine the minimum bandwidth of a suitable replacement link that would restore connectivity if that original link fails. INPUT FORMAT: The first line of input contains $N$ and $M$. Each of the next $N-1$ lines describes an original communication link using integers $p$, $q$, where $p \\neq q$ are the planets connected by the link (in the range $1 \\ldots N$). The remaining $M$ lines each describe an additional link in terms of three integers: $p$, $q$, and $r$, where $r$ is the bandwidth of the link. At most one link runs between any pair of planets. OUTPUT FORMAT: For each of the $N-1$ original communication links in the order they appear in the input, output the bandwidth of the shortest suitable replacement link which would restore connectivity if that original link were to fail. If no suitable replacement exists, output -1.",
    "num_tests": 15,
    "solution": "\nThis problem involves finding so-called \"replacement edges\" for a spanning tree,\na problem that is closely linked with the minimum spanning tree problem.  There \nare several nice ways to approach it, varying quite a bit in terms of complexity\nof implementation.  Below is one particularly nice solution, from coach Matt\nFontaine,  running in $O(n \\log m + m \\log^2 m)$ time.\nFirst we need a priority queue data structure -- capable of adding a new\nelement, removing an element, and querying for the minimum element.  Depending\non language, there are several suitable choices here (Matt uses a hash table\nplus a priority queue in Java; a C++ set would probably also suffice).  \nFor each candidate replacement edge, put a candidate \"token\" on each of its two\nendpoint nodes, with value equal to the weight of the edge.  We then traverse\nthe tree (say, with a post-order traversal), and for each of its  subtrees we\ncompute the minimum value of all the tokens appearing exactly once in the\nsubtree (since these tell us the weights of the edges with exactly one endpoint\nin the subtree, and one endpoint outside the subtree).  Our priority queue\nmaintains the set of tokens appearing exactly once in the current subtree.\nWhenever we try to add the second token for the same edge to the priority queue,\nwe instead remove the existing token, since now both edges lie within the same\nsubtree.\nAs the traversal works its way up the tree, we need to \"merge\" the priority\nqueue contents of subtrees together.  E.g., suppose we have finished traversing\nsubtrees rooted at nodes $x$ and $y$ and now we move up to the parent $p$ of $x$\nand $y$.  At this point, we have a separate priority queue for the contents of\n$x$'s subtree and for that  of $y$'s subtree.  To merge these together to get a\nsingle priority queue reflecting the contents of $p$'s subtree, we take all the\nelements in the smaller of $x$'s  and $y$'s priority queues and insert these\ninto the larger.  Using this relatively common \"merge the smaller into the\nlarger\" trick, we get good amortized performance since each element participates\nin at most $\\log m$ inserts, since each time it is inserted it finds that it is\npart of a priority queue of at least twice the size as before.  Since each\ninsert takes $O(\\log m)$ time, this is where we get the running time of\n$O(\\log^2 m)$ per potential replacement edge.\nMatt's code is below; note that a good chunk of it is a pre-built I/O class, so\nthe solution code is actually quite concise.  \nFinal note: in theory, the problem has a rather sophisticated $O(m\\alpha(n))$\nsolution on a graph with $n$ nodes and $m$ edges, where $\\alpha()$ denotes the \ninverse Ackermann function, although this solution is well beyond the scope of \nwhat would be expected in a contest setting.\n\nimport java.util.*;                                                                                                    \nimport java.io.*;                                                                                                      \n\npublic class dis\n{\n   public static void main(String[] args) throws Exception\n   {\n      FastScanner in = new FastScanner(new FileInputStream(\"disrupt.in\"));                                             \n      PrintWriter out = new PrintWriter(new File(\"disrupt.out\"));                                                      \n      new dis(in, out);                                                                                                \n      out.close();                                                                                                     \n   }\n\n   int N;                                                                                                              \n   ArrayList<Edge>[] adj;                                                                                              \n   Blob[] blobs;                                                                                                       \n   int[] res;                                                                                                          \n\n   void dfs(int i, int p)\n   {\n      for (Edge e : adj[i]) if (e.j != p)\n      {\n         dfs(e.j, i);                                                                                                  \n         res[e.id] = blobs[e.j].min();                                                                                 \n         blobs[i] = blobs[i].merge(blobs[e.j]);                                                                        \n      }\n   }\n\n   public dis(FastScanner in, PrintWriter out)\n   {\n      N = in.nextInt();                                                                                                \n      int M = in.nextInt();                                                                                            \n      res = new int[N-1];                                                                                              \n      blobs = new Blob[N];                                                                                             \n      for (int i=0; i<N; i++)                                                                                          \n         blobs[i] = new Blob();                                                                                        \n      adj = new ArrayList[N];                                                                                          \n      for (int i=0; i<N; i++)                                                                                          \n         adj[i] = new ArrayList<>();                                                                                   \n      for (int x=0; x<N-1; x++)                                                                                        \n      {\n         int i = in.nextInt()-1;                                                                                       \n         int j = in.nextInt()-1;                                                                                       \n         adj[i].add(new Edge(j, x));                                                                                   \n         adj[j].add(new Edge(i, x));                                                                                   \n      }\n\n      for (int x=0; x<M; x++)                                                                                          \n      {\n         int i = in.nextInt()-1;                                                                                       \n         int j = in.nextInt()-1;                                                                                       \n         int w = in.nextInt();                                                                                         \n         blobs[i].add(new Node(x, w));                                                                                 \n         blobs[j].add(new Node(x, w));                                                                                 \n      }\n\n      dfs(0,0);                                                                                                        \n      for (int rr : res)\n         out.println(rr);                                                                                              \n   }\n}\n\nclass Blob\n{\n   PriorityQueue<Node> q;                                                                                              \n   HashSet<Integer> active;                                                                                            \n\n   Blob()\n   {\n      q = new PriorityQueue<>();                                                                                       \n      active = new HashSet<>();                                                                                        \n   }\n\n   void mergeInto(Blob rhs)\n   {\n      for (Node n : rhs.q)\n         if (rhs.active.contains(n.id))\n            add(n);                                                                                                    \n   }\n\n   Blob merge(Blob rhs)\n   {\n      if (active.size() > rhs.active.size())\n      {\n         mergeInto(rhs);                                                                                               \n         return this;                                                                                                  \n      }\n      else\n      {\n         rhs.mergeInto(this);                                                                                          \n         return rhs;                                                                                                   \n      }\n   }\n\n   void add(Node n)\n   {\n      if (active.contains(n.id))\n      {\n         active.remove(n.id);                                                                                          \n      }\n      else\n      {\n         active.add(n.id);                                                                                             \n         q.add(n);                                                                                                     \n      }\n   }\n\n   int min()\n   {\n      while (q.size() > 0 && !active.contains(q.peek().id))\n         q.poll();                                                                                                     \n      return q.size() > 0 ? q.peek().w : -1;                                                                           \n   }\n}\n\nclass Node implements Comparable<Node>\n{\n   int id, w;                                                                                                          \n\n   Node(int id, int w)\n   {\n      this.id = id;                                                                                                    \n      this.w = w;                                                                                                      \n   }\n\n   public int compareTo(Node rhs)\n   {\n      return Integer.compare(w, rhs.w);                                                                                \n   }\n}\n\nclass Edge\n{\n   int j, id;                                                                                                          \n\n   Edge(int jj, int ii)\n   {\n      j=jj; id=ii;                                                                                                     \n   }\n}\n\nclass FastScanner{\n   private InputStream stream;                                                                                         \n   private byte[] buf = new byte[1024];                                                                                \n   private int curChar;                                                                                                \n   private int numChars;                                                                                               \n\n   public FastScanner(InputStream stream)\n   {\n      this.stream = stream;                                                                                            \n   }\n\n   int read()\n   {\n      if (numChars == -1)\n         throw new InputMismatchException();                                                                           \n      if (curChar >= numChars){\n         curChar = 0;                                                                                                  \n         try{\n            numChars = stream.read(buf);                                                                               \n         } catch (IOException e) {\n            throw new InputMismatchException();                                                                        \n         }\n         if (numChars <= 0)\n            return -1;                                                                                                 \n      }\n      return buf[curChar++];                                                                                           \n   }\n\n   boolean isSpaceChar(int c)\n   {\n      return c==' '||c=='\\n'||c=='\\r'||c=='\\t'||c==-1;                                                                 \n   }\n\n   boolean isEndline(int c)\n   {\n      return c=='\\n'||c=='\\r'||c==-1;                                                                                  \n   }\n\n   int nextInt()\n   {\n      return Integer.parseInt(next());                                                                                 \n   }\n\n   long nextLong()\n   {\n      return Long.parseLong(next());                                                                                   \n   }\n\n   double nextDouble()\n   {\n      return Double.parseDouble(next());                                                                               \n   }\n\n   String next(){\n      int c = read();                                                                                                  \n      while (isSpaceChar(c))\n         c = read();                                                                                                   \n      StringBuilder res = new StringBuilder();                                                                         \n      do{\n         res.appendCodePoint(c);                                                                                       \n         c = read();                                                                                                   \n      }while(!isSpaceChar(c));                                                                                         \n      return res.toString();                                                                                           \n   }\n\n   String nextLine(){\n      int c = read();                                                                                                  \n      while (isEndline(c))\n         c = read();                                                                                                   \n      StringBuilder res = new StringBuilder();                                                                         \n      do{\n         res.appendCodePoint(c);                                                                                       \n         c = read();                                                                                                   \n      }while(!isEndline(c));                                                                                           \n      return res.toString();                                                                                           \n   }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "6 3\n1 2\n1 3\n4 1\n4 5\n6 5\n2 3 7\n3 6 8\n6 4 5",
        "output": "7\n7\n8\n5\n5"
      }
    ],
    "description_no_samples": "In the distant future, humanity has established a network of communication satellites across N planets ($2 \\leq N \\leq 50,000$), with each pair of planets connected by $N-1$ bi-directional communication links of unit bandwidth. These links ensure that communication can take place between any two planets. However, the space federation is concerned about what might happen if one of the communication links fails, which would split the network into two groups of planets. Communication could still occur within each group but not between the groups. To mitigate this risk, the federation has established a set of $M$ additional communication links ($1 \\leq M \\leq 50,000$), each with a positive bandwidth capacity of at most $10^9$. The additional links are typically not used unless an original link fails. If failure occurs, the network will be partitioned, and the federation will select one additional link to restore communication between the two groups, ensuring that messages can be sent between any two planets once again. For each of the original communication links, help the federation determine the minimum bandwidth of a suitable replacement link that would restore connectivity if that original link fails. INPUT FORMAT: The first line of input contains $N$ and $M$. Each of the next $N-1$ lines describes an original communication link using integers $p$, $q$, where $p \\neq q$ are the planets connected by the link (in the range $1 \\ldots N$). The remaining $M$ lines each describe an additional link in terms of three integers: $p$, $q$, and $r$, where $r$ is the bandwidth of the link. At most one link runs between any pair of planets. OUTPUT FORMAT: For each of the $N-1$ original communication links in the order they appear in the input, output the bandwidth of the shortest suitable replacement link which would restore connectivity if that original link were to fail. If no suitable replacement exists, output -1.",
    "num_samples": 1,
    "mapping": [
      "pastures -> planets",
      "pathways -> communication links",
      "Farmer John -> the space federation",
      "unit length -> unit bandwidth",
      "length of pathway -> bandwidth of link",
      "cows -> messages",
      "blocked -> fail",
      "re-establishes connectivity -> restores communication"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "866_1_platinum_the_cow_gathering": {
    "name": "The Cow Gathering",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=866",
    "test_data_link": "http://www.usaco.org/current/data/gathering_platinum_dec18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_gathering_platinum_dec18.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "866",
    "problem_id": "866_1_platinum_the_cow_gathering",
    "description": "In a distant future, a group of advanced robots have gathered for a technological summit. There are $N$ robots, and $N-1$ pairs of robots who are directly connected to each other. Every robot is connected to every other robot through some chain of connections.\n\nAfter a successful summit, the robots need to deactivate one by one following a specific order. They must deactivate in such a way that as long as there are still at least two robots active, every remaining robot is connected to another active robot. Additionally, due to technical dependencies, there are $M$ pairs of robots $(a_i, b_i)$ such that robot $a_i$ must deactivate before robot $b_i$. Note that the robots $a_i$ and $b_i$ may or may not be directly connected.\n\nHelp the robots determine, for each one, whether it could be the last robot to deactivate. It may be that there is no possible sequence of deactivations that satisfies these constraints.\n\nINPUT FORMAT:\nLine $1$ contains two space-separated integers $N$ and $M$.\n\nLines $2 \\leq i \\leq N$ each contain two integers $x_i$ and $y_i$ with $1 \\leq x_i, y_i \\leq N$ and $x_i \\neq y_i$ indicating that robots $x_i$ and $y_i$ are directly connected.\n\nLines $N+1 \\leq i \\leq N+M$ each contain two integers $a_i$ and $b_i$ with\n$1 \\leq a_i, b_i \\leq N$ and $a_i \\neq b_i$ indicating that robot $a_i$ must deactivate before robot $b_i$.\n\nIt is guaranteed that $1 \\leq N, M \\leq 10^5$. In test cases worth $20\\%$ of the points, it is further guaranteed that $N, M \\leq 3000$.\n\nOUTPUT FORMAT:\nThe output should consist of $N$ lines, with one integer $d_i$ on each line such that $d_i = 1$ if robot $i$ could be the last to deactivate, and $d_i = 0$ otherwise.",
    "num_tests": 17,
    "solution": "\n(Analysis by  Dhruv Rohatgi )\nThe problem can be rephrased as follows: removing leaves from a tree one by one\nwhile respecting order constraints, determine the possible final nodes. Let's\nstart with an easier variant: determine whether there exists a feasible\nordering, and if so, find a possible final node. This can be solved by greedily\nremoving \"free\" leaves: that is, leaves which are not constrained to be removed\nafter nodes which still remain in the tree. \nTo prove that this works, note that if there is no feasible ordering, than this\ngreedy process cannot possibly succeed. Conversely, if the process does not\nsucceed, then there is some contiguous subtree in which every leaf of the\nsubtree is constrained to be removed after some other node in the subtree. Any\nordering has to break at least one of these constraints, since out of all the\nnodes in the subtree, some leaf is removed first. So there is no feasible\nordering.\nNow we want to find all possible final nodes. If the above greedy algorithm\nfails, then we're done: there are no possible final nodes. Otherwise, we've\nfound one final node $r$ and want to find all others. Intuitively, the possible\nfinal nodes should form a contiguous subtree. This intuition is correct. \nLet $s$ be any neighbor of $r$. If there is some constraint that $s$ must be\nremoved before some other node, then $s$ is clearly not a possible final node.\nIt turns out this is sufficient: fix a feasible ordering in which $r$ is the\nfinal node, and find the location where $s$ is removed. Swapping $s$ with the\nnext node in the ordering does not break any constraints, so $s$ can be\niteratively swapped towards the end of the ordering. Hence, $s$ is a possible\nfinal node.\nThis means that if we consider the induced subgraph of all nodes $a$ with no\nconstraints of the form \"remove $a$ before $b$\", then every node in the\nconnected component of $r$ is a possible final node.\nIn fact, such nodes are the only possible final nodes. Fix some node $s$ such\nthat there is some node $a$ along the path from $s$ to $r$, and some constraint\n\"remove $a$ before $b$\". Root the tree at $a$. Then $r$ and $s$ are in different\nsubtrees. If $b$ is not in the subtree of $r$, then $a$ is on the path from $r$\nto $b$, so $r$ must be removed before $a$, so $r$ is not a possible final node.\nContradiction, so $b$ is in the subtree of $r$. But then it's not in the subtree\nof $s$, so by the same reasoning, $s$ is not a possible final node.\nThis yields our final algorithm: run the greedy process to find $r$, and run DFS\nfrom $r$, avoiding nodes $a$ which have constraints \"remove $a$ before $b$\". The\nset of visited nodes is the set of possible final nodes.\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MAXN 100000\n \nint N,M;\nvector<int> edges[MAXN];\nvector<int> inConstraints[MAXN];\t//i: must remove j before i\nvector<int> outConstraints[MAXN];\t//i: must remove i before j\nint numInConstraints[MAXN];\nint numEdges[MAXN];\nbool isfree[MAXN];\nbool isroot[MAXN];\n \nvoid dfs(int i,int par)\n{\n\tif(outConstraints[i].size() > 0)\n\t\treturn;\n\tisroot[i] = 1;\n\tfor(int j=0;j<edges[i].size();j++)\n\t\tif(edges[i][j] != par)\n\t\t\tdfs(edges[i][j], i);\n}\n \n \nint main()\n{\n\tcin >> N >> M;\n\tint a,b;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t\tnumEdges[a]++, numEdges[b]++;\n\t}\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tinConstraints[b].push_back(a);\n\t\toutConstraints[a].push_back(b);\n\t\tnumInConstraints[b]++;\n\t}\n\tvector<int> freeNodes;\n\tfor(int i=0;i<N;i++)\n\t\tif(numEdges[i]<=1 && numInConstraints[i]==0)\n\t\t{\n\t\t\tfreeNodes.push_back(i);\n\t\t\tisfree[i] = 1;\n\t\t}\n\tfor(int i=0;i<N-1;i++)\n\t{\n\t\tif(i == freeNodes.size())\n\t\t{\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\tcout << 0 << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tint cur = freeNodes[i];\n\t\tfor(int j=0;j<edges[cur].size();j++)\n\t\t{\n\t\t\tint e = edges[cur][j];\n\t\t\tnumEdges[e]--;\n\t\t\tif(numEdges[e]<=1 && numInConstraints[e]==0 && !isfree[e])\n\t\t\t{\n\t\t\t\tfreeNodes.push_back(e);\n\t\t\t\tisfree[e] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<outConstraints[cur].size();j++)\n\t\t{\n\t\t\tint e = outConstraints[cur][j];\n\t\t\tnumInConstraints[e]--;\n\t\t\tif(numEdges[e]<=1 && numInConstraints[e]==0 && !isfree[e])\n\t\t\t{\n\t\t\t\tfreeNodes.push_back(e);\n\t\t\t\tisfree[e] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint root = freeNodes[N-1];\n\tdfs(root, -1);\n\tint num = 0;\n\tfor(int i=0;i<N;i++)\n\t\tnum += isroot[i];\n\tfor(int i=0;i<N;i++)\n\t\tcout << isroot[i] << '\\n';\n}\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5 1\n1 2\n2 3\n3 4\n4 5\n2 4",
        "output": "0\n0\n1\n1\n1"
      }
    ],
    "description_no_samples": "In a distant future, a group of advanced robots have gathered for a technological summit. There are $N$ robots, and $N-1$ pairs of robots who are directly connected to each other. Every robot is connected to every other robot through some chain of connections.\n\nAfter a successful summit, the robots need to deactivate one by one following a specific order. They must deactivate in such a way that as long as there are still at least two robots active, every remaining robot is connected to another active robot. Additionally, due to technical dependencies, there are $M$ pairs of robots $(a_i, b_i)$ such that robot $a_i$ must deactivate before robot $b_i$. Note that the robots $a_i$ and $b_i$ may or may not be directly connected.\n\nHelp the robots determine, for each one, whether it could be the last robot to deactivate. It may be that there is no possible sequence of deactivations that satisfies these constraints.\n\nINPUT FORMAT:\nLine $1$ contains two space-separated integers $N$ and $M$.\n\nLines $2 \\leq i \\leq N$ each contain two integers $x_i$ and $y_i$ with $1 \\leq x_i, y_i \\leq N$ and $x_i \\neq y_i$ indicating that robots $x_i$ and $y_i$ are directly connected.\n\nLines $N+1 \\leq i \\leq N+M$ each contain two integers $a_i$ and $b_i$ with\n$1 \\leq a_i, b_i \\leq N$ and $a_i \\neq b_i$ indicating that robot $a_i$ must deactivate before robot $b_i$.\n\nIt is guaranteed that $1 \\leq N, M \\leq 10^5$. In test cases worth $20\\%$ of the points, it is further guaranteed that $N, M \\leq 3000$.\n\nOUTPUT FORMAT:\nThe output should consist of $N$ lines, with one integer $d_i$ on each line such that $d_i = 1$ if robot $i$ could be the last to deactivate, and $d_i = 0$ otherwise.",
    "num_samples": 1,
    "mapping": [
      "cows -> robots",
      "friendship -> connection",
      "leave -> deactivate",
      "gathering -> summit",
      "luggage storage -> technical dependencies"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1190_1_platinum_multiple_choice_test": {
    "name": "Multiple Choice Test",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1190",
    "test_data_link": "http://www.usaco.org/current/data/prob3_platinum_jan22.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob3_platinum_jan22.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan22results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "1190",
    "problem_id": "1190_1_platinum_multiple_choice_test",
    "description": "In a magical realm, a group of wizards is planning their flight paths. Instead of evaluating each segment of the journey separately and then summing them, they want to optimize the entire path at once.\n\nSpecifically, you have $N$ ($2 \\le N \\le 10^5$) sets of magical vectors on a 2D map, where each vector is represented by an ordered pair $(a, b)$. Choose one vector from each set such that the resultant vector from combining all chosen vectors is as far from the starting point as possible.\n\nIt is guaranteed that the total number of vectors is at most $2 \\cdot 10^5$. Each set has at least $2$ vectors, and within a set, all vectors are distinct. Additionally, every $a$ and $b$ coordinate has an absolute value at most $\\frac{10^9}{N}$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, the number of vector sets.\n\nEach set begins with $G$, the number of vectors in that set, followed by $G$ lines containing the vectors in that set. Consecutive sets are separated by newlines.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe maximum possible squared Euclidean distance.",
    "num_tests": 17,
    "solution": "\n(Analysis by Benjamin Qi)\nLet $f(x,y)=x^2+y^2$ be the function we want to maximize. It turns out that for\nany convex\nfunction $f$, we can apply the same solution.\nClaim: We only need to consider evaluating $f$ at the vertices of the\nconvex hull of the set of all\npossible Minkowski sums.\nProof: Any point $p$ within the convex hull that is not a vertex can be\nwritten as  $p=\\lambda_1v_1+\\lambda_2v_2+\\cdots+\\lambda_kv_k$ for some\n$\\lambda_i>0, \\sum \\lambda_i=1$, $k>1$, and $v_1,\\ldots,v_k$ distinct vertices\nof the convex hull. Then assuming $f$ is convex,\n$$f(p)\\le f\\left(\\sum \\lambda_iv_i\\right)\\le \\sum \\lambda_i f(v_i)\\implies \\max_i f(v_i)\\ge f(p).$$\nIt remains to describe how to efficiently compute the convex hull of the\nMinkowski sum.\nFor a slow solution, we may directly compute the convex hull of the Minkowski\nsum of two sets  of sizes $|A|$ and $|B|$, by summing every pair of points and\nthen computing the convex hull in $\\mathcal O(|A|\\cdot |B|\\log (|A|\\cdot |B|))$\ntime. It turns out the convex hull of the Minkowski sum always has at most\n$|A|+|B|$ vertices, leading to an  $\\mathcal O(T^2\\log T)$ time solution if we\napply this reasoning for every group in the input, where $T$ is the total number\nof vectors.\nMy code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n#define f first\n#define s second\n\nusing ll = long long;\n\nP operator+(P a, P b) { return {a.f + b.f, a.s + b.s}; }\nP operator-(P a, P b) { return {a.f - b.f, a.s - b.s}; }\nll cross(P a, P b) { return (ll)a.f * b.s - (ll)a.s * b.f; }\nll cross(P a, P b, P c) { return cross(b - a, c - a); }\nll sq(ll x) { return x * x; }\nll norm(P p) { return sq(p.f) + sq(p.s); }\n\n// Graham Scan, assumes the hull has size > 1\nvector<P> convex_hull(vector<P> v) {\n\tnth_element(begin(v), begin(v), end(v));\n\tconst P leftmost = v[0];\n\tfor (P &p : v) p = p - leftmost;\n\tsort(begin(v), end(v), [](P a, P b) { // sort points by argument\n\t\tif (cross(a, b) == 0) return norm(a) < norm(b);\n\t\treturn cross(a, b) > 0;\n\t});\n\tvector<P> hull;\n\tfor (P p : v) {\n\t\twhile (hull.size() >= 2 && cross(end(hull)[-2], end(hull)[-1], p) <= 0)\n\t\t\thull.pop_back();\n\t\thull.push_back(p);\n\t}\n\tfor (P &p : hull) p = p + leftmost;\n\treturn hull;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint N;\n\tcin >> N;\n\tvector<P> prefix_hull{{}};\n\twhile (N--) {\n\t\tint G;\n\t\tcin >> G;\n\t\tvector<P> group(G);\n\t\tfor (P &p : group) cin >> p.f >> p.s;\n\t\tvector<P> next_prefix;\n\t\tfor (P a : prefix_hull)\n\t\t\tfor (P b : group) next_prefix.push_back(a + b);\n\t\tprefix_hull = convex_hull(next_prefix);\n\t}\n\tll ans = 0;\n\tfor (P p : prefix_hull) ans = max(ans, norm(p));\n\tcout << ans << \"\\n\";\n}\n\nFor a more efficient solution, let's start by computing the convex hull of each\ngroup. Then consider the following question: How can we more efficiently compute\nthe convex hull of the Minkowski sum of two convex polygons $A$ and $B$ (and why\nis it  true that it  has size at most $|A|+|B|$)? \nDefine the offset sequence  of a  convex polygon to be the sequence of\nvectors traversed when touring the hull starting at the lexicographically least\nvertex of the hull and going in counterclockwise order. It turns out that the\noffset sequence of the Minkowski sum is always a permutation of the combined\noffset sequences of the summands. Consider the following example:\n\nA = [(0, 0), (2, -1), (3, 0), (2, 2)]\noffsets_A = [(2, -1), (1, 1), (-1, 2), (-2, -2)]\n\nB = [(0, 0), (4, -3), (0, 5)]\noffsets_B = [(4, -3), (-4, 8), (0, -5)]\n\nsum(A,B) = C = [(0, 0), (4, -3), (6, -4), (7, -3), (6, -1), (2, 7), (0, 5)]\noffsets_C = [(4, -3), (2, -1), (1, 1), (-1, 2), (-4, 8), (-2, -2), (0, -5)]\n\nObserve that $\\texttt{offsets}_C$ may be computed by merging the sequences\n$\\texttt{offsets}_A$ and $\\texttt{offsets}_B$ such that the final sequence is\nsorted in order of \nargument (as\ndescribed\nhere).\nFor a more complete explanation of Minkowski sums, you can check the editorial\nfor this problem.\nIf we want to compute the offsets of the Minkowski sum of more than two convex\nhulls, we can place all of the offsets into a single sequence and sort the\nentire sequence by argument. The overall time complexity is\n$\\mathcal O(T\\log T)$.\nMy code:\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n#define f first\n#define s second\n\nusing ll = long long;\n\nP operator+(P a, P b) { return {a.f + b.f, a.s + b.s}; }\nP operator-(P a, P b) { return {a.f - b.f, a.s - b.s}; }\nll cross(P a, P b) { return (ll)a.f * b.s - (ll)a.s * b.f; }\nll cross(P a, P b, P c) { return cross(b - a, c - a); }\nll sq(ll x) { return x * x; }\nll norm(P p) { return sq(p.f) + sq(p.s); }\nint half(P p) {\n\tif (p.f > 0 || (p.f == 0 && p.s > 0)) return 0;\n\treturn 1;\n}\n\n// Graham Scan, assumes the hull has size > 1\nvector<P> convex_hull(vector<P> v) {\n\tnth_element(begin(v), begin(v), end(v));\n\tconst P leftmost = v[0];\n\tfor (P &p : v) p = p - leftmost;\n\tsort(begin(v), end(v), [](P a, P b) { // sort points by argument\n\t\tif (cross(a, b) == 0) return norm(a) < norm(b);\n\t\treturn cross(a, b) > 0;\n\t});\n\tvector<P> hull;\n\tfor (P p : v) {\n\t\twhile (hull.size() >= 2 && cross(end(hull)[-2], end(hull)[-1], p) <= 0)\n\t\t\thull.pop_back();\n\t\thull.push_back(p);\n\t}\n\tfor (P &p : hull) p = p + leftmost;\n\treturn hull;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint N;\n\tcin >> N;\n\tP start{}; // lexicographically minimum reachable point\n\tvector<P> offsets;\n\twhile (N--) {\n\t\tint G;\n\t\tcin >> G;\n\t\tvector<P> group(G);\n\t\tfor (P &p : group) cin >> p.f >> p.s;\n\t\tvector<P> hull = convex_hull(group);\n\t\tstart = start + hull[0];\n\t\tfor (int i = 1; i <= hull.size(); ++i)\n\t\t\toffsets.push_back(hull[i % hull.size()] - hull[i - 1]);\n\t}\n\t// sort offsets by CCW angle such that (0, -1) comes last\n\tsort(begin(offsets), end(offsets), [](P a, P b) {\n\t\tif (half(a) != half(b)) return half(a) < half(b);\n\t\treturn cross(a, b) > 0;\n\t});\n\tll ans = 0;\n\t// tour the hull in counterclockwise order\n\tfor (int i = 0; i < offsets.size(); ++i) {\n\t\tans = max(ans, norm(start));\n\t\tstart = start + offsets[i];\n\t}\n\tcout << ans << \"\\n\";\n}\n\nDanny Mittal's code:\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n \npublic class MultipleChoiceTest {\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        List<Vector> exchanges = new ArrayList<>();\n        Vector curr = new Vector(0, 0);\n        for (; n > 0; n--) {\n            in.readLine();\n            int g = Integer.parseInt(in.readLine());\n            Vector[] group = new Vector[g];\n            for (int j = 0; j < g; j++) {\n                StringTokenizer tokenizer = new StringTokenizer(in.readLine());\n                long x = Long.parseLong(tokenizer.nextToken());\n                long y = Long.parseLong(tokenizer.nextToken());\n                group[j] = new Vector(x, y);\n            }\n            Arrays.sort(group, (u, v) -> {\n                if (v.x == u.x) {\n                    return Long.compare(v.y, u.y);\n                } else {\n                    return Long.compare(v.x, u.x);\n                }\n            });\n            List<Vector> upperHull = new ArrayList<>();\n            for (Vector v : group) {\n                while (upperHull.size() >= 2 && sideOfLine(upperHull.get(upperHull.size() - 2), upperHull.get(upperHull.size() - 1), v) >= 0L) {\n                    upperHull.remove(upperHull.size() - 1);\n                }\n                upperHull.add(v);\n            }\n            List<Vector> lowerHull = new ArrayList<>();\n            for (Vector v : group) {\n                while (lowerHull.size() >= 2 && sideOfLine(lowerHull.get(lowerHull.size() - 2), lowerHull.get(lowerHull.size() - 1), v) <= 0L) {\n                    lowerHull.remove(lowerHull.size() - 1);\n                }\n                lowerHull.add(v);\n            }\n            for (int j = upperHull.size() - 1; j > 0; j--) {\n                Vector before = upperHull.get(j);\n                Vector after = upperHull.get(j - 1);\n                exchanges.add(after.minus(before));\n            }\n            for (int j = 0; j < lowerHull.size() - 1; j++) {\n                Vector before = lowerHull.get(j);\n                Vector after = lowerHull.get(j + 1);\n                exchanges.add(after.minus(before));\n            }\n            Vector lowest = group[0];\n            for (Vector v : group) {\n                if (v.y < lowest.y || (v.y == lowest.y && v.x < lowest.x)) {\n                    lowest = v;\n                }\n            }\n            curr = curr.plus(lowest);\n        }\n        exchanges.sort((u, v) -> {\n            int uHalf = u.y > 0L || (u.y == 0L && u.x > 0L) ? 0 : 1;\n            int vHalf = v.y > 0L || (v.y == 0L && v.x > 0L) ? 0 : 1;\n            if (vHalf != uHalf) {\n                return uHalf - vHalf;\n            }\n            int uWhetherZero = u.y == 0L ? 0 : 1;\n            int vWhetherZero = v.y == 0L ? 0 : 1;\n            if (uWhetherZero == 0 || vWhetherZero == 0) {\n                return uWhetherZero - vWhetherZero;\n            }\n            return Long.compare(v.x * u.y, u.x * v.y);\n        });\n        long answer = curr.magnitude();\n        for (Vector exchange : exchanges) {\n            curr = curr.plus(exchange);\n            answer = Math.max(answer, curr.magnitude());\n        }\n        System.out.println(answer);\n    }\n \n    static class Vector {\n        final long x;\n        final long y;\n \n        Vector(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n \n        Vector plus(Vector other) {\n            return new Vector(x + other.x, y + other.y);\n        }\n \n        Vector minus(Vector other) {\n            return new Vector(x - other.x, y - other.y);\n        }\n \n        long magnitude() {\n            return (x * x) + (y * y);\n        }\n \n        @Override\n        public String toString() {\n            return \"Vector{\" +\n                    \"x=\" + x +\n                    \", y=\" + y +\n                    '}';\n        }\n    }\n \n    static long sideOfLine(Vector a, Vector b, Vector c) {\n        long left = (b.x - a.x) * (c.y - a.y);\n        long right = (b.y - a.y) * (c.x - a.x);\n        return left - right;\n    }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3\n\n2\n-2 0\n1 0\n\n2\n0 -2\n0 1\n\n3\n-5 -5\n5 1\n10 10\n",
        "output": "242\n"
      }
    ],
    "description_no_samples": "In a magical realm, a group of wizards is planning their flight paths. Instead of evaluating each segment of the journey separately and then summing them, they want to optimize the entire path at once.\n\nSpecifically, you have $N$ ($2 \\le N \\le 10^5$) sets of magical vectors on a 2D map, where each vector is represented by an ordered pair $(a, b)$. Choose one vector from each set such that the resultant vector from combining all chosen vectors is as far from the starting point as possible.\n\nIt is guaranteed that the total number of vectors is at most $2 \\cdot 10^5$. Each set has at least $2$ vectors, and within a set, all vectors are distinct. Additionally, every $a$ and $b$ coordinate has an absolute value at most $\\frac{10^9}{N}$.\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$, the number of vector sets.\n\nEach set begins with $G$, the number of vectors in that set, followed by $G$ lines containing the vectors in that set. Consecutive sets are separated by newlines.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nThe maximum possible squared Euclidean distance.",
    "num_samples": 1,
    "mapping": [
      "cows -> wizards",
      "multiple choice test -> flight path planning",
      "groups -> sets",
      "vectors -> magical vectors",
      "x, y -> a, b",
      "origin -> starting point"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "998_1_platinum_falling_portals": {
    "name": "Falling Portals",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=998",
    "test_data_link": "http://www.usaco.org/current/data/falling_platinum_jan20.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_falling_platinum_jan20.html",
    "contest_link": "http://www.usaco.org/index.php?page=jan20results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "998",
    "problem_id": "998_1_platinum_falling_portals",
    "description": "In a futuristic city, there are $N$ ($2\\le N\\le 2\\cdot 10^5$) skyscrapers, each equipped with an elevator. Initially, skyscraper $i$ (for $1 \\leq i \\leq N$) is located at $x$-coordinate $i$, and its height is $H_i$ ($1\\le H_i\\le 10^9$). There is also a drone stationed on each skyscraper. At time $0$, all heights are distinct, and the skyscrapers start descending: skyscraper $i$ lowers continuously at a rate of $i$ units per second. \n\nAt any point in time when two skyscrapers reach the same height (possibly at a fractional time), the elevators are considered to be 'synced', allowing a drone on one skyscraper to instantly transfer to the other. \n\nFor each $i$, the drone on skyscraper $i$ aims to transfer to skyscraper $D_i$ ($D_i \\neq i$). Help each drone determine the time required for its optimal journey.\n\nEach query's output should be a fraction $a/b$ where $a$ and $b$ are positive and relatively prime integers, or $-1$ if the journey is impossible.\n\nSCORING:\nTest cases 2-3 satisfy $N\\le 100.$ Test cases 4-5 satisfy $N\\le 2000.$ Test cases 6-14 satisfy no additional constraints.\n\nINPUT FORMAT:\nThe first line of input contains a single integer $N.$\n\nThe next line contains $N$ space-separated integers $H_1,H_2,\\ldots,H_N.$\n\nThe next line contains $N$ space-separated integers $D_1,D_2,\\ldots,D_N.$\n\nOUTPUT FORMAT:\nPrint $N$ lines, the $i$-th of which contains the journey time for drone $i.$",
    "num_tests": 14,
    "solution": "\n(Analysis by Benjamin Qi)\nFix $i.$ Consider a graph of time versus\n$y$-coordinate; then world $i$ is represented by a line of slope $-i$. Call a \npoint $(T,Y)$ on this graph \"attainable\" if it is possible for cow $i$ to be at\n$y$-coordinate $Y$ at time $T.$\nSubtask 1: $O(N^3)$ BFS\nSubtask 2: It can be shown that the shortest path between any two worlds\ncontains at most one intermediate world. So for each query, iterate over all \nworlds aside from the start and the end and check if it can be the intermediate\none in $O(N^2)$ time. Alternatively, speed up the solution from subtask 1 with\nbitset.\nSubtask 3: WLOG suppose that $A[Q_i]<A_i.$ Clearly no attainable points lie below the lower convex hull\nof all lines representing worlds $j$ such that $A_j\\ge A_i$. Furthermore, all\npoints on this hull are attainable. Thus, it suffices to find the $t$-coordinate\nof the intersection of the line $y=-Q_it+A[Q_i]$ with this lower hull. We can\ncompute the hulls for all $i$ by sorting the lines by $A_i$ in decreasing order\nand adding them to the hull one by one. This can be done using a deque. After\ncomputing the hull for $i,$ we can binary search to find the intersection of the\nline with the hull.\nSpencer's Code:\n\nimport java.io.*;\nimport java.util.*;\n\npublic class falling {\n\tpublic static class Obj implements Comparable<Obj>{\n\t\tpublic long y, d;\n\t\tpublic int ind;\n\t\tpublic Obj(long a, long b, int c) {\n\t\t\ty = a;\n\t\t\td = b;\n\t\t\tind = c;\n\t\t}\n\t\tpublic int compareTo(Obj o) {\n\t\t\treturn Long.compare(y, o.y);\n\t\t}\n\t}\n\tpublic static long gc(long a, long b) {\n\t\tif(a==0L || b==0L) {\n\t\t\treturn a+b;\n\t\t}\n\t\treturn gc(b%a,a);\n\t}\n\tpublic static class Pair{\n\t\tpublic long first, second;\n\t\tPair(long a, long b){\n\t\t\tfirst = a;\n\t\t\tsecond = b;\n\t\t}\n\t}\n\tpublic static Pair make_pair(long a, long b) {\n\t\treturn new Pair(a,b);\n\t}\n\tpublic static Pair ev(Obj a, Obj b) {\n\t\treturn make_pair(Math.abs(a.y-b.y),Math.abs(a.d-b.d));\n\t}\n\tpublic static int cmp(Obj a, Obj b, Obj c) {\n\t\tPair l = ev(a,c);\n\t\tPair r = ev(b,c);\n\t\tlong res = l.first*r.second-r.first*l.second;\n\t\tif(res<0L) {\n\t\t\treturn -1;\n\t\t}\n\t\tif(res==0L) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\tpublic static boolean used(Obj a, Obj b, Obj c) {\n\t\tPair l = ev(a,b);\n\t\tPair r = ev(b,c);\n\t\tlong res = l.first*r.second-r.first*l.second;\n\t\treturn (res<0L);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader in = new BufferedReader(new FileReader(\"falling.in\"));\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tString[] line = in.readLine().split(\" \");\n\t\tlong[] a = new long[n];\n\t\tint[] q = new int[n];\n\t\tlong[] num = new long[n];\n\t\tlong[] dem = new long[n];\n\t\tfor(int i = 0; i<line.length; i++) {\n\t\t\ta[i] = Integer.parseInt(line[i]);\n\t\t}\n\t\tline = in.readLine().split(\" \");\n\t\tfor(int i =0 ; i<line.length; i++) {\n\t\t\tq[i] = Integer.parseInt(line[i])-1;\n\t\t}\n\t\tArrayList<Obj> li = new ArrayList<Obj>();\n\t\tArrayList<Obj> all = new ArrayList<Obj>();\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tli.add(new Obj(a[i],-(i+1),i));\n\t\t\tall.add(new Obj(a[i],-(i+1),i));\n\t\t}\n\t\tCollections.sort(li);\n\t\tArrayList<Obj> cur = new ArrayList<Obj>();\n\t\tfor(int i = li.size()-1; i>=0; i--) {\n\t\t\tObj now = li.get(i);\n\t\t\twhile(cur.size()>0) {\n\t\t\t\tif(now.d < cur.get(cur.size()-1).d) {\n\t\t\t\t\tcur.remove(cur.size()-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cur.size()>1 && !used(now,cur.get(cur.size()-1),cur.get(cur.size()-2))) {\n\t\t\t\t\tcur.remove(cur.size()-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur.add(now);\n\t\t\tint ind = li.get(i).ind;\n\t\t\tif(a[ind]>a[(int)q[(int)ind]]) {\n\t\t\t\tif(cur.get(0).d > -(q[ind]+1)) {\n\t\t\t\t\tnum[ind]=-1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = cur.size()-1;\n \n\t\t\t\t\twhile(lo<hi){\n\t\t\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\t\t\tint l = mid;\n\t\t\t\t\t\tint r = mid+1;\n\t\t\t\t\t\tif(cur.get(r).d > - (q[ind]+1)){\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res = cmp(cur.get(l),cur.get(r),all.get((int)q[(int)ind]));\n\t\t\t\t\t\tif(res<0){\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(res==0){\n\t\t\t\t\t\t\tlo = l;\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlo = r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tPair got = ev(cur.get(lo),all.get((int)q[(int)ind]));\n\t\t\t\t\tlong g = gc(got.first,got.second);\n\t\t\t\t\tnum[ind] = got.first/g;\n\t\t\t\t\tdem[ind] = got.second/g;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcur.clear();\n\t\tfor(int i = 0; i<li.size(); i++){\n\t\t\tObj now = li.get(i);\n\t\t\twhile(cur.size()>0){\n\t\t\t\tif(now.d > cur.get(cur.size()-1).d){\n\t\t\t\t\tcur.remove(cur.size()-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(cur.size()>1 && !used(now, cur.get(cur.size()-1), cur.get(cur.size()-2))){\n\t\t\t\t\tcur.remove(cur.size()-1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcur.add(now);\n\t\t\tint ind = li.get(i).ind;\n\t\t\tif(a[ind]<a[(int)q[(int)ind]]){\n\t\t\t\tif(cur.get(0).d < -(q[ind]+1)){\n\t\t\t\t\tnum[ind] = -1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint lo = 0;\n\t\t\t\t\tint hi = cur.size()-1;\n\t\t\t\t\twhile(lo<hi){\n\t\t\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\t\t\tint l = mid;\n\t\t\t\t\t\tint r = mid+1;\n\t\t\t\t\t\tif(cur.get(r).d < - (q[ind]+1)){\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res = cmp(cur.get(l),cur.get(r),all.get((int)q[(int)ind]));\n\t\t\t\t\t\tif(res<0){\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(res==0){\n\t\t\t\t\t\t\tlo = l;\n\t\t\t\t\t\t\thi = l;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlo = r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tPair got = ev(cur.get(lo),all.get((int)q[(int)ind]));\n\t\t\t\t\tlong g = gc(got.first,got.second);\n\t\t\t\t\tnum[ind] = got.first/g;\n\t\t\t\t\tdem[ind] = got.second/g;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"falling.out\")));\n\t\tfor(int i = 0; i<n; i++){\n\t\t\tif (num[i]==-1) out.println(-1);\n\t\t\telse out.println(num[i]+\"/\"+dem[i]);\n\t\t}\n\t\tout.close();\n\t}\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4\n3 5 10 2\n3 3 2 1",
        "output": "7/2\n7/2\n5/1\n-1"
      }
    ],
    "description_no_samples": "In a futuristic city, there are $N$ ($2\\le N\\le 2\\cdot 10^5$) skyscrapers, each equipped with an elevator. Initially, skyscraper $i$ (for $1 \\leq i \\leq N$) is located at $x$-coordinate $i$, and its height is $H_i$ ($1\\le H_i\\le 10^9$). There is also a drone stationed on each skyscraper. At time $0$, all heights are distinct, and the skyscrapers start descending: skyscraper $i$ lowers continuously at a rate of $i$ units per second. \n\nAt any point in time when two skyscrapers reach the same height (possibly at a fractional time), the elevators are considered to be 'synced', allowing a drone on one skyscraper to instantly transfer to the other. \n\nFor each $i$, the drone on skyscraper $i$ aims to transfer to skyscraper $D_i$ ($D_i \\neq i$). Help each drone determine the time required for its optimal journey.\n\nEach query's output should be a fraction $a/b$ where $a$ and $b$ are positive and relatively prime integers, or $-1$ if the journey is impossible.\n\nSCORING:\nTest cases 2-3 satisfy $N\\le 100.$ Test cases 4-5 satisfy $N\\le 2000.$ Test cases 6-14 satisfy no additional constraints.\n\nINPUT FORMAT:\nThe first line of input contains a single integer $N.$\n\nThe next line contains $N$ space-separated integers $H_1,H_2,\\ldots,H_N.$\n\nThe next line contains $N$ space-separated integers $D_1,D_2,\\ldots,D_N.$\n\nOUTPUT FORMAT:\nPrint $N$ lines, the $i$-th of which contains the journey time for drone $i.$",
    "num_samples": 1,
    "mapping": [
      "world -> skyscraper",
      "portal -> elevator",
      "cow -> drone",
      "y-coordinate -> height",
      "falling -> descending",
      "align -> synced",
      "Q -> D",
      "A -> H"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "769_1_platinum_push_a_box": {
    "name": "Push a Box",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=769",
    "test_data_link": "http://www.usaco.org/current/data/pushabox_platinum_dec17.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_pushabox_platinum_dec17.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec17results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "769",
    "problem_id": "769_1_platinum_push_a_box",
    "description": "Captain Salty and his crew have discovered an ancient treasure map. The treasure, a large chest, is hidden in a maze-like cave, represented as an $N \\times M$ grid. Some cells in the grid are blocked by rocks. Captain Salty stands on one cell of this grid, and the treasure chest is on another cell. Neither the captain nor the chest can occupy the same cell simultaneously, and neither can be in a cell with rocks.\n\nCaptain Salty can move in the four cardinal directions (north, east, south, west) as long as he does not walk into rocks. If he attempts to move to the space with the chest, the chest will be pushed one space in that direction, provided there is an empty cell on the other side. If there is no empty cell, the captain cannot make that move.\n\nA particular grid cell is marked as the target location. Captain Salty's goal is to push the chest to this location.\n\nGiven the layout of the cave, including the starting positions of the chest and the captain, and the target position of the chest, determine if it is possible to move the chest to the target location.\n\nNote: This problem allows 512MB of memory usage, which is higher than the usual limit of 256MB.\n\nINPUT FORMAT:\nThe first line contains three integers, $N$, $M$, and $Q$, where $N$ is the number of rows in the grid and $M$ is the number of columns.\n\n$1 \\le N,M \\le 1500$.\n\n$1 \\le Q \\le 50,000$.\n\nThe following $N$ lines represent the grid, using characters to denote empty cells (.), rocks (#), Captain Salty's starting position (S), and the chest's initial location (T).\n\nThis is followed by $Q$ lines, each containing a pair of integers $(R, C)$. For each pair, determine if it is possible to push the chest to that cell at row $R$, column $C$, starting from the initial configuration of the cave. The top row is row 1, and the left column is column 1.\n\nOUTPUT FORMAT:\nPrint $Q$ lines, each containing either \"SUCCESS\" or \"FAILURE\".",
    "num_tests": 15,
    "solution": "\n(Analysis by Nathan Pinsker)\nOne immediate thought that is to use some flavor of graph search to solve this\nproblem, since the state space is fairly tractable and straightforward (it only\nconsists of Bessie's and the box's position). Unfortunately, with\n$M, N \\leq 1,500$, this approach is both too slow and too time-consuming, since\nit takes $O(N^2M^2)$ space and time. However, notice that this naive approach\nkeeps track of a lot of unnecessary state information. In particular, Bessie's\nposition isn't terribly important to us most of the time -- only the box's\nposition -- and Bessie's position only matters insofar as it determines where\nthe box will be pushed next. In other words, we don't actually care about\nBessie's precise position, only from which directions she can push the box at\nthe next step.\nWe can take advantage of this insight by redefining our state slightly. It still\nconsists of Bessie's and the box's position, but we limit ourselves to\nconsidering only states where Bessie is directly next to the box. This is\n$O(MN)$ states, which is possible to work with.\nHowever, the state transition becomes more complicated as a result. Bessie can\ntransition between states in one of two ways: either she can push the box, or\nshe can walk around the box and reach another side. The first type of transition\nis easy to handle, so we turn our attention to handling the second type.\nHandling this type of transition is equivalent to asking \"Can I get from point A\nto point B, without walking over the square containing the box?\" Luckily, this\nquestion is well-studied, and is known as\nbiconnected\ncomponents. We consider the lattice graph formed by taking each unoccupied\nspot in the barn as a vertex and edges between each pair of adjacent vertices.\nSince A and B are clearly part of the same connected component, there is an\nalternate path from A to B if and only if they are part of the same biconnected\ncomponent in this graph.\nTherefore, we can solve the problem by precomputing all biconnected components\nof the lattice graph described above. We perform a BFS over our $O(NM)$ states;\nif we want to check whether Bessie can walk around the box to reach another side\nwithout moving it, we simply query our graph to see if Bessie's start and end\nvertex are part of the same biconnected component. This operation is $O(1)$, so\nour overall BFS runtime will be $O(NM)$. The runtime of our biconnected\ncomponents algorithm is also $O(NM)$. Once we have run these two algorithms, we\ncan answer queries in $O(1)$ time, so our overall running time is\n$O(NM + Q)$.\nTravis's solution is below:\n\n#include <cstdio>\n#include <cassert>\n#include <vector>\nusing namespace std;\n \n#define NMAX 1500\n \nstruct P {\n  int x, y;\n  P(int x, int y): x(x), y(y) { }\n  P() {}\n  bool operator ==(P b) {\n    return x == b.x && y == b.y;\n  }\n  bool operator !=(P b) {\n    return !(x == b.x && y == b.y);\n  }\n};\n \nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n \nint getDIndex(P v1, P v2) {\n  for (int d = 0; d < 4; d++) {\n    if (v1.x + dx[d] == v2.x && v1.y + dy[d] == v2.y) {\n      return d;\n    }\n  }\n  assert(false);\n}\n \nint width, height;\nint blockStartX, blockStartY;\nint blockEndX, blockEndY;\nint humanStartX, humanStartY;\n \nbool isOpen[NMAX][NMAX];\n \nbool visited[NMAX][NMAX];\nint depth[NMAX][NMAX];\nint low[NMAX][NMAX];\n \nunsigned short adjacency[NMAX][NMAX];\nint initialD = -1;\n \nvoid biconnected_component_dfs(P v, P parent, int myDepth) {\n  visited[v.x][v.y] = true;\n  depth[v.x][v.y] = myDepth;\n  low[v.x][v.y] = myDepth;\n  int childCount = 0;\n \n  vector<vector<P>> components;\n \n  for (int d = 0; d < 4; d++) {\n    int x1 = v.x + dx[d];\n    int y1 = v.y + dy[d];\n    if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height && isOpen[x1][y1]) {\n      if (!visited[x1][y1]) {\n        if (x1 == blockStartX && y1 == blockStartY) {\n          initialD = (d + 2) % 4;\n        }\n \n        bool alreadyVisited[4];\n        for (int d2 = 0; d2 < 4; d2++) {\n          int x2 = v.x + dx[d2];\n          int y2 = v.y + dy[d2];\n          alreadyVisited[d2] = (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height && isOpen[x2][y2] && visited[x2][y2]);\n        }\n \n        biconnected_component_dfs(P(x1, y1), v, myDepth+1);\n        childCount++;\n        if (low[x1][y1] >= depth[v.x][v.y]) {\n          vector<P> cmp;\n \n          for (int d2 = 0; d2 < 4; d2++) {\n            int x2 = v.x + dx[d2];\n            int y2 = v.y + dy[d2];\n            if (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height && isOpen[x2][y2] && visited[x2][y2] && !alreadyVisited[d2]) {\n              cmp.push_back(P(x2,y2));\n            }\n          }\n \n          components.push_back(cmp);\n        }\n        low[v.x][v.y] = min(low[v.x][v.y], low[x1][y1]);\n      } else {\n        if (parent != P(x1,y1)) {\n          low[v.x][v.y] = min(low[v.x][v.y], depth[x1][y1]);\n        }\n      }\n    }\n  }\n \n  vector<P> lastComponent;\n  for (int d = 0; d < 4; d++) {\n    int x1 = v.x + dx[d];\n    int y1 = v.y + dy[d];\n    if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height && isOpen[x1][y1]) {\n      bool exist = false;\n      for (int i = 0; i < components.size(); i++) {\n        for (int j = 0; j < components[i].size(); j++) {\n          if (components[i][j] == P(x1,y1)) {\n            exist = true;\n          }\n        }\n      }\n      if (!exist) {\n        lastComponent.push_back(P(x1,y1));\n      }\n    }\n  }\n  if (lastComponent.size() > 0) {\n    components.push_back(lastComponent);\n  }\n \n  unsigned short bits = 0;\n \n  for (auto& component : components) {\n    for (int i = 1; i < component.size(); i++) {\n      int dIndex = getDIndex(v, component[i-1]);\n      int dIndex2 = getDIndex(v, component[i]);\n      bits |= ((unsigned short)1) << (dIndex*4 + dIndex2);\n      bits |= ((unsigned short)1) << (dIndex2*4 + dIndex);\n    }\n  }\n \n  adjacency[v.x][v.y] = bits;\n}\n \npair<P, char> bfs[NMAX * NMAX * 4];\nbool bfsVisited[NMAX][NMAX][4];\nvoid do_bfs(pair<P, char> startV) {\n  bfs[0] = startV;\n  int index = 0;\n  int len = 1;\n  for (int i = 0; i < width; i++) {\n    for (int j = 0; j < height; j++) {\n      for (int d = 0; d < 4; d++) {\n        bfsVisited[i][j][d] = false;\n      }\n    }\n  }\n  bfsVisited[startV.first.x][startV.first.y][(int)startV.second] = true;\n  while (index < len) {\n    pair<P, char> v = bfs[index];\n    index++;\n \n    P p = v.first;\n    int d = v.second;\n \n    int x1 = p.x;\n    int y1 = p.y;\n    int x2 = x1 - dx[d];\n    int y2 = y1 - dy[d];\n    if (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height && isOpen[x2][y2]) {\n      pair<P, char> w = make_pair(P(x2, y2), d);\n      if (!bfsVisited[w.first.x][w.first.y][(int)w.second]) {\n        bfsVisited[w.first.x][w.first.y][(int)w.second] = true;\n        bfs[len++] = w;\n      }\n    }\n \n    for (int d1 = 0; d1 < 4; d1++) {\n      if (adjacency[p.x][p.y] & (((unsigned short)1) << (d*4 + d1))) {\n        pair<P, char> w = make_pair(P(p.x, p.y), d1);\n        if (!bfsVisited[w.first.x][w.first.y][(int)w.second]) {\n          bfsVisited[w.first.x][w.first.y][(int)w.second] = true;\n          bfs[len++] = w;\n        }\n      }\n    }\n  }\n}\n \nchar rowInput[NMAX + 5];\n \nint main() {\n  int q;\n  scanf(\"%d\", &height);\n  scanf(\"%d\", &width);\n  scanf(\"%d\", &q);\n  blockStartX = -1;\n  blockStartY = -1;\n  humanStartX = -1;\n  humanStartY = -1;\n  for (int i = 0; i < height; i++) {\n    scanf(\"%s\", rowInput);\n    for (int j = 0; j < width; j++) {\n      isOpen[j][i] = (rowInput[j] != '#');\n      if (rowInput[j] == 'A') {\n        assert(humanStartX == -1);\n        humanStartX = j;\n        humanStartY = i;\n      } else if (rowInput[j] == 'B') {\n        assert(blockStartX == -1);\n        blockStartX = j;\n        blockStartY = i;\n      } else {\n        assert(rowInput[j] == '.' || rowInput[j] == '#');\n      }\n    }\n  }\n \n  for (int x = 0; x < width; x++) {\n    for (int y = 0; y < height; y++) {\n      visited[x][y] = false;\n    }\n  }\n \n  biconnected_component_dfs(P(humanStartX, humanStartY), P(-1, -1), 0);\n \n  if (initialD == -1) {\n    for (int i = 0; i < q; i++) {\n      int blockEndX, blockEndY;\n      scanf(\"%d\", &blockEndY);\n      scanf(\"%d\", &blockEndX);\n      blockEndX--;\n      blockEndY--;\n      printf(\"%s\\n\", blockStartX == blockEndX && blockStartY == blockEndY ? \"YES\" : \"NO\");\n    }\n    return 0;\n  }\n \n  do_bfs(make_pair(P(blockStartX, blockStartY), (char)initialD));\n \n  for (int i = 0; i < q; i++) {\n    int blockEndX, blockEndY;\n    scanf(\"%d\", &blockEndY);\n    scanf(\"%d\", &blockEndX);\n    blockEndX--;\n    blockEndY--;\n    assert(isOpen[blockEndX][blockEndY]);\n    bool isPossible =\n      bfsVisited[blockEndX][blockEndY][0] ||\n      bfsVisited[blockEndX][blockEndY][1] ||\n      bfsVisited[blockEndX][blockEndY][2] ||\n      bfsVisited[blockEndX][blockEndY][3];\n    printf(\"%s\\n\", isPossible ? \"YES\" : \"NO\");\n  }\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5 5 4\n##.##\n##.##\nS.T..\n##.##\n##.##\n3 2\n3 5\n1 3\n5 3\n",
        "output": "FAILURE\nSUCCESS\nFAILURE\nFAILURE\n"
      }
    ],
    "description_no_samples": "Captain Salty and his crew have discovered an ancient treasure map. The treasure, a large chest, is hidden in a maze-like cave, represented as an $N \\times M$ grid. Some cells in the grid are blocked by rocks. Captain Salty stands on one cell of this grid, and the treasure chest is on another cell. Neither the captain nor the chest can occupy the same cell simultaneously, and neither can be in a cell with rocks.\n\nCaptain Salty can move in the four cardinal directions (north, east, south, west) as long as he does not walk into rocks. If he attempts to move to the space with the chest, the chest will be pushed one space in that direction, provided there is an empty cell on the other side. If there is no empty cell, the captain cannot make that move.\n\nA particular grid cell is marked as the target location. Captain Salty's goal is to push the chest to this location.\n\nGiven the layout of the cave, including the starting positions of the chest and the captain, and the target position of the chest, determine if it is possible to move the chest to the target location.\n\nNote: This problem allows 512MB of memory usage, which is higher than the usual limit of 256MB.\n\nINPUT FORMAT:\nThe first line contains three integers, $N$, $M$, and $Q$, where $N$ is the number of rows in the grid and $M$ is the number of columns.\n\n$1 \\le N,M \\le 1500$.\n\n$1 \\le Q \\le 50,000$.\n\nThe following $N$ lines represent the grid, using characters to denote empty cells (.), rocks (#), Captain Salty's starting position (S), and the chest's initial location (T).\n\nThis is followed by $Q$ lines, each containing a pair of integers $(R, C)$. For each pair, determine if it is possible to push the chest to that cell at row $R$, column $C$, starting from the initial configuration of the cave. The top row is row 1, and the left column is column 1.\n\nOUTPUT FORMAT:\nPrint $Q$ lines, each containing either \"SUCCESS\" or \"FAILURE\".",
    "num_samples": 1,
    "mapping": [
      "Bessie -> Captain Salty",
      "box -> chest",
      "barn -> cave",
      "hay -> rocks",
      "goal -> target location",
      "A -> S",
      "B -> T",
      "\"YES\" -> \"SUCCESS\"",
      "\"NO\" -> \"FAILURE\""
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text.replace('A', 'S').replace('B', 'T')\n\ndef transform_output(text: str) -> str:\n    return text.replace('YES', 'SUCCESS').replace('NO', 'FAILURE')\n"
  },
  "1452_1_platinum_all_pairs_similarity": {
    "name": "USACO 2024 December Contest, Platinum",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1452",
    "test_data_link": "http://www.usaco.org/current/data/prob1_platinum_dec24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_platinum_dec24.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec24results",
    "inner_contest_link": null,
    "problem_level": "platinum",
    "cp_id": "1452",
    "problem_id": "1452_1_platinum_all_pairs_similarity",
    "description": "**Note: The memory limit for this problem is 512MB, twice the default.**\nIn an enchanted forest, there are $N$ ($1\\le N\\le 5\\cdot 10^5$) magical creatures, each assigned a mystical rune of length $K$ that is not all zero ($1\\le K\\le 20$). Different creatures may be assigned the same rune.\nThe Compatibility Score of two runes is defined as the number of common magical symbols in their bitwise intersection divided by the number of distinct magical symbols in their bitwise union.\nFor example, the Compatibility Score of the runes $\\texttt{11001}$ and $\\texttt{11010}$ would be $2/4$.\nFor each creature, output the sum of their rune's Compatibility Score with each of the $N$ creatures' runes including their own, modulo $10^9+7$. Specifically, if\nthe sum is equal to a rational number $a/b$ where $a$ and $b$ are integers sharing no common factors, output the unique integer $x$ in the range\n$[0,10^9+7)$ such that $bx-a$ is divisible by $10^9+7$.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $K$.\nThe next $N$ lines each contain an integer $i\\in (0,2^K)$, representing a creature associated with the length-$K$ binary representation of $i$.\nOUTPUT FORMAT (output arrives at the terminal / stdout):\nOutput the sum modulo $10^9+7$ for each creature on a separate line.\nSAMPLE INPUT:\n4 2\n1\n1\n2\n3\nSAMPLE OUTPUT:\n500000006\n500000006\n500000005\n500000006\nThe creatures are associated with the following runes:\n$[\\texttt{01}, \\texttt{01}, \\texttt{10}, \\texttt{11}]$.\nFor the first creature, the sum is\n$\\text{comp}(1,1)+\\text{comp}(1,1)+\\text{comp}(1,2)+\\text{comp}(1,3)=1+1+0+1/2\\equiv 500000006\\pmod{10^9+7}$.\nThe second creature's rune is the same as the first creature's, so their sum is the\nsame as above.\nFor the third creature, the sum is\n$\\text{comp}(2,1)+\\text{comp}(2,1)+\\text{comp}(2,2)+\\text{comp}(2,3)=0+0+1+1/2\\equiv 500000005\\pmod{10^9+7}$.\nSCORING:\nInputs 2-15: There will be two test cases for each of\n$K\\in \\{10,15,16,17,18,19,20\\}$.\nProblem credits: Benjamin Qi",
    "description_no_samples": "**Note: The memory limit for this problem is 512MB, twice the default.**\nIn an enchanted forest, there are $N$ ($1\\le N\\le 5\\cdot 10^5$) magical creatures, each assigned a mystical rune of length $K$ that is not all zero ($1\\le K\\le 20$). Different creatures may be assigned the same rune.\nThe Compatibility Score of two runes is defined as the number of common magical symbols in their bitwise intersection divided by the number of distinct magical symbols in their bitwise union.\nFor example, the Compatibility Score of the runes $\\texttt{11001}$ and $\\texttt{11010}$ would be $2/4$.\nFor each creature, output the sum of their rune's Compatibility Score with each of the $N$ creatures' runes including their own, modulo $10^9+7$. Specifically, if\nthe sum is equal to a rational number $a/b$ where $a$ and $b$ are integers sharing no common factors, output the unique integer $x$ in the range\n$[0,10^9+7)$ such that $bx-a$ is divisible by $10^9+7$.\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains $N$ and $K$.\nThe next $N$ lines each contain an integer $i\\in (0,2^K)$, representing a creature associated with the length-$K$ binary representation of $i$.\nOUTPUT FORMAT (output arrives at the terminal / stdout):\nOutput the sum modulo $10^9+7$ for each creature on a separate line.\nSAMPLE INPUT:\n4 2\n1\n1\n2\n3\nSAMPLE OUTPUT:\n500000006\n500000006\n500000005\n500000006\nThe creatures are associated with the following runes:\n$[\\texttt{01}, \\texttt{01}, \\texttt{10}, \\texttt{11}]$.\nFor the first creature, the sum is\n$\\text{comp}(1,1)+\\text{comp}(1,1)+\\text{comp}(1,2)+\\text{comp}(1,3)=1+1+0+1/2\\equiv 500000006\\pmod{10^9+7}$.\nThe second creature's rune is the same as the first creature's, so their sum is the\nsame as above.\nFor the third creature, the sum is\n$\\text{comp}(2,1)+\\text{comp}(2,1)+\\text{comp}(2,2)+\\text{comp}(2,3)=0+0+1+1/2\\equiv 500000005\\pmod{10^9+7}$.\nSCORING:\nInputs 2-15: There will be two test cases for each of\n$K\\in \\{10,15,16,17,18,19,20\\}$.\nProblem credits: Benjamin Qi",
    "samples": [
      {
        "input": "4 2\n1\n1\n2\n3\n",
        "output": "500000006\n500000006\n500000005\n500000006\n"
      }
    ],
    "mapping": [
      "cows -> magical creatures",
      "bitstrings -> runes",
      "Jaccard similarity -> Compatibility Score",
      "set bits -> magical symbols",
      "Farmer John -> enchanted forest"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "1404_1_platinum_lazy_cow": {
    "name": "USACO 2024 February Contest, Platinum",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1404",
    "test_data_link": "http://www.usaco.org/current/data/prob1_platinum_feb24.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_prob1_platinum_feb24.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb24results",
    "inner_contest_link": null,
    "problem_level": "platinum",
    "cp_id": "1404",
    "problem_id": "1404_1_platinum_lazy_cow",
    "description": "You are tasked with helping a wizard named Eldrin collect magical stones. Each minute, Eldrin can choose to do nothing, expending no mana; or spend $3^{a-1}$ mana to collect $a$ stones, for some positive integer $a$. Eldrin receives $D$ ($1\\le D\\le 2\\cdot 10^5$) requests from the Council of Magicians. For the $i$th request, within the first $m_i$ minutes, Eldrin needs to have collected at least $b_i$ stones in total ($1\\le m_i\\le 10^6, 1 \\leq b_i \\leq 10^{12}$). Let $e_i$ be the smallest amount of mana Eldrin needs to spend to satisfy the first $i$ requests. Print $e_1,\\dots,e_D$ modulo $10^9+7$. INPUT FORMAT (input arrives from the terminal / stdin): The first line contains $D$. The $i$th of the next $D$ lines contains two space-separated integers $m_i$ and $b_i$. OUTPUT FORMAT (print output to the terminal / stdout): Output $D$ lines, the $i$th containing $e_i \\text{ mod } 10^9+7$. SAMPLE INPUT: 4 5 11 6 10 10 15 10 30 SAMPLE OUTPUT: 21 21 25 90",
    "description_no_samples": "You are tasked with helping a wizard named Eldrin collect magical stones. Each minute, Eldrin can choose to do nothing, expending no mana; or spend $3^{a-1}$ mana to collect $a$ stones, for some positive integer $a$. Eldrin receives $D$ ($1\\le D\\le 2\\cdot 10^5$) requests from the Council of Magicians. For the $i$th request, within the first $m_i$ minutes, Eldrin needs to have collected at least $b_i$ stones in total ($1\\le m_i\\le 10^6, 1 \\leq b_i \\leq 10^{12}$). Let $e_i$ be the smallest amount of mana Eldrin needs to spend to satisfy the first $i$ requests. Print $e_1,\\dots,e_D$ modulo $10^9+7$. INPUT FORMAT (input arrives from the terminal / stdin): The first line contains $D$. The $i$th of the next $D$ lines contains two space-separated integers $m_i$ and $b_i$. OUTPUT FORMAT (print output to the terminal / stdout): Output $D$ lines, the $i$th containing $e_i \\text{ mod } 10^9+7$. SAMPLE INPUT: 4 5 11 6 10 10 15 10 30 SAMPLE OUTPUT: 21 21 25 90",
    "samples": [
      {
        "input": "4\n5 11\n6 10\n10 15\n10 30\n",
        "output": "21\n21\n25\n90\n"
      }
    ],
    "mapping": [
      "Bessie -> Eldrin",
      "test cases -> stones",
      "energy -> mana",
      "Farmer John -> Council of Magicians",
      "demand -> request"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "974_1_platinum_tree_depth": {
    "name": "Tree Depth",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=974",
    "test_data_link": "http://www.usaco.org/current/data/treedepth_platinum_dec19.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_treedepth_platinum_dec19.html",
    "contest_link": "http://www.usaco.org/index.php?page=dec19results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "974",
    "problem_id": "974_1_platinum_tree_depth",
    "description": "In a distant galaxy, a team of explorers is tasked with mapping star systems using a special method that relies on star proximity. \n\nTo perform the mapping, the team starts with a permutation $s=\\{s_1,s_2,\\ldots,s_N\\}$ of the integers $1\\ldots N$, where $N\\le 300$. They then run the following procedure with arguments $1$ and $N.$\n\nexplore(l,r):\n  if l > r, return empty star cluster;\n  x = argmin_{l <= i <= r} s_i; // index of closest star s_i in {s_l,...,s_r}\n  return a star cluster with x as the core, \n    explore(l,x-1) as the left sub-cluster,\n    explore(x+1,r) as the right sub-cluster;\n\nFor example, the permutation $\\{3,2,5,1,4\\}$ organizes the stars into the following cluster:\n\n    4\n   / \\\n  2   5\n / \\ \n1   3\n\nLet $d_i(s)$ denote the distance of star $i$ from the core of the cluster corresponding to $s,$ meaning the number of stars on the path from $s_i$ to the core. In the above example, $d_4(s)=1, d_2(s)=d_5(s)=2,$ and $d_1(s)=d_3(s)=3.$\n\nThe number of proximity inversions of $s$ is equal to the number of pairs of stars $(i,j)$ such that $1\\le i<j\\le N$ and $s_i>s_j.$ The explorers know that the $s$ that will be used to organize the stars has exactly $K$ proximity inversions $(0\\le K\\le \\frac{N(N-1)}{2})$. Over all $s$ satisfying this condition, compute the remainder when $\\sum_sd_i(s)$ is divided by $M$ for each $1\\le i\\le N.$\n\nINPUT FORMAT:\nThe only line of input consists of three space-separated integers $N, K,$ and $M$, followed by a new line. $M$ will be a prime number in the range $[10^8,10^9+9].$\n\nOUTPUT FORMAT:\nPrint $N$ space-separated integers denoting $\\sum_sd_i(s)\\pmod{M}$ for each \n$1\\le i\\le N.$\n\nBATCHING:\nTest cases 3-4 satisfy $N\\le 8.$ Test cases 5-7 satisfy $N\\le 20.$ Test cases 8-10 satisfy $N\\le 50.$",
    "num_tests": 14,
    "solution": "\n(Analysis by Benjamin Qi) \nFor $N\\le 20,$ any reasonable polynomial-time solution should work. One possible\napproach is to calculate the result for all $n\\le N, k\\le \\binom{n}{2}$ in\n$O(N^7).$\nFor additional points, we should find a way to compute $d_i(a)$ without\nexplicitly constructing the tree. The key condition is that $j$ is an ancestor\nof $i$ if $a[j]=\\min(a[i\\ldots j]),$ so it follows that\n$$d_i(a)=1+\\sum_{1\\le j<i}(a[j] == \\min(a[j\\ldots i]))+\\sum_{i<j\\le n}(a[j] == \\min(a[i\\ldots j])).$$\nLet's focus on counting the number of permutations $a$ such that\n$a[j] == \\min(a[i\\ldots j])$ for some fixed pair $(i,j)$ satisfying $i<j.$ We'll\ndo this by constructing $a$ one element at a time.\nFirst, we start with a sequence consisting of $a[i]$ only. Then $a[i+1]$ can be\neither greater than $a[i]$ or less than $a[i],$ contributing $0$ or $1$\ninversion. Then $a[i+2]$ can take on any of three different values relative to\n$a[i]$ and $a[i+1],$ contributing anywhere from $0$ to $2$ inversions.\nContinuing in this fashion, the possible numbers of inversions in the\nsub-permutation $a[i\\ldots j-1]$ can be represented by the polynomial product\n$$\\prod_{t=1}^{j-i}\\left(\\sum_{u=0}^{t-1}x^u\\right).$$\nThis is known as a generating function because we are encoding a sequence\nusing a polynomial. If we expand it and group together the terms with the same\npower of $x,$ then a term in the form $cx^d$ means that there are exactly $c$\npermutations with $d$ inversions.\nAdding $a[j]$ contributes $j-i$ inversions regardless of how many inversions\n$a[i\\ldots j-1]$ has. Then we should add the remaining elements of the\npermutation, each of which can go anywhere in the sorted order. Thus, the final\nresult is given by the generating function\n$$\\prod_{t=1}^{n}\\left(\\sum_{u=0}^{t-1}x^u\\right)\\cdot \\frac{1}{\\sum_{u=0}^{j-i}x^u}\\cdot x^{j-i}.$$\nThe first part of this product does not depend on $i$ or $j,$ and we can\ncalculate it in $O(N^3)$ time with prefix sums. We can divide it by\n$\\sum_{u=0}^{j-i}x^u$ in $O(N^2)$ time by reversing the process we used to\nmultiply.\nAfter dividing, all we need is the coefficient of $x^{k-(j-i)}.$ Since the\nproduct depends only on $j-i,$ we only need to do $N$ different divisions.\nAlternatively, we can maintain prefix and suffix products without needing to do\ndivision. The process for $i>j$ is almost exactly the same, except $a[j]$\ncontributes $0$ inversions rather than $i-j.$\nThe whole solution runs in $O(N^3)$ time and $O(N^2)$ memory. My code follows. It turns out that $M$\nbeing prime is irrelevant ...\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi; \n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \n#define pb push_back\n#define rsz resize\n#define sz(x) int(x.size())\n \nvoid setIO(string name) {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfreopen((name+\".in\").c_str(),\"r\",stdin);\n\tfreopen((name+\".out\").c_str(),\"w\",stdout);\n}\n\nint MOD;\nint n,k;\n\ntypedef int T;\nstruct mi {\n\tT val; \n\tmi() { val = 0; }\n\tmi(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tmi& operator+=(const mi& m) { \n\t\tif ((val += m.val) >= MOD) val -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((val -= m.val) < 0) val += MOD; \n\t\treturn *this; }\n};\ntypedef vector<mi> vmi;\n \nvoid ad(vmi& a, int b) { // multiply by (x^0+x^1+...+x^{b-1})\n\ta.rsz(sz(a)+b-1);\n\tR0F(i,sz(a)-b) a[i+b] -= a[i];\n\tFOR(i,1,sz(a)) a[i] += a[i-1];\n}\nvoid sub(vmi& a, int b) {\n\tROF(i,1,sz(a)) a[i] -= a[i-1];\n\tF0R(i,sz(a)-b) a[i+b] += a[i];\n\ta.rsz(sz(a)-b+1); \n}\nmi get(vmi& a, int b) {\n\tif (b < 0 || b >= sz(a)) return 0;\n\treturn a[b];\n}\n \nint main() {\n\tsetIO(\"treedepth\"); \n\tcin >> n >> k >> MOD;\n\tvmi v = {1}; FOR(i,1,n+1) ad(v,i);\n\tvmi ans(n,v[k]);\n\tFOR(dif,1,n) {\n\t\tsub(v,dif+1);\n\t\tmi x = get(v,k-dif), y = get(v,k);\n\t\tad(v,dif+1);\n\t\tF0R(a,n-dif) {\n\t\t\tans[a] += x;\n\t\t\tans[a+dif] += y;\n\t\t}\n\t}\n\tF0R(i,n) cout << ans[i].val << ' ';\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "3 0 192603497\n",
        "output": "1 2 3\n"
      }
    ],
    "description_no_samples": "In a distant galaxy, a team of explorers is tasked with mapping star systems using a special method that relies on star proximity. \n\nTo perform the mapping, the team starts with a permutation $s=\\{s_1,s_2,\\ldots,s_N\\}$ of the integers $1\\ldots N$, where $N\\le 300$. They then run the following procedure with arguments $1$ and $N.$\n\nexplore(l,r):\n  if l > r, return empty star cluster;\n  x = argmin_{l <= i <= r} s_i; // index of closest star s_i in {s_l,...,s_r}\n  return a star cluster with x as the core, \n    explore(l,x-1) as the left sub-cluster,\n    explore(x+1,r) as the right sub-cluster;\n\nFor example, the permutation $\\{3,2,5,1,4\\}$ organizes the stars into the following cluster:\n\n    4\n   / \\\n  2   5\n / \\ \n1   3\n\nLet $d_i(s)$ denote the distance of star $i$ from the core of the cluster corresponding to $s,$ meaning the number of stars on the path from $s_i$ to the core. In the above example, $d_4(s)=1, d_2(s)=d_5(s)=2,$ and $d_1(s)=d_3(s)=3.$\n\nThe number of proximity inversions of $s$ is equal to the number of pairs of stars $(i,j)$ such that $1\\le i<j\\le N$ and $s_i>s_j.$ The explorers know that the $s$ that will be used to organize the stars has exactly $K$ proximity inversions $(0\\le K\\le \\frac{N(N-1)}{2})$. Over all $s$ satisfying this condition, compute the remainder when $\\sum_sd_i(s)$ is divided by $M$ for each $1\\le i\\le N.$\n\nINPUT FORMAT:\nThe only line of input consists of three space-separated integers $N, K,$ and $M$, followed by a new line. $M$ will be a prime number in the range $[10^8,10^9+9].$\n\nOUTPUT FORMAT:\nPrint $N$ space-separated integers denoting $\\sum_sd_i(s)\\pmod{M}$ for each \n$1\\le i\\le N.$\n\nBATCHING:\nTest cases 3-4 satisfy $N\\le 8.$ Test cases 5-7 satisfy $N\\le 20.$ Test cases 8-10 satisfy $N\\le 50.$",
    "num_samples": 2,
    "mapping": [
      "BST -> star cluster",
      "permutation a -> permutation s",
      "integers -> stars",
      "inversions -> proximity inversions",
      "depth -> distance",
      "node -> star",
      "root -> core"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  },
  "818_1_platinum_cow_gymnasts": {
    "name": "Cow Gymnasts",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=818",
    "test_data_link": "http://www.usaco.org/current/data/gymnasts_platinum_feb18.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_gymnasts_platinum_feb18.html",
    "contest_link": "http://www.usaco.org/index.php?page=feb18results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "818",
    "problem_id": "818_1_platinum_cow_gymnasts",
    "description": "In a distant galaxy, a species of intelligent alien creatures live on a series of interconnected space stations. These aliens, known as Zorblaxians, have decided to hold a grand event to showcase their coordination. The event involves $N$ space stations arranged in a circular orbit. Each station hosts a stack of alien pods, with between $1$ and $N$ pods per station. When the event begins, all stacks must simultaneously shift clockwise: the bottom pod in a stack remains stationary, the pod above it moves one station clockwise, the next pod moves two stations clockwise, and so on. The advanced technology of the Zorblaxians ensures that all pods will land on their intended stations without interference. Each station forms a new stack from the arriving pods, which remains stable. The event's organizer wants the spectacle to be particularly impressive if, after the shift, the new stack on each station contains the same number of pods as the original stack on that station. We call a configuration of stack sizes \"harmonious\" if it satisfies this condition. Your task is to compute the number of harmonious configurations. Since this number could be very large, provide the result modulo $10^9 + 7$. Two configurations are considered distinct if there is any station for which the configurations have a different number of pods. INPUT FORMAT: The input is a single integer, $N$ ($1 \\leq N \\leq 10^{12}$). OUTPUT FORMAT: A single integer giving the number of harmonious configurations modulo $10^9 + 7$.",
    "num_tests": 12,
    "solution": "\n(Analysis by  Dhruv Rohatgi )\nConsider any magical configuration. Let $m$ be the minimum number of cows in any\nstack, and consider some stack $i$ achieving this minimum. Then the $m-1$ stacks\nbefore it will all \"contribute\": that is, one cow from each of these stacks will\nland on stack $i$. But of course stack $i$ contributes to itself, so we have\nalready accounted for all $m$ cows which land on stack $i$. This means that\nstack $i-m$ (wrapping around the index if necessary) cannot contribute to stack\n$m$. So stack $i-m$ must also have only $m$ cows. Applying the above proof\nrepeatedly, we see that if $j \\equiv i \\pmod{g}$, where $g = \\gcd(N,m)$, then\nstack $j$ must have only $m$ cows.\nWe will show inductively that none of stacks $i-1, i-2, \\dots, i-g+1$ can have\nmore than $m+1$ cows. Start with stack $i-1$. If it had more than $m+1$ cows,\nthen it would contribute to stack $i+m$. But we know that stack $i+m$ has only\n$m$ cows, and we know that these $m$ cows come from stacks\n$i+1, i+2, \\dots, i+m$. So this is impossible.\nMore generally, consider stack $i-k$ for some $k>0$. There are two cases.\nIf stack $i-k+1$ has $m$ cows, then the logic we described for stack $i-1$\napplies: stack $i-k$ cannot contribute to stack $i-k+m+1$, so it must have at\nmost $m+1$ cows. \nIf on the other hand stack $i-k+1$ does not have $m$ cows, then by our inductive\nhypothesis it must have $m+1$ cows. This implies that every stack $j$, where\n$j \\equiv i-k+1 \\pmod{g}$, must have exactly $m+1$ cows: by a parallel\ninduction, we know that every such stack can have at most $m+1$ cows, and by the\nprevious periodicity fact we proved above, if any such stack had $m$ cows then\nstack $i-k+1$ would also have $m$ cows.\nSo in particular, stack $i-k+m+1$ has exactly $m+1$ cows. We know that each of\nthe stacks $i-k+2, i-k+3, \\dots, i-k+m+1$ contribute to stack $i-k+m+1$, simply\nbecause they all have at least $m$ cows. And we know that stack $i-k+1$\ncontributes, since it has $m+1$ cows. So stack $i-k$ must not contribute to\nstack $i-k+m+1$. We conclude that stack $i-k$ cannot have more than $m+1$ cows.\nThis argument shows that every stack has either $m$ or $m+1$ cows. Together with\nthe periodicity fact, this means that for every $j$, stack $j$ has the same\nnumber of cows as stack $j+g$. So the configuration is periodic with period $g$.\nIt is not hard to verify that any configuration satisfying these two properties\nis magical.\nNow that we have characterized magical configurations, it remains to count them.\nFix some $m$, and assume that $m < N$. Then by our characterization above, there\nare $2^{\\gcd(N,m)} - 1$ magical configurations for which the minimum number of\ncows in any stack is $m$. Taking care of the case $m = N$, the total number of\nmagical configurations is $$2 - 2^N + \\sum_{m=1}^N \\left ( 2^{\\gcd(m,N)} - 1 \\right ).$$ Calculating\nthis sum directly is too slow, and only receives partial credit. To speed it up,\nobserve that for a fixed gcd $g$, the summand $2^g$ is fixed. Furthermore, the\nnumber of times this summand appears in the sum is the number of $m$ with\n$1 \\leq m \\leq N$ and $\\gcd(m,N) = g$. Equivalently, it is the number of $m'$\nwith $1 \\leq m' \\leq \\frac{N}{g}$ and $\\gcd(m', \\frac{N}{g}) = 1$. But this is\nprecisely $\\varphi(\\frac{N}{g})$, the Euler totient function of $\\frac{N}{g}$.\nTherefore the sum is equal to\n$$2 - N - 2^N + \\sum_{g \\mid N} 2^g \\varphi(\\frac{N}{g}).$$\nTo efficiently compute this sum, we start by prime factorizing $N$ in\n$O(\\sqrt{N})$ time: simply divide out all prime divisors of magnitude at most\n$\\sqrt{N}$; the remaining number must be either $1$ or prime, since $N$ cannot\nhave multiple prime factors of magnitude greater than $\\sqrt{N}$.\nNow the $O(\\sqrt{N})$ divisors of $N$ can be enumerated quickly. For each\ndivisor, we use fast exponentiation to compute $2^g$, and we compute the totient\nfunction using the formula\n$$\\varphi(p_1^{e_1}p_2^{e_2}\\cdots p_i^{e_i}) = p_1^{e_1-1}p_2^{e_2-1}\\cdots p_i^{e_i-1}(p_1-1)(p_2-1)\\cdots(p_i-1).$$\nA simple (though by no means tight) bound on the overall time complexity is $O(\\sqrt{N}\\log N)$. Below is an implementation\nof the algorithm described above. Note that depth-first search is used to\niterate over the divisors of $N$, allowing the totient function to be computed\nwith only constant overhead.\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n \n \nvector<long long> p;\nvector<int> e;\nint ans;\nlong long origN;\n \nint fexp(int a,long long e)\n{\n\tif(e==0) return 1;\n\tint tmp = fexp(a,e/2);\n\ttmp = (tmp*((long long)tmp))%MOD;\n\tif(e&1) tmp = (tmp*((long long)a))%MOD;\n\treturn tmp;\n}\n \nlong long gcd(long long a,long long b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n \nvoid dfs(int i,long long cdiv, long long sdiv, long long smult)\n{\n\tif(i == p.size())\n\t{\n\t\tif(cdiv < origN)\n\t\t\tans = (ans + fexp(2,cdiv)*((long long)((origN/(cdiv*sdiv))*smult)))%MOD;\n\t\treturn;\n\t}\n\tfor(int j=0;j<e[i];j++)\n\t{\n\t\tdfs(i+1,cdiv,sdiv*p[i],smult*(p[i]-1));\n\t\tcdiv *= p[i];\n\t}\n\tdfs(i+1,cdiv,sdiv,smult);\n}\n \nint main()\n{\n\tlong long N;\n\tcin >> N;\n\torigN = N;\n\tint i = 2;\n\tlong long bound = N;\n\tfor(i=2;i*((long long)i) < bound;i++)\n\t\tif(N%i == 0)\n\t\t{\n\t\t\tint mult = 0;\n\t\t\twhile(N%i == 0)\n\t\t\t{\n\t\t\t\tmult++;\n\t\t\t\tN /= i;\n\t\t\t}\n\t\t\tp.push_back(i);\n\t\t\te.push_back(mult);\n\t\t}\n\tif(i*((long long)i) == bound && N%i == 0)\n\t{\n\t\tint mult = 0;\n\t\twhile(N%i == 0)\n\t\t{\n\t\t\tmult++;\n\t\t\tN /= i;\n\t\t}\n\t\tp.push_back(i);\n\t\te.push_back(mult);\n\t}\n\tif(N > 1)\n\t{\n\t\tp.push_back(N);\n\t\te.push_back(1);\n\t}\n\tdfs(0,1,1,1);\n\tans = (ans + MOD - (origN - 1)%MOD)%MOD;\n\tans = (ans+1)%MOD;\n\tcout << ans << '\\n';\n}\n\n",
    "runtime_limit_sentences": [],
    "memory_limit_sentences": [],
    "runtime_limit": 2,
    "memory_limit": 256,
    "samples": [
      {
        "input": "4",
        "output": "6"
      }
    ],
    "description_no_samples": "In a distant galaxy, a species of intelligent alien creatures live on a series of interconnected space stations. These aliens, known as Zorblaxians, have decided to hold a grand event to showcase their coordination. The event involves $N$ space stations arranged in a circular orbit. Each station hosts a stack of alien pods, with between $1$ and $N$ pods per station. When the event begins, all stacks must simultaneously shift clockwise: the bottom pod in a stack remains stationary, the pod above it moves one station clockwise, the next pod moves two stations clockwise, and so on. The advanced technology of the Zorblaxians ensures that all pods will land on their intended stations without interference. Each station forms a new stack from the arriving pods, which remains stable. The event's organizer wants the spectacle to be particularly impressive if, after the shift, the new stack on each station contains the same number of pods as the original stack on that station. We call a configuration of stack sizes \"harmonious\" if it satisfies this condition. Your task is to compute the number of harmonious configurations. Since this number could be very large, provide the result modulo $10^9 + 7$. Two configurations are considered distinct if there is any station for which the configurations have a different number of pods. INPUT FORMAT: The input is a single integer, $N$ ($1 \\leq N \\leq 10^{12}$). OUTPUT FORMAT: A single integer giving the number of harmonious configurations modulo $10^9 + 7$.",
    "num_samples": 1,
    "mapping": [
      "cows -> alien pods",
      "platforms -> space stations",
      "ringmaster -> event's organizer",
      "magical -> harmonious",
      "stacks -> stacks of pods",
      "fall -> shift"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text"
  },
  "649_1_platinum_bull_in_a_china_shop": {
    "name": "Bull in a China Shop",
    "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=649",
    "test_data_link": "http://www.usaco.org/current/data/bcs_platinum_open16.zip",
    "solution_link": "http://www.usaco.org/current/data/sol_bcs_platinum_open16.html",
    "contest_link": "http://www.usaco.org/index.php?page=open16results",
    "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
    "problem_level": "platinum",
    "cp_id": "649",
    "problem_id": "649_1_platinum_bull_in_a_china_shop",
    "description": "In a distant galaxy, an ancient artifact known as the Cosmic Jigsaw is on display in the Museum of Galactic Wonders. This artifact is an intricate mosaic depicting the history of the universe, represented by an $N \\times M$ grid of symbols, each symbol being a unique color indicating a significant cosmic event or entity.\n\nDue to an unfortunate cosmic storm, the artifact was shattered into 3 segments, mixing with $K$ other cosmic fragments that were being transported through the galaxy ($4 \\leq K \\leq 100$). Each of the $K$ fragments is described by a grid of symbols, just like the original artifact.\n\nYour mission is to determine how many sets of 3 fragments (out of the $K$ fragments scattered in space) could be reassembled to recreate the Cosmic Jigsaw.\n\nThe fragments might have been flipped vertically or horizontally, or rotated by some multiple of 90 degrees. Therefore, given the original grid as well as $K$ grids describing fragments, you want to find sets of 3 fragments that can be joined together to form the original mosaic, allowing the fragments to be translated, flipped, or rotated multiples of 90 degrees. When superimposed, the 3 fragments should exactly form the original mosaic, with each symbol in the original mosaic represented in exactly one of the fragments.\n\nINPUT FORMAT:\nThe first line contains a single integer $K$. Following that will be $K + 1$ fragment descriptions. The first description will describe the original Cosmic Jigsaw, the following $K$ descriptions will be of the scattered fragments.\n\nEach description begins with a line containing two integers $R$ and $C$ ($1 \\le R, C \\le 100$). The following $R$ lines contain $C$ lowercase alphabet characters describing the color of each cell. Each fragment will be horizontally/vertically connected and have at least one non-empty cell.\n\nOUTPUT FORMAT:\nOutput the number of triples $i, j, k$ ($i < j < k$) such that fragments $i$, $j$, and $k$ can be arranged to form the original Cosmic Jigsaw.",
    "num_tests": 10,
    "solution": "\n(Analysis by Mark Gordon)\nThe most basic approach to this problem would loop over tuples of three pieces\nand try all offsets and orientations of the pieces to try and make the figurine.\nObviously, this approach would be too slow with $k^3$ tuples and $(8N^2)^3$\nways to arrange them.\nHowever,  The need to try all offsets can be eliminated by simply trying the\noffset such that the bottom most (breaking ties by rightmost) uncovered cell is\ncovered by the new piece.  We can do this because this cell must eventually be\ncovered and there is at most one way to do it for a given piece and orientation.\nThis observation alone can bring us down to a $O(8k^3N^2)$ solution.  The next\npiece of the puzzle is to use\npolynomial\nhashing to eliminate a $O(k)$ factor on the critical path.  After placing\nthe first two pieces we can calculate the appropriate offset of the final piece\nand quickly test if its hash is one of the input pieces.\nThe final bit of the puzzle is how to calculate offsets quickly.  This amounts\nto being able to quickly calculate the position of the bottom most, right most\nuncovered cell.  This can be done in $O(log N)$ time by precomputing the suffix sums in \nRow Major Order and binary searching to\nfind the last non-zero suffix sum when subtracting out the suffix sums of already placed pieces.0\nHere's my solution to this problem annotated with what each section of code aims\nto accomplish.\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef vector<string> pat;\n\nint POLYMOD[2] = {\n  975919579,\n  975979579,\n};\n\nint POLYMUL[2] = {\n  382737283,\n  382878283,\n};\n\n#define MAXCOL 1010\n#define MAXROW 510\n\n#define HASHES 2\n#define MAXPOW (MAXROW * MAXCOL)\n\nint POWTAB[HASHES][MAXPOW];\n\nvoid init_tab() {\n  if (POWTAB[0][0]) {\n    return;\n  }\n  for (int i = 0; i < HASHES; i++) {\n    for (int j = POWTAB[i][0] = 1; j < MAXPOW; j++) {\n      POWTAB[i][j] = (1ll * POWTAB[i][j - 1] * POLYMUL[i]) % POLYMOD[i];\n    }\n  }\n}\n\n/* Tracks a polynomial hash over a 2D array. */\nstruct xhash {\n  xhash() {\n    init_tab();\n    memset(H, 0, sizeof(H));\n  }\n\n  xhash(const pat& p) {\n    init_tab();\n    memset(H, 0, sizeof(H));\n\n    /* Calculate the hash of the given input matrix. We linearize the array by\n     * setting a[r * MAXCOL + c] = p[i][j] and then apply a standard polynomial\n     * hash. */\n    for (int i = 0; i < p.size(); i++) {\n      for (int j = 0; j < p[0].size(); j++) {\n        if (p[i][j] == '.') {\n          continue;\n        }\n\n        /* We set v this way to ensure that v_1 - v_2 could never represent a\n         * valid character.  This is important for ensuring the integrity of\n         * subtracting two hashes. */\n        int v = 26 + (p[i][j] - 'a');\n        for (int k = 0; k < HASHES; k++) {\n          H[k] = (H[k] + 1ll * POWTAB[k][i * MAXCOL + j] * v) %\n                      POLYMOD[k];\n        }\n      }\n    }\n  }\n\n  void offset(int r, int c) {\n    /* Offsetting the matrix by (r, c) translates into offsetting the\n     * linearized array by r * MAXCOL + c.  Therefore we multiply each hash\n     * by x^(r * MAXCOL + c). */\n    for (int i = 0; i < HASHES; i++) {\n      H[i] = (1ll * H[i] * POWTAB[i][r * MAXCOL + c]) % POLYMOD[i];\n    }\n  }\n\n  /* Compute the difference of hashes.  This gives you a hash of what would\n   * remain in *this if you got rid of everything present in x.  In the case\n   * that x isn't actually a subset of *this the hash should just represent\n   * garbage and won't get matched. */\n  xhash operator-(const xhash& x) const {\n    xhash nh;\n    for (int i = 0; i < HASHES; i++) {\n      nh.H[i] = H[i] - x.H[i];\n      if (nh.H[i] < 0) {\n        nh.H[i] += POLYMOD[i];\n      }\n    }\n    return nh;\n  }\n\n  bool operator==(const xhash& x) const {\n    return !memcmp(H, x.H, sizeof(H));\n  }\n\n  bool operator<(const xhash& x) const {\n    return memcmp(H, x.H, sizeof(H)) < 0;\n  }\n\n  int H[HASHES];\n};\n\n/* For use in C++'s unordered_map. */\nstruct xhash_downhash {\n  int operator()(const xhash& h) const {\n    return h.H[0];\n  }\n};\n\n/* Vertically flips the pattern. */\nvoid vflip(pat& p) {\n  int R = p.size();\n  for (int i = 0; i < R - i - 1; i++) {\n    p[i].swap(p[R - i - 1]);\n  }\n}\n\n/* Rotates the pattern 90 degrees. */\nvoid rotate(pat& p) {\n  int R = p.size();\n  int C = p[0].size();\n  pat op(C, string(R, '.'));\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      op[C - j - 1][i] = p[i][j];\n    }\n  }\n  p = op;\n}\n\n/* Read in a pattern and canonicalize it. */\npat read_pat() {\n  int R, C;\n  cin >> R >> C;\n\n  pat res(R);\n  for (int i = 0; i < R; i++) {\n    cin >> res[i];\n  }\n\n  /* Remove unneeded padding from the sides. */\n  int mnr = R, mxr = 0;\n  int mnc = C, mxc = 0; \n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      if (res[i][j] != '.') {\n        mnr = min(mnr, i);\n        mxr = max(mxr, i + 1);\n        mnc = min(mnc, j);\n        mxc = max(mxc, j + 1);\n      }\n    }\n  }\n\n  pat nres;\n  for (int i = mnr; i < mxr; i++) {\n    nres.push_back(res[i].substr(mnc, mxc - mnc));\n  }\n\n  /* Try all orientations and take the lexicographically least one.  This\n   * ensures that all equivalant piece representations are actually equal. */\n  res = nres;\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 4; j++) {\n      if (nres < res) {\n        res = nres;\n      }\n      rotate(nres);\n    }\n    vflip(nres);\n  }\n  return res;\n}\n\n\ntypedef vector<vector<int> > sum_table;\n\nsum_table target_sums;\nvector<sum_table> piece_sums;\n\n/* Calculate the number of non-empty entries after every position in the\n * linearized array.  This gets used in find_offset later. */\nsum_table calc_sums(const pat& p) {\n  int N = p.size();\n  int M = p[0].size();\n  sum_table sums(N, vector<int>(M));\n\n  int lst = 0;\n  for (int i = N - 1; i >= 0; i--) {\n    for (int j = M - 1; j >= 0; j--) {\n      if (p[i][j] != '.') {\n        lst++;\n      }\n      sums[i][j] = lst;\n    }\n  }\n  return sums;\n}\n\n/* Efficiently find the last non-zero position in base after subtracting\n * (possibly) several other matricies. */\npair<int, int> find_offset(const sum_table& base,\n                           const vector<int>& subtract_inds = {},\n                           const vector<pair<int, int> >& offsets = {}) {\n  /* Binary search over the linearized array. */\n  int N = base.size();\n  int M = base[0].size();\n  int lo = 0;\n  int hi = N * M - 1;\n  while (lo < hi) {\n    int md = (lo + hi + 1) / 2;\n    int r = md / M;\n    int c = md % M;\n\n    /* Calculate how many non-zero entries there are after (r, c) in the\n     * linearized array. */\n    int val = base[r][c];\n    for (int i = 0; i < subtract_inds.size(); i++) {\n      int j = subtract_inds[i];\n      int er = r - offsets[i].first;\n      int ec = c - offsets[i].second;\n      int PN = piece_sums[j].size();\n      int PM = piece_sums[j][0].size();\n      if (ec >= PM) {\n        er++;\n        ec = 0;\n      }\n      if (er >= PN) {\n        /* Do nothing. */\n      } else if (er < 0) {\n        val -= piece_sums[j][0][0];\n      } else {\n        val -= piece_sums[j][er][max(0, ec)];\n      }\n    }\n\n    /* Search right if there are more non-zero entries, otherwise search left.\n     */\n    if (val) {\n      lo = md;\n    } else {\n      hi = md - 1;\n    }\n  }\n\n  return make_pair(lo / M, lo % M);\n}\n\nint main() {\n  freopen(\"bcs.in\", \"r\", stdin);\n  freopen(\"bcs.out\", \"w\", stdout);\n  int K; cin >> K;\n  pat target = read_pat();\n\n  int R = target.size();\n  int C = target[0].size();\n  xhash target_hash = target;\n  target_sums = calc_sums(target);\n\n  /* Read in the pieces into a map after canonicalization.  Keep track of\n   * how many times an equivalant piece occurs and deduplicate. */\n  map<pat, int> piece_map;\n  for (int i = 0; i < K; i++) {\n    piece_map[read_pat()]++;\n  }\n\n  /* Build data structures based on the deduplicated pieces in each of\n   * their orientations. */\n  vector<int> piece_counts;\n  vector<pair<int, int> > piece_offsets;\n  vector<int> piece_index;\n  vector<xhash> piece_hashes;\n\n  unordered_map<xhash, int, xhash_downhash> the_hash;\n  for (auto it : piece_map) {\n    pat p = it.first;\n    int index = piece_counts.size();\n    piece_counts.push_back(it.second);\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < 4; k++) {\n        if (p.size() > R || p[0].size() > C) {\n          rotate(p);\n          continue;\n        }\n\n        xhash h(p);\n        piece_sums.push_back(calc_sums(p));\n        piece_offsets.push_back(find_offset(piece_sums.back()));\n        piece_hashes.push_back(h);\n        piece_index.push_back(index);\n\n        h.offset(R - piece_offsets.back().first,\n                 C - piece_offsets.back().second);\n\n        /* Deduplication ensures that no two pieces should have the same hash.\n         */\n        the_hash[h] = index;\n        rotate(p);\n      }\n      vflip(p);\n    }\n  }\n\n  set<tuple<int, int, int> > sols;\n  pair<int, int> base_1 = find_offset(target_sums);\n  for (int i = 0; i < piece_hashes.size(); i++) {\n    /* Find the offset so that the last item in piece_hashes[i] covers the last\n     * item in the target. */\n    pair<int, int> off_1 = base_1;\n    off_1.first -= piece_offsets[i].first;\n    off_1.second -= piece_offsets[i].second;\n    if (off_1.first < 0 || off_1.second < 0) {\n      continue;\n    }\n\n    xhash hash_1 = piece_hashes[i];\n    hash_1.offset(off_1.first, off_1.second);\n\n    pair<int, int> base_2 = find_offset(target_sums, {i}, {off_1});\n    for (int j = 0; j < piece_hashes.size(); j++) {\n      /* Find the offset so that the last uncovered item in * piece_hashes[j]\n       * covers the last still uncovered item in the target. */\n      pair<int, int> off_2 = base_2;\n      off_2.first -= piece_offsets[j].first;\n      off_2.second -= piece_offsets[j].second;\n      if (off_2.first < 0 || off_2.second < 0) {\n        continue;\n      }\n\n      xhash hash_2 = piece_hashes[j];\n      hash_2.offset(off_2.first, off_2.second);\n\n      /* Canonicalize the position of the last still uncovered item of the\n       * target so we can look up if we have a matching hash. */\n      pair<int, int> off_3 = find_offset(target_sums, {i, j}, {off_1, off_2});\n      if (off_3.first < 0 || off_3.second < 0) {\n        continue;\n      }\n      xhash hash_remains = target_hash - hash_1 - hash_2;\n      hash_remains.offset(R - off_3.first, C - off_3.second);\n\n      /* Check if we have a match, if we do insert it into the solutions list.\n       */\n      auto it = the_hash.find(hash_remains);\n      if (it != the_hash.end()) {\n        int L[3];\n        L[0] = piece_index[i];\n        L[1] = piece_index[j];\n        L[2] = it->second;\n        sort(L, L + 3);\n        sols.insert(make_tuple(L[0], L[1], L[2]));\n      }\n    }\n  }\n\n  /* Convert the solutions list into an actual result on the input array.  This\n   * takes into account the pieces that were deduplicated in the beginning. */\n  int result = 0;\n  for (auto sol : sols) {\n    int c0 = piece_counts[get<0>(sol)];\n    int c1 = piece_counts[get<1>(sol)];\n    int c2 = piece_counts[get<2>(sol)];\n    if (get<0>(sol) == get<2>(sol)) {\n      result += c0 * (c0 - 1) * (c0 - 2) / 6;\n    } else if (get<0>(sol) == get<1>(sol)) {\n      result += c0 * (c0 - 1) / 2 * c2;\n    } else if (get<1>(sol) == get<2>(sol)) {\n      result += c0 * c1 * (c1 - 1) / 2;\n    } else {\n      result += c0 * c1 * c2;\n    }\n  }\n  cout << result << endl;\n\n  return 0;\n}\n\n",
    "runtime_limit_sentences": [
      "\n\nNote that this problem has a time limit of 6 seconds per test case (and twice that for Java and Python submissions)."
    ],
    "memory_limit_sentences": [],
    "runtime_limit": 12,
    "memory_limit": 256,
    "samples": [
      {
        "input": "5\n5 5\naaaaa\n..a..\nbbabb\n..a..\naaaaa\n3 5\n..abb\n..a..\naaaaa\n5 2\na.\na.\naa\na.\na.\n1 2\nbb\n1 5\nbbabb\n2 5\naaaaa\n..a..\n",
        "output": "3\n"
      }
    ],
    "description_no_samples": "In a distant galaxy, an ancient artifact known as the Cosmic Jigsaw is on display in the Museum of Galactic Wonders. This artifact is an intricate mosaic depicting the history of the universe, represented by an $N \\times M$ grid of symbols, each symbol being a unique color indicating a significant cosmic event or entity.\n\nDue to an unfortunate cosmic storm, the artifact was shattered into 3 segments, mixing with $K$ other cosmic fragments that were being transported through the galaxy ($4 \\leq K \\leq 100$). Each of the $K$ fragments is described by a grid of symbols, just like the original artifact.\n\nYour mission is to determine how many sets of 3 fragments (out of the $K$ fragments scattered in space) could be reassembled to recreate the Cosmic Jigsaw.\n\nThe fragments might have been flipped vertically or horizontally, or rotated by some multiple of 90 degrees. Therefore, given the original grid as well as $K$ grids describing fragments, you want to find sets of 3 fragments that can be joined together to form the original mosaic, allowing the fragments to be translated, flipped, or rotated multiples of 90 degrees. When superimposed, the 3 fragments should exactly form the original mosaic, with each symbol in the original mosaic represented in exactly one of the fragments.\n\nINPUT FORMAT:\nThe first line contains a single integer $K$. Following that will be $K + 1$ fragment descriptions. The first description will describe the original Cosmic Jigsaw, the following $K$ descriptions will be of the scattered fragments.\n\nEach description begins with a line containing two integers $R$ and $C$ ($1 \\le R, C \\le 100$). The following $R$ lines contain $C$ lowercase alphabet characters describing the color of each cell. Each fragment will be horizontally/vertically connected and have at least one non-empty cell.\n\nOUTPUT FORMAT:\nOutput the number of triples $i, j, k$ ($i < j < k$) such that fragments $i$, $j$, and $k$ can be arranged to form the original Cosmic Jigsaw.",
    "num_samples": 1,
    "mapping": [
      "original glass cow -> Cosmic Jigsaw",
      "figurine -> artifact",
      "pieces -> fragments",
      "bull -> cosmic storm",
      "shop -> galaxy",
      "shopkeeper -> galactic curator"
    ],
    "transformer_code": "def transform_input(text: str) -> str:\n    return text\n\ndef transform_output(text: str) -> str:\n    return text\n"
  }
}